namespace Qorpent.Patterns
	class pattern "Описание паттернов проектирования" abstract
		element motivation "Элемент мотивации паттерна"
			strategy="""
				Стратегическая задача мотивации, связанная со стратегией проектирования - 
				уменьшение дублирования (ndub), - базовая ИТ-стратегия, исключает хаотизацию проекта
				сужение зоны контакта (spot), - базовая ИТ-стратегия, упрощает интеграцию, упрощает тестирование, уменьшает требования к компетенции программиста
				стабильность экспортируемого API (stab) - повышает сопровождаемость, тестируемость кода, простоту смены версии
				у любой мотивации должна быть такая конечная цель
			"""
		element bind "Связь с другим паттерном"
		element implementation "Реализация"		
		element sample "Пример кода"
	

	pattern Configuration "Конфигурация"
		implementation
			class worker "Есть некий рабочий класс"
				require big_set_of_parameters "В своей работе он использует множество параметров"
				require api_only_run_commands "Но при этом в API мы хотим держать только минимальный набор команд, необходимых для интерфейса"
				solution parameters_moved_to "Решение - вынести все параметры, связанные с настройкой и внутренней работой в отдельный класс" ref=workerConfig 
				solution can_give_access "Если желателен доступ к параметрам, можно всю конфигурацию вынести в параметр" 
					hint can_be_readonly "Если конфигурация инициализирует класс и связна с ним, резонно сделать ее только для чтения"
					hint can_be_immutable "Если в процессе работы конфигурация не должна меняться, в классе можно хранить ее неизменяемый слепок"
			class workerConfig "Включает в себя все параметры для рабочего класса"
				require serializeable "Так как конфигурация очень часто считывается или записывается или отрисвывается она должна быть сериализуемой"
				require hash_functions "Настоятельно рекомендуется реализовать весь набор GetHashCode, Equal и ToString() чтобы конфигурации могли служить дескрипторами"
				require immutable_support "Настоятельно рекомендуется делать в классе конфига 'запирающий ключ' - метод, после вызова которого свойства конфига больше менять нельзя"
				
		motivation encapsulate_ctor_parameters "Инкапсуляция параметров конструктора класса" strategy=stab
			comment : """
				Так как вся настройка перемещается в класс конфигурации, основной класс может иметь очень простое настроечное API и ничего не выводить в виде отдельных парамтеров наружу,
				соответственно при работе с классом не требуется знать варианты конструкторов и он легко может использоваться в качестве основания генерика с ограничением new()
			"""
		motivation defaults_complexity "Целостность умолчаний и настроек класса" strategy=ndub
			comment : """
				Множество параметров порождают проблему их верификации и установки умолчаний и/или типовых конфигураций,
				так как сам класс может не знать своих умолчаний, и более того если речь идет о полиморфном семействе, то получается, что код верификации и/или
				установки дефолтов начинает распределяться по классу и семействам, вызывать лишние проверки и т.д. 
				Но в случае с отдельно вынесенной конфигурации - в ней вполне без нарушения ее предназначения могут быть сделаны все сверки и установки и подготовка ДО передачи
				их в класс, соответственно целевой рабочий класс избавляется от необходимости держать лишний код валидации, а вся логика валидации инкапсулируется без дублирования в одном месте
			"""
		sample allin "Все рекомендации в одном флаконе (кроме тривиальных GetHashCode,Equals,ToString)" : (
			public class WorkerConfig {
				//признак неизменяемой конфигурации (immutable_support)
				private bool _immutable;
				//некий набор параметров (тут мы понятно показываем в примере только один)
				public string Param1 {
					get {return _param1;}
					set {
						//защита от изменений в неизменяемом режиме
						if(_immutable && _param1!=value) throw new Exception ("cannot change - immutable");
						_param1 = value;
					}
				}
				//некий метод Setup, должен вызываться до передачи конфига классу, fluen-style всегда неплохо
				public WorkerConfig Setup(){
					if(_immutable)return;
					//некая логика доводки конфигурации
					if(string.IsNullOrWhitespace(Param1)){
						Param1 = "MyDefault";
					}
					return this;
				}
				//метод получения защищенной от записи копии
				public WorkerConfig ToIm0s0svmutable(){
					if(_immutable)return this; //зачем плодить копии, если эта уже не меняется
					var result = MemberwiseCopy() as WorkerConfig;
					result._immutable = true;
					return result;
				}
				//некая инкапсуляция дефолта
				public static WorkerConfig CreateDefault(){
					return new WorkerConfig().Setup();
				}
			}
			
			//вот чего ждет собственно клиент
			public interface IWorker{
				void DoWork();
				// в принципе можно и без этого метода, но так все же логичнее
				void Initialize(WorkerConfig config);
			}
			public class Worker : IWorker {
			
				//(encapsulate_ctor_parameters) no ctor required, default can be used, Initialize method used instead
				public Worker(){
					// у нас всегда есть конфиг
					_config = WorkerConfig.CreateDefault();
				}
				// если кому-то что-то надо особое, то пусть вызывают этот метод
				public void Initialize ( WorkerConfig config) {
					//в нашем примере мы считаем, что Worker работает со своей неизменяемой копиецй
					_config = config.Setup().ToImmutable();
					//дальше может еще какая-то логика
				}
				WorkerConfig _config;
				//если кому-то очень надо, он доберется до неизменяемого и доступного только на чтение конфига
				public WorkerConfig Config {get{return _config;}}
				
				//некий рабочий метод
				public void DoWork(){
					//мы уверены, что _config не 0 и что в нем корректный Param1, нам не надо  никаких проверок или чего-то такого и мы знаем, что никто не испортит Param1
					Console.WriteLine(_config.Param1.ToUpper());
				}
			}
		
		)
	
	pattern Factory "Фабрика"
		motivation hide_low_level_polimorphism "Скрытие низкоуровнего полиморфизама" strategy=spot
			comment : """
				Если полиморфизм семейства связан не с характером использования, а с особенностями реализации API нижнего уровня, то 
				при сохранении полиморфизма во внешнем API мы вынуждаем вызывающую сторону знать эти особенности, которые вне его
				компетенции и точно знать класс
			"""
		motivation less_visibility "Уменьшение уровня видимости классов сборки" strategy=spot
			comment : """
				При решении вопроса со скрытием полиморфизма можно уменьшить и уровень видимости классов до internal (тестированию это не помешает),
				что снижает необходимость в лишних комментариях и сопровождении документации на библиотеку
			"""
		bind ^Configuration
	
	
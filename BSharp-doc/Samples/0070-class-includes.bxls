# Copyright Comdiv 2007-2013
# qorpent.sys B#

###############################################
# ДАННЫЙ ПРИМЕР ПОКАЗЫАЕТ                     #
# ЛОГИКУ РАБОТЫ ПРОСТРАНСТВ ИМЕН			  #
# режим работы с тестом                       #
# Interpolation = true                        #
# BxlSharp = true                             #
###############################################

# в документе 0050 было рассказано о манипуляциях 
# и перекрытиях с классом ДО собственно компиляции 
# но есть и обратная ситуация
# иногда возникает необходимость включить уже готовый класс (точнее его копию)
# в состав другого класса при этом в нужное место
# static для этого не годится, так как класс который включается
# во-первых не обязан знать что его включают, а во-вторых
# импорт статика производится только в корень класса

# итак, сооружаем на B# автомобиль

# есть некое колесо
class coleso price=10000 abstract
# есть 4 купленных колеса
coleso col_fl place='front_left'
coleso col_fr place='front_right'
coleso col_rl place='rear_left'
coleso col_rr place='rear_right'
# есть вообще фара
class fara price=5000 abstract
# и две купленные фары
fara f_left place='left'
fara f_right place='right'
# ну и есть машина
class car
	kuzov
		fornt
			include f_left
			include f_right
	podveska
		front
			include col_fl
			include col_fr
		rear
			include col_rl
			include col_rr
# все вроде бы понятно - собрали одни классы, вставили в другие
# однако и тут не все так просто. Можно задаться вопросом
# а зачем нам собственно отдельно держать в коде каждое колесо?
# а зачем нам стряпать им коды и все такое?
# на это в B# тоже есть ответ "поздняя интерполяция"
# это специальный режим интерполяции, выполняемый после include,
# чтобы подставлять им параметры надо использовать не ${...}, а %{...}
# смотрим, и даже усложним пример:

# есть некое колесо
class coleso abstract
	# но с заготовочкой на "установку куда-то"  и с радиусом
	place='%{_place}' 
	radius='%{_radius}'
# есть вообще фара
class fara price=5000 abstract
	place='%{_place}' # тоже заготовочкой на "установку куда-то"
# ну и есть абстрактная машина (как мы видим мы просто пишем, что нам нужны колеса, 
# никакие коды для этого не нужны
class car abstract
	number ='${_number}'
	kuzov
		fornt
			# мы больше нигде не заботимся о кодах, мы просто ставим фары!!!
			include fara _place=front_left 
			include fara _place=front_right
		bagazhnik if='_bagazh'
	podveska
		# мы больше нигде не заботимся о кодах, мы просто ставим колеса куда надо!!!
		front
			include coleso _place=front_left
			include coleso _place=front_right
		rear
			include coleso _place=rear_left
			include coleso _place=rear_right
	salon
		magnitola if='_magnitola'
	
# и конкретная машина с 13 радиусом колес, без багажника, но с магнитолой
car our_matrix _number='a666aa96'  _radius=13 _magnitola=true

			
# и опять мы добились читаемости и чистоты кода:
# нам не пришлось плодить ненужных классов колес и потом синхронить их коды
# в машину
# мы можем наделать хоть 100500 машин с любым количеством где угодно установленных
# колес абсолютно не напрягаясь!

# но и это еще не все, есть маленькое замечаение. Допустим возьмем колсеты

class colset abstract
colset A
	col A
	col B
	col C
	
colset B
	include A
	col D
	col E

# очевидно, что мы получаем не совсем что ждем...
colset B
	colset A
		col A
		col B
		col C
	col D
	col E

# а хотим допустим именно просто плоский список колонок
# но и тут есть заготовочка - спец. слово body, которое 
# указывает компилятору не копировать класс целиком, а только
# его внутренности
class colset abstract
colset A
	col A
	col B
	col C
	
colset B
	include A body # теперь все будет как надо !!!
	col D
	col E	
	
# таким образом резюмируем уже несколько примеров:
# 1) наследование, пространства имен, статики и интерполяция - предназначены для увязывания 
#    иерархий в рамках одного функционального назначения и работают по принципу объединения шаблонов
# 2) перекрытие  - предназначено для простой коррекции имеющегося кода при адаптации к конкретным условиям
# 3) включения - механизм объединения в комплексы разнородных сущностей
# Все эти механизмы практически исчерпыающим образом закрывают вообще все известные описания
# взаимоувязки сущностей
# Используйте B# и ваща жизнь станет легче! ${Be Sharp!}
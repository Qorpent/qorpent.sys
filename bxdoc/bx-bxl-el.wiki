{style:float:right;}Языки BXL/B# - руководство{style}
{style:float:left;}Элементы в BXL{style}
[bx-index Вернуться к оглавлению]

= Элементы в BXL

Синтаксис BXL элементов достаточно подробно описан в [bx-bxl-syntax общий синтаксис BXL]

Здесь подробнее остановимся на более точных нюансах

== BXL ***неявно*** поддерживает корневой элемент

XML ***требует*** наличия корневого элемента, BXL ***не требует*** соответственно при парсе создается условный корневой элемент ***root***.

BXL тяготеет к тому, чтобы легко расщепляться на модули и отдельные файлы по границам элементов, соответственно использование корневого элемента внесло бы необходимость контроля его атрибутов и пространств имен и  проверять их критичность для переносимого элемента. Поэтому в BXL поддержка корневого элемента  неявная, а разрешенный по умолчанию вариант парсинга с определением атрибутов корневого элемента, может быть отключен для более строгого контроля за исходным кодом.



[[code]]
##showroot -- это спецтег для wiki, чтобы в результатах показывался корневой элемент
child_1
child_2
[[/code]]
[[script-last type=bxl]]

/ Корневой элемент обычно используется ***только*** для определения префиксов пространств имен

Такой код будет корректен

[[code]]
##showroot -- это спецтег для wiki, чтобы в результатах показывался корневой элемент
x=1
child_1
child_2
[[/code]]
[[script-last type=bxl]]

Также для тех случаев, когда необходимо использование корневых атрибутов, они также могут использоваться,
но это синтаксически не так чисто. Так как определения пространств и атрибутов имеют один синтаксис,
то потребуется наличие хотя бы одного элемента

[[code]]
##showroot -- это спецтег для wiki, чтобы в результатах показывался корневой элемент
child_1
x=1
child_2
[[/code]]
[[script-last type=bxl]]

/ Поддержка корневых атрибутов по сути неоднозначная языковая конструкция , пользоваться ими рекомендуем только при явной необходимости

Однако в подавляющем большинстве примеров будет использоваться вариант представления результатов парсинга  и компиляции без корневого элемента и корневые атрибуты соответственно будут проигнорированы.

[[code]]
# не включаем опцию showroot
child_1
x=1
child_2
[[/code]]
[[script-last type=bxl]]

== При наборе вложенных элементов внимательно следите за табуляцией


BXL пытается нормализовать табуляцию руководствуясь простыми правилами
% ***если уровень вложенного элемента БОЛЬШЕ уровня предыдущего, то независимо от количества табуляций, считать, что был добавлен один уровень*** - это позволяет использовать для обозначения уровня как одинарную табуляцию, так и двойную и/или 4-рядом расположенных пробела.
% если уровень следующего элемента меньше, то ищем ближайший элемент уровня меньше этого и вписываем туда

В следующем примере BXL набран очень грубо (моделируется работа не компетентного пользователя, которому сказали описать что-то на BXL)

[[code]]
a
     x  # тут пять пробелов (но 5 % 4 - это 1 уровень
			y  # тут 3 табуляции, но так как прежний уровнь = 1, то это 2-й уровень
          z # тут 9 пробелов - 5%4 - тоже второй уровень
[[/code]]

С этим BXL справляется 
[[script-last type=bxl]]


Но подобная способность к нормализации BXL имеет свои пределы

В примере внизу табуляция x,y,z задана совсем странно - даже непонятно, что могло иметься в виду

[[code]]
a
					x
				y
			z
		w
[[/code]]

BXL сможет обработать это, но результат нормализации будет неожиданным
[[script-last type=bxl]]

Так как для BXL это:
[[code]]
a  # уровень 0
					x # "сырой уровень 5, больше предыдущего 0, значит 0+1=(1)
				y # сырой уровень 4, больше предыдущего 1, значит 1+1 (2)
			z # сырой уровень 3, больше предыдущего 2, значит 2+1(3)
		w # сырой уровень 2, меньше предыдущего, ищем ближайший элемент уровня 1 (x) и вписываем в него
[[/code]]

/ Отсюда - старайтесь всегда использовать однозначное определение уровней через единичную табуляцию - это читаемо и не приведет к странным последствиям


== В отличие от XML BXL поддерживает очень строгую модель значений элементов

В XML текстовые узлы и вложенные элементы равноправны и позволяют делать смешанный контент.

Это возникло исторически, для совместимости с HTML, прародителем XML. С точки зрения XML как языка для представления данных это считается устаревшим пережитком и не используется, так как есть неоднозначное соответствие между "полным значением элементов" и "порядком обхода дочерних узлов"

В соответствии с этим элементы в BXL могут содержать один и только один текстовой узел, который указывается сразу после заголовка

Весь остально вложенный строковый контент BXL пытается представить в виде ***анонимных атриутов***

/ Это означает что BXL не пригоден для моделирования на нем традиционного XHTML, состоящего из смеси текста и тегов.  Возможно в следующих версиях парсера этот подход будет пересмотрен и добавится опция "NativeTextNodes" для поддержки генерации смеси текстовых узлов и элементов

Простые примеры значений
[[code]]
# использование знака : - обязательно
a : val     
a : "val"
a : """
	val
	"""
a : (val)
a : (
val
)
[[/code]]
[[script-last type=bxl]]

Но попытки определить значение не начав его в заголовке или не отделив ":" будут безуспешы

[[code]]
# использование знака : - обязательно
a val     
a : 
	"val"
a  """
	val
	"""
a (
val
)
[[/code]]
[[script-last type=bxl]]

/ В целом мы считаем, что предпочтительнее использовать только элементы и атрибуты без значений, так как это гораздо больше совместимо с сериализацией в JSON и с кодогенерацией в языки типа C#, также это гораздо больше поддержано XPath и не вносит сумятицы с определением уровня с которого получено значение (напомню что по XML "значение" - это конкатенация всех значений своих текстовых узлов и узлов вложенных элементов


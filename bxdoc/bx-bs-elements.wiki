{style:float:right;}Языки BXL/B# - руководство{style}
{style:float:left;}Элементы классов B#{style}
[bx-index Вернуться к оглавлению]


= Элементы классов B#

Любые элементы XML, включенные в тело класса B# являются его элементами или контентом.

Элементы B# разделяются на два класса - ***простые*** и ***расширяемые***

== Простые элементы

Простые элементы - это просто контент, транслируемый в XML без специальной поддерки со стороны B# помимо интерполяции.

Аналогом простых элементов можно считать приватные члены классов C#, которые все всегда неявно наследуются.

Вот пример простых элементов

[[code]]
class farm
	server portal port=80
		service frontal "http:${port}"
[[/code]]
[[script-last type=bsharp]]

В данном примере ***server portal*** является 

== Поведение простых элементов при наследовании

При наследовании поведение простых элементов крайне простое - они все записываются в результирующий класс:

[[code]]
class farmBase abstract
	server portal port=80
		service frontal "http:${port}"
class myFarm
	import farmBase
	server back port=1448
		service mysrv "tcp:${port}"
[[/code]]
[[script-last type=bsharp]]

При этом никакого контроля на дублирование не производится

[[code]]
class A abstract
	el 1
	el 1
	el 1
class B
	import A
	el 1
	el 1
	el 1
[[/code]]
[[script-last type=bsharp]]

Ну и собственно именно это поведение простых элементов приводит к сложностям, например:

[[code]]
class farmBase abstract
	server portal port=80
		service frontal "http:${port}"
class myFarm
	import farmBase
	server portal port=443
		service frontal "http:${port}"
[[/code]]
[[script-last type=bsharp]]

Результат может очень огорчить автора класса myFarm

% У него теперь в конфигурации 2 сервера вместо одного и один из них к тому же не защищен
% Он может даже не знать о существовании второго сервера, если не он пишет класс farmBase(!)

/ Именно из-за этого в B# большое внимание уделено внутреннему контенту класса и прежде всего конструкции ***расширяемого элемента***, который является прямым аналлогом виртуальных (virtual, @override) членов класса C#/Java

== Расширяемые элементы

Расширяемые элементы отличаются от простых следующим:

% в классе (или любом из его родительских классов) присутствует определение расширяемого элемента в синтаксисе ***element NAME*** где NAME - это имя элемента
% у каждого элемента обязательно есть атрибут идентичности @code (см . [bx-bxl-idattr идентичность в BXL])
% элемент с определенной идентичностью может присуствовать только в одном экземпляре
% для элементов поддерживатся синтаксис переопределения (эквивалент инструкции ***new NAME*** в C#) перекрытия ***~NAME*** ( идентичен override c вызовом base.XXX() в начале метода) и расширения ***+NAME*** (логически эквивалентно override  c вызовом base.XXX() в конце метода)

Перепишем примеры из предыдущего раздела, но в синтаксисе ***расширяемых элементов***

[[code]]
class A abstract
	element el  # директива, указывающая, что имя el - здесь и во всех наследуемых классах - это расширяемый элемент
	el 1
	el 1
	el 1
class B
	import A
	el 1
	el 1
	el 1
[[/code]]
[[script-last type=bsharp]]

Как видно, дубляжи исчезли.

Теперь проверим более серьезный пример с серверами

[[code]]
class farmBase abstract
	element server
	server portal port=80
		service frontal "http:${port}"
class myFarm
	import farmBase
	server portal port=443
		service frontal "https:${port}"
[[/code]]
[[script-last type=bsharp]]

Как и ожидается - более дочернее определение сервера portal переопределило базовое

/ Переопределение расширяемых элементов не требует специальных инструкций и синтаксиса

== Перекрытие и расширение 

Перекрытие и расширение элементов исполнено по аналогии с перекрытием и расширением классов (см. [bx-bs-overrides перекрытия в B#])

Напомним, что перекрытие записывается как ***~NAME***, а расширение как ***+NAME***, где NAME - имя элемента.

[[code]]
class A abstract
	element el
	el 1 x=1 y=2
	el 2 x=3 y=4
class B 
	import A
	~el 1 x=4 y=3 #будут заменены оба атрибута
	+el 2 x=4 z=1 #будет взят только атрибут z как отсутстовавший ранее
[[/code]]
[[script-last type=bsharp]]

Некоторые отличия связаны с тем, как перекрытия и расширения поступают с внутренним контентом элементов.

Если при перекрытии классов - перекрытие и расширение не отличаются по своему поведению и дополняют тело класса (что как раз и связано с поддержкой расширяемых элементов, резолюция которых производится в более поздний период), то перекрытие элементов и перекрытие расширений по-разному поступают с телом элемента:

[[code]]
class A abstract
	element el
	el 1 x=1 y=2
		body 
	el 2 x=3 y=4
		body
class B 
	import A
	~el 1 x=4 y=3 
		new body # полностью заменит прежний контент
	+el 2 x=4 z=1 
		new body #дополнит предыдущий контент
[[/code]]
[[script-last type=bsharp]]

/ Соответственно посредством комбинации переопределний, расширений и перекрытий мы можем добиться требуемой структуры и внутреннего наполнения элементов класса с сохранением максимальной переемственности между ними - соответственно ***расширяемые элементы*** основной инструмент полиморфизма в B#

== Стек перекрытий

B# не делает никаких ограничений на количество перекрытий и расширений как в иерархии классов, так и внутри одного класса

В своей работе компилятор формирует полный стек вызовов из определений, переопределений, перекрытий и расширений элементов с контролем порядка и приоритета их применения.

При адекватном по архитектуре кода использовании расширенных элементов (как и при программировании полиморфизма в любых других ООП языках) стек не требует особого анализа и отражает достаточно интуитивно понятный порядок обхода.

В примере внизу показан более-менее реалистичный пример со стеком перегрузки расширяемых элементов.

[[code]]
class farmBase abstract
	element server
	server portal port=80
		service frontal "http:${port}"
class safeFarm abstract
	import farmBase
	# перекрываем сервер portal, перенаправив его  на защищенный порт
	~server portal port=443
		service frontal "https:${port}"
class myFarm
	import safeFarm
	#перекрываем с заменой порта
	~server portal port=4438
	#расширяем с добавлением еще одного сервиса
	+server portal 
		service back "https:1${port}"
[[/code]]
[[script-last type=bsharp]]
{style:float:right;}Языки BXL/B# - руководство{style}
{style:float:left;}Предисловие к B#{style}
[bx-index Вернуться к оглавлению]

= Предисловие к B#

Изучать B# бессмыслено, если вы еще не ознакомились с [bs-bxl-qstart BXL], обязательно изучите этот базовый язык, так как синтаксически B# является его прямым расширением с соотношением соответствия структур и выразительности примерно как C#/C.

В создании B# мы исходили из основной главной мысли - языковаяи нфраструктура для обработки сложных спецификаций, древовидных справочников, описания сложных сущнностей должна отвечать следующим основным критериям:

% на входе должен быть максимально упрощенный язык с быстрым циклом освоения, так как целевая группа - это прежде всего "особые пользователи" системы, а не программисты
% это не должен быть визуальный генератор, а именно языковое решение, чтобы для работы не требовалось наличие инфраструктуры и чтобы легко было вносить структурные изменения в модель - визуальное же моделирование порождает и первую и вторую проблему
% на выходе необходимо получать внятные XML/JSON документы, которые легко было затем подвернуть машинной обработке с целью верификации, генерации документации, генерации кода и т.д.
% соответственно все имеющиеся средства из стандарта XML (XPath,XSLT,XQuery) во-первых не являются простыми в освоении, во-вторых они не дружествены JSON, а требуется дружественность любой древовидной структуре и более того, поверх них все равно потребовалось бы выстраивать инфраструктуру сборки, а на вход подавать XML с которым тяжело работать вручную

Соответственно после создания BXL мы увидели в нем перспективы на возможность создания некоей нотации , которая будучи внутри XML являлась бы читаемой и похожей на более традиционные языки и просто естественный язык для описания сущностей.

Идеалогически B# вырос из BXL, а BXL исторически вырос из раннего решения на основе макросов языка BOO ([http://boo.codehaus.org/]), что наложило определенный отпечаток на дизайн и идеалогию B#:

№ Синтаксис B# - это BXL с зарезервированными ключевым словами, операторами и соглашениями, соответственно B# использует "питоновское" понимание вложенности блоков через табуляцию
№ Программа на B# состоит из множества модулей, в каждом из которых могут быть определения классов и ряд специальных конаструкций, модули B#:
№№ Не зависят друг от друга, образуют единое пространство
№№ На случай наличия функциональной зависимости модулей предусмотрена инструкция require, имеющая семантику, близкую к Node.js
№ B# - объектно-ориентированный язык со следующими особенностями
№№ поддерживаются пространства имен и гибкая резолюция имен, чем-то напоминающая C#/Java, но с возможностью пересечения пространст имен (пакетов) при запросе класса по имени
№№ множественное наследование с четким порядком (то есть множественное наследование понимается как последовательное обычное наследование)
№№ отсутствует единый базовый класс, вместо этого используется понятие "прототипа" логически группирующие классы по группам (не обязательно с одним базовым классом)
№№ в связи с XML и описательной направленностью языка тело класса не разделяется на явные члены класса, при наследовании произодится слияние классов, для логических "членов класса" вводится понятие "элемента класса", слияние которого просиходит с четким  сохранением идентичности изначального элемента
№№ поддержка абстрактных классов
№№ поддержка статических классов
№ B# поддерживает особые инструкции для связывания и импорта одних классов (и элементов кода XML) в другие
№№ Интерполяция разной фазы срабатывания для встраивания атрибутов в состав комплексных значений
№№ Операция include (включение контента другого класса)
№№ Поддержка специальных patch - класслов (донастройка класса в режиме адаптированно DIFF/PATCH без необходимости перекрытия и наследования
№№ Инфраструктрура экспорта справочников через конструкцию export
№№ Инфраструктрура массовой генерации кода на инструкциях dataset/generator
№ ...

Описание отдельных особенностей B# будет дано в других разделах. 

= Базовая методология B#
Во введении стоит подробнее показать как понимается "объектное программирование" в применении к XML и как оно понимается в B#

Расcмотрим пример внизу:

[[script type=bxl]]
group domain=myorg
	server srv1 addr="myorg.srv1.com"
[[/script]]

Вопрос - какой домен у сервера? Очевидный ответ - "myorg", однако с точки зрения XML как такового у server вообще нет атрибута domain.
И соответственно мы вынуждены дублировать код, более того XML никак не отреагирует на изменения в базовом элементе:

[[script type=bxl]]
group domain=portal
	server srv2 addr="myorg.srv1.com"
[[/script]]

Получили рассогласованную модель.


В B# мы можем явно выразить соотношение атрибутов элементов через интерполяцию:

[[code]]
class group domain=portal
	server srv2 addr="${domain}.${code}.com"
[[/code]]
[[script-last type=bsharp]]

/ ${...} конструкция интерполяции значений атрибутов в атрибуты и значенияэлементов и унаследованных классов, обладают scope от локального (свой элемент) вверх по иерархии элементов и унаследованных сущностей

Но допустим серверов много:

[[code]]
class group domain=portal
	server srv1 addr="${domain}.${code}.com"
	server srv2 addr="${domain}.${code}.com"
	server srv3 addr="${domain}.${code}.com"
	server srv4 addr="${domain}.${code}.com"
	server srv5 addr="${domain}.${code}.com"
[[/code]]
[[script-last type=bsharp]]

Опять избыточное дублирование шаблона для адреса сервера? 

Мы обязваем класс group знать нутро server, что нарушает архитектуру ?

B# позволяет легко выделить "подкласс для внедрения" 

[[code]]
class server embed=1 addr="%{domain}.%{name}.com"
class group domain=portal
	include server srv1 
	include server srv2 
	include server srv3
	include server srv4
	include server srv5
[[/code]]
[[script-last type=bsharp]]

/ embed- признак несамостоятельного, внедряемого класса, include - инструкция включения другого класса внутрь тела данного %{...} - поздняя интерполяция, производимая уже после include, соответвтенно domain и name получат правильные значения

Но допустим у нас кластер из 2-х групп одинаковой структуры в разных доменах:

[[code]]
class server embed=1 addr="%{domain}.%{name}.com"
class group domain=portal
	include server srv1 
	include server srv2 
	include server srv3
	include server srv4
	include server srv5
class group2 domain=corpinternals
	include server srv1 
	include server srv2 
	include server srv3
	include server srv4
	include server srv5
[[/code]]
[[script-last type=bsharp]]

Опять дублирование, но уже на уровне самих классов и значит на помощи приходит наследование:

Плюс еще решим проблему идентичности серверов решив проблему через атрибут code и явной директивы его установки set-code...

[[code]]
class server embed=1 addr="%{domain}.%{code}.com"
class groupBase  domain = MUSTDEFINE abstract # абстрактные классы также как и embed не включаются в результаты
	include server set-code=srv1 
	include server set-code=srv2 
	include server set-code=srv3
	include server set-code=srv4
	include server set-code=srv5
class group domain=portal     
	import groupBase
class group2 domain=corpinternals 
	import groupBase
[[/code]]
[[script-last type=bsharp]]

Теперь допустим в совершенно другом файле, другой разработчик, не замещая самого класса group2 хочет добавить к нему сервер и выставить еще дополнительный параметр...

[[code]]
class server embed=1 addr="%{domain}.%{code}.com"
class groupBase  domain = MUSTDEFINE abstract # абстрактные классы также как и embed не включаются в результаты
	include server set-code=srv1 
	include server set-code=srv2 
	include server set-code=srv3
	include server set-code=srv4
	include server set-code=srv5
class group domain=portal     
	import groupBase
class group2 domain=corpinternals 
	import groupBase
	
# где-то в другом файле на продакшене

patch for=group2
	access=private
	server srv3 access=public
	
[[/code]]

Вуаля! Теперь понятно - для чего нужна идентичность - чтобы ссылаться по коду

[[script-last type=bsharp]]

Вызвающий код по прежнему будет использовать элемент (класс с кодом group2) и ничего не знать о "патче"

/ Думаю теперь вы получили некоторое представление об основном стиле и назначении B# и можете перходить к более конкретным темам

См. далее

% [bx-bs-classresolution B# - пространства имен, классы и область видимости]
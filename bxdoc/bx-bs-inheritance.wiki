{style:float:right;}Языки BXL/B# - руководство{style}
{style:float:left;}Наследование{style}
[bx-index Вернуться к оглавлению]


= Наследование

== Простое наследование
Классы могут наследовать друг друга в интуитивно понятной манере:

% новые атрибуты добавляются
% одинаковые атрибуты перекрываются
% элементы добавляются

Наследование обеспечивается директивой import

[[code]]
class A x=1 z=base
class B y=2 z=new
	import A
[[/code]]
[[script-last type=bsharp]]

== Абстрактные классы

Если класс помечен как абстрактный, то он не включается в результаты

Используется директива класса abstract

[[code]]
class A x=1 z=base abstract
class B y=2 z=new
	import A
[[/code]]
[[script-last type=bsharp]]

== Множественное наследование

Множественое наследование реализовано как последовательное применение базового класса по тем же принципам, что и при простом наследовании

Результат будет зависеть от порядка

[[code]]
class A x=1 z=base abstract
class B y=2 z=new abstract
class FirstA 
	import A
	import B
class FirstB
	import B
	import A
[[/code]]
[[script-last type=bsharp]]


== Базовый класс по умолчанию

В языках с единичным наследованием (С#/Java) более четким дизайном является наследование одного базового класса с имплементацией интерфейсов, так как в B# речь идет о XML и соответственно не возможно разделить "определение" и "имплементацию", то в B# используется немного другой дизайн.

Во-первых для первого базового класса предусмотрено "импортирование через замену директивы class"

[[code]]
class A x=1 z=base abstract
class B y=2 z=new abstract
A FirstA 
	import B
B FirstB
	import A
[[/code]]
[[script-last type=bsharp]]

Внимание! кроме упрощения синтаксиса импорт по умолчанию влечет изменение выходящего XML сравните:

[[code]]
class A abstract
A B
class C
	import A
[[/code]]
[[script-last type=bsharp]]

Во-вторых для упрощения и DSL-подобного синтаксиса предусмотрены псевдонимы классов, обеспечивающих лучшую читаемость (но работают они по аналогии с C# только с полными пространствами имен)

Для этого используется директива using уровня пространства имен

[[code]]
# где-то в одном файле...

namespace My.Org.Core
	class BaseDefinition x=1 abstract
	
# в нашем файле...

namespace program
	using def=My.Org.Core.BaseDefinition
	
	def X y=1
	def Y y=2
	def Z y=3
[[/code]]
[[script-last type=bsharp]]

/ Внимание! Нотация using в B# не соответствует одноименной в C# - в B# речь идет именно о ***псевдонимах классов***, а не о "видимости пространства имен" и соответствует в C# только нотации using MyName = My.Org.Core.BaseDefinition;


Если вместо слова class указан код класса, который отсутствует в проекте, то это ошибка
[[code]]
class A x=1 
A B #ok
Z Y #error
[[/code]]
[[script-last type=bsharp]]



== Видимость классов 

Видимость классов понимается как доступность одного класса по ссылке из другого. При наследовании система безусловно пытается помочь в резолюции имен

Резолюция в B# более гибкая, нежели в C# и JAVA - ибо в том случае, если системе не удается найти соответствие в стеке пространств имен "вверх" она старается найти бесконфликтный вариант по частичному совпадению например

[[code]]
class X.Y.Z.a x=1 # класс а глубоко спрятан в некое пространство имен
class b 
	import X.Y.Z.a # можно конечно так, но проще так:
	
class c
	import Z.a    #или даже так
class d
	import a       # нет других классов с именем "а" - все ОК

[[/code]]
[[script-last type=bsharp]]

Но системе необходимо, чтобы полное имя класса полностью заканчивалось на ссылку, например следующий пример не сработает и появится соответствующая ошибка

[[code]]
class X.Y.Z.a x=1 # класс а глубоко спрятан в некое пространство имен
class c
	import D.a  # такого суффикса нет

[[/code]]
[[script-last type=bsharp]]


Если вариантов несколько, то система выберет ближайший по иерархии

[[code]]
namespace A
	class a x=1
	namespace B
		class a x=2
		namespace C
			class a x=3
			class b
				import a # будет импортирован A.B.C.a
		class b
			import a #будет импортирован A.B.a
[[/code]]
[[script-last type=bsharp]]

Если вариантов несколько, но относительно иерархии определения класса они равноценны, то для B# это ошибка

[[code]]
namespace A
	class a x=1
namespace B
	class a x=2
namespace C
	class b
		import a
[[/code]]
[[script-last type=bsharp]]

C темой наследования тесно переплетена тема интерполяции, которую следует изучить следующей


== Рециклы

При циклическом импорте B# прерывает рециклы, компилирует класс в текущем состоянии наследования и выдает ошибку
[[code]]
class A x=1
	import C
class B x=2
	import A
class C x=3
	import B
[[/code]]
[[script-last type=bsharp]]

См. далее

[bx-bs-interpolation Интерполяция]
/*global Array: false, FusionCharts, window: false,
    FusionChartsDataFormats: false */

/**!
 * @license FusionCharts JavaScript Library
 * Copyright FusionCharts Technologies LLP
 * License Information at <http://www.fusioncharts.com/license>
 *
 * @version fusioncharts/3.3.1-sr2.19840
 */

(function () {

    // Register the module with FusionCharts and also oget access to a global
    // variable within the core's scope.
    var global = FusionCharts(['private', 'modules.renderer.js-lib']);
    // Check whether the module has been already registered. If true, then
    // do not bother to re-register.
    if (global === undefined) {
        return;
    }

    var
        win = window,
        // Constants
        BLANKSTRINGPLACEHOLDER = '#BLANK#',
        BLANK = '',
        COLOR_BLACK = '000000',
        COLOR_GLASS = 'rgba(255, 255, 255, 0.3)',
        COLOR_WHITE = 'FFFFFF',
        COLOR_TRANSPARENT = 'rgba(0,0,0,0)',
        LINEHEIGHT = 'line-height',
        TESTSTR = 'Ag',
        HASHSTRING = '#',
        BREAKSTRING = '<br />',
        STRINGSTRING = 'string',
        OBJECTSTRING = 'object',
        COMMASTRING = ',',
        ZEROSTRING = '0',
        ONESTRING = '1',
        DECIMALSTRING = ".",
        STRINGUNDEFINED = 'undefined',
        POSITION_TOP = 'top',
        POSITION_RIGHT = 'right',
        POSITION_BOTTOM = 'bottom',
        POSITION_LEFT = 'left',
        POSITION_CENTER = 'center',
        POSITION_MIDDLE = 'middle',
        POSITION_START = 'start',
        POSITION_END = 'end',
        FC_CONFIG_STRING = '_FCconf',
        SHAPE_RECT = 'rect',
        TEXTANCHOR = 'text-anchor',

        // Strings that is being used rapidly
        HUNDREDSTRING = '100',
        BGRATIOSTRING = '0,100',
        PXSTRING = 'px',
        COMMASPACE = ', ',

        doc = document,
        docMode8 = doc.documentMode === 8,
        hasSVG = !!doc.createElementNS &&
        !!doc.createElementNS("http://www.w3.org/2000/svg", "svg").createSVGRect,

        isIE = /msie/i.test(navigator.userAgent) && !window.opera,

        // Regular Expressions
        stripWhitespace = /\s+/g,
        dropHash = /^#?/,
        startsRGBA = /^rgba/i,
        cleanColorCode = /[#\s]/ig,
        breakPlaceholder = /\{br\}/ig,
        hexcode = /^#?[0-9a-f]{6}/i,
        validhexcolor =  /(^#[0-9A-F]{6}$)|(^#[0-9A-F]{3}$)/i,
        mathAbs = Math.abs,
        mathPow = Math.pow,
        mathRound = Math.round,

        EPSILON = mathPow(2, -24),

        objectToStrFn = Object.prototype.toString,

        hasTouch = doc.documentElement.ontouchstart !== undefined,

        math = Math,
        mathAbs = math.abs,
        mathMax = math.max,
        mathMin = math.min,

        DRAGSTART = 'dragstart',
        DRAG = 'drag',
        DRAGEND = 'dragend',
        stubEvent = {
            pageX: 0,
            pageY: 0
        },


    createContextMenu = function (options) {

        var chart = options.chart,
        smartLabel = chart.smartLabel,
        labelOptions = options.labels,
        boxHover = options.hover || ({
            fill: 'rgba(64, 64, 64, 1)'
        }),
        boxAttrs = options.attrs || ({
            fill: 'rgba(255, 255, 255, 1)'
        }),
        textStyle = (labelOptions && labelOptions.style) || ({
            fontSize: '12px',
            color: '000000'
        }),
        textAttrs = (labelOptions && labelOptions.attrs) || ({

        }),
        textHover = (labelOptions && labelOptions.hover) || ({
            color: 'FFFFFF'
        }),
        items = options.items,
        position = options.position,
        vPad = (options.verticalPadding || 5),
        hPad = (options.horizontalPadding || 10),
        R = global.hcLib.Raphael,
        menu = {},
        chartPos,
        hideTimer,
        paper;

        if (!chart) {
            return false;
        }
        else {
            chartPos = getPosition(chart.container);
        }

        var drawFn = function () {

            paper = this;

            var items = menu.items,
            i = items.length,
            menuHeight = 0,
            menuWidth = 0,
            eachHeight = 0,
            top = 0,
            item,
            group = menu.group,

            smartLabelObj;

            if (!menu.menuItems) {
                menu.menuItems = [];
            }

            smartLabel.setStyle(textStyle);

            while (i--) {

                item = items[i];
                smartLabelObj = smartLabel.getOriSize(item.text);
                if (!eachHeight) {
                    eachHeight = (smartLabelObj.height + (2 * vPad));
                }
                menuHeight += eachHeight;
                menuWidth = Math.max(menuWidth, (smartLabelObj.width + (2 * hPad)));
            }

            menu.height = menuHeight;
            menu.width = menuWidth;
            menu.itemH = eachHeight;

            // set the dimensions to the paper.
            paper.setSize(menuWidth + 5, menuHeight + 5);

            if (!group) {
                group = menu.group = paper.group("contextmenu-container");
            }

            // create the outer rect.
            if (menu.menuRect) {
                menu.menuRect.attr({
                    width: menuWidth,
                    height: menuHeight
                });
            }
            else {
                menu.menuRect = paper.rect(0, 0, menuWidth, menuHeight, 0, group)
                    .shadow(true)
                    .attr({
                        'stroke-width': 1,
                        fill: 'rgba(255, 255, 255, 1)'
                    });
            }

            var ii = items.length;

            for (i = 0; i < ii; i += 1) {
                // create elements
                item = items[i];
                if (menu.menuItems[i]) {
                    menu.menuItems[i].label.attr({
                        text: item.text
                    });
                }
                else {
                    menu.menuItems[i] = {};
                    menu.menuItems[i].box = paper.rect(0, top, menuWidth, eachHeight, 0, group)
                        .attr({
                            stroke: 'none'
                        })
                        .attr(boxAttrs)
                        .click(itemClick)
                        .hover(mouseOver, mouseOut);

                    menu.menuItems[i].label = paper.text(hPad / 2, top + (eachHeight / 2), item.text, group)
                        .attr({
                            'text-anchor': 'start'
                        })
                        .attr(textAttrs)
                        .css(textStyle)
                        .click(itemClick)
                        .hover(mouseOver, mouseOut);

                    menu.menuItems[i].box._itemIdx = i;
                    menu.menuItems[i].label._itemIdx = i;
                    top += eachHeight;
                }
            }

            while (menu.menuItems[i]) {
                menu.menuItems[i].box.remove();
                menu.menuItems[i].label.remove();
                menu.menuItems.splice(i, 1);
            }

        },

        setHideTimer = function () {
            hideTimer = setTimeout(menu.hide, 800);
        },

        resetHideTimer = function () {
            if (hideTimer) {
                clearTimeout(hideTimer);
            }
        },

        calculateTopLeft = function (position) {
            var x = position.x,
            y = position.y,
            pos = {
                x: x + chartPos.left,
                y: y + chartPos.top
            },
            width = menu.width,
            height = menu.height,
            cHeight = chart.chartHeight,
            cWidth = chart.chartWidth;

            if (((x + width) > cWidth) && ((x - width) > 0)){
                pos.x -= width;
            }

            if (((y + height) > cHeight) && ((y - height) > 0)){
                pos.y -= height;
            }

            return pos;
        },

        nonItemClick = function () {
            menu.hide();
        },

        mouseOver = function (e) {
            var rEle = this,
            items = menu.menuItems,
            i = rEle._itemIdx,
            item = items[i];

            resetHideTimer();

            item.box.attr(boxHover);
            item.label.css(textHover);
        },

        mouseOut = function (e) {
            var rEle = this,
            items = menu.menuItems,
            i = rEle._itemIdx,
            item = items[i];

            item.box.attr(boxAttrs);
            item.label.css(textStyle);

            setHideTimer();
        },

        itemClick = function (e) {
            var rEle = this,
            items = menu.items,
            i = rEle._itemIdx,
            item = items[i];

            if (item.onclick) {
                item.onclick.call(item, e);
            }

            menu.hide();
        };

        menu.showItem = function (index) {

            var m = this,
            item = m.menuItems[index],
            menuH = m.height,
            itemH = m.itemH,
            height,
            posObj;

            if (item && item._isHidden) {
                height = m.height = (menuH + itemH);
                m.menuRect.attr({
                    height: height
                });

                item.box.show();
                item.label.show();

                item._isHidden = false;

                posObj = calculateTopLeft(position);
                m.left = posObj.x;
                m.top = posObj.y;

                index += 1;

                while (item = m.menuItems[index]) {
                    item.box.attr({
                        y: (item.box.attrs.y + itemH)
                    });

                    item.label.attr({
                        y: (item.label.attrs.y + itemH)
                    });

                    index += 1;
                }
            }

        };

        menu.hideItem = function (index) {
            var m = this,
            item = m.menuItems[index],
            menuH = m.height,
            itemH = m.itemH,
            height,
            posObj;

            if (item && !item._isHidden) {
                item.box.hide();
                item.label.hide();

                height = m.height = (menuH - itemH);
                m.menuRect.attr({
                    height: height
                });

                item._isHidden = true;

                posObj = calculateTopLeft(position);
                m.left = posObj.x;
                m.top = posObj.y;

                index += 1;

                while (item = m.menuItems[index]) {
                    item.box.attr({
                        y: (item.box.attrs.y - itemH)
                    });

                    item.label.attr({
                        y: (item.label.attrs.y - itemH)
                    });

                    index += 1;
                }
            }
        };

        menu.redraw = function () {
            var m = this,
            paper = m.paper,
            posObj;

            m.items = items;

            if (!paper) {
                if (position && position.x !== undefined && position.y !== undefined) {

                    m.paper = R(0, 0, 100, 100);
                    drawFn.call(m.paper);

                    posObj = calculateTopLeft(position);
                    m.left = posObj.x;
                    m.top = posObj.y;
                    m.paper.canvas.style.left = m.left + 'px';
                    m.paper.canvas.style.top = m.top + 'px';
                }
                else {
                    m.paper = R(0, 0, 100, 100);
                    drawFn.call(m.paper);
                }
            }
            else {
                drawFn.call(m.paper);
            }
        };

        menu.show = function (showOptions) {
            var m = this,
            items = m.menuItems,
            i = items.length,
            item;

            m.visible = true;

            if (showOptions && showOptions.x !== undefined && showOptions.y !== undefined) {
                var posObj = calculateTopLeft(showOptions);
                m.paper.canvas.style.left = posObj.x + 'px';
                m.paper.canvas.style.top = posObj.y + 'px';
            }
            else {
                m.paper.canvas.style.left = m.left + 'px';
                m.paper.canvas.style.top = m.top + 'px';
            }

            menu.group.show();

            setTimeout(function () {
                R.click(nonItemClick);
            }, 50);
        };

        menu.hide = function () {
            this.visible = false;
            menu.group.hide();
            //paper.setViewBox(0, 0, 0, 0);
            menu.paper.canvas.style.left = (- menu.width) + 'px';
            menu.paper.canvas.style.top = (- menu.height) + 'px';

            R.unclick(nonItemClick);
        };

        menu.update = function (items) {
            var m = this;

            if (items && items.length) {
                m.items = items;
                m.redraw();
            }
        };

        menu.updatePosition = function (posObj) {
            var m = this,
            oldChartPos = {
                left: chartPos.left,
                top: chartPos.top
            },
            cPos;

            chartPos = getPosition(chart.container);
            if (posObj) {
                position = posObj;
                cPos = calculateTopLeft(posObj);
                m.left = cPos.x;
                m.top = cPos.y;
            }
            else {
                m.left -= (oldChartPos.left - chartPos.left);
                m.top -= (oldChartPos.top - chartPos.top);
            }
        }

        menu.add = function (item) {
            // create elements
            var m = this,
            paper = m.paper,
            mItems = m.menuItems,
            i = mItems.length;

            mItems[i] = {};
            mItems[i].box = paper.rect(0, m.height, m.width, m.itemH, 0)
                .attr(boxAttrs)
                .hover(mouseOver, mouseOut);

            menu.menuItems[i].label = paper.text(m.width / 2, m.height + (m.itemH / 2), item.text)
                .attr(textAttrs)
                .css(textStyle)
                .hover(mouseOver, mouseOut);

            menu.menuItems[i].box._itemIdx = i;
            menu.menuItems[i].label._itemIdx = i;
            m.height += m.itemH;

            m.menuRect.attr({
                height: m.height
            });
        };

        menu.removeItems = function () {
            var m = this,
            items = m.menuItems,
            i = items && items.length,
            item;

            while (i--) {
                item = items[i];
                item.box && item.box.remove && item.box.remove();
                item.label && item.label.remove && item.label.remove();
            }

            delete m.menuItems;
            delete m.items;

        };

        menu.setPosition = function (position) {
            var m = this;

            if (position.x !== undefined && position.y !== undefined) {
                m.paper.setViewBox(position.x, position.y, m.width, m.height);
            }
        };

        menu.destroy = function () {
            var m = this;

            m.removeItems();
            m.menuRect.remove();

        };

        if (items && items.length) {
            menu.redraw();
            menu.hide();
        }

        return menu;

    },

    selectionEventHandler = function (event) {
        var config = event.data,
            chart = config.chart,
            paper = chart.paper,
            type = event.type,
            tgt = event.target || event.originalTarget || event.srcElement ||
                event.relatedTarget || event.fromElement,
            touchEvent = (hasTouch && getTouchEvent(event)) || stubEvent,
            resizeBox = chart.elements.resizeBox,
            layerX = event.layerX || touchEvent.layerX,
            layerY = event.layerY || touchEvent.layerY,
            dx = layerX - config.ox,
            dy = layerY - config.oy,
            bBox = config.bBox,
            x = config.ox,
            y = config.oy,
            zoomX = config.zoomX,
            zoomY = config.zoomY,
            canvasY = config.canvasY,
            canvasX = config.canvasX,
            canvasW = config.canvasW,
            canvasH = config.canvasH,
            canvasX2 = config.canvasX2,
            canvasY2 = config.canvasY2,
            strokeWidth = config.strokeWidth,
            chartPosLeft = config.chartPosLeft,
            chartPosTop = config.chartPosTop,
            attr = config.attr;

        if (layerX === undefined) {
            layerX = (event.pageX || touchEvent.pageX) - chartPosLeft;
            layerY = (event.pageY || touchEvent.pageY) - chartPosTop;
        }

        switch (type) {
            case DRAGSTART : // DragStart
                config.oy = layerY;
                config.ox = layerX;
                config.allowMove = false;
                // Create the resizable box
                if (!resizeBox) {
                    resizeBox = chart.elements.resizeBox =
                        paper.rect(chart.layers.tracker)
                        .attr(attr);
                }

                if (layerX  > canvasX && layerX  < canvasX2 &&
                        layerY  > canvasY && layerY  < canvasY2) {
                    config.allowMove = true;
                }
                // do not receive event if the clicked target element is marked as
                // hot
                if (tgt && tgt.ishot) {
                    config.allowMove = false;
                }

                resizeBox.attr({
                    x: 0,
                    y: 0,
                    width: 0,
                    height: 0
                }).show();
            break;

            case DRAGEND :  // DragEnd
                var bBox = resizeBox.getBBox(),
                    selectionData = {
                         chart: chart,
                         selectionLeft: bBox.x,
                         selectionTop: bBox.y,
                         selectionHeight: bBox.height,
                         selectionWidth: bBox.width
                    };
                config.allowMove && config.callback(selectionData);
                resizeBox.hide();

                delete config.oy;
                delete config.ox;
            break;

            default: // DragMove
                if (!config.allowMove) {
                    return;
                }
                dx = layerX - config.ox;
                dy = layerY - config.oy;
                bBox = config.bBox;
                x = config.ox;
                y = config.oy;

                dx = -(x - mathMin(x - (x - mathMax(x + dx, canvasX)), canvasX2));
                dy = -(y - mathMin(y - (y - mathMax(y + dy, canvasY)), canvasY2));

                resizeBox.attr({
                    x: (zoomX ? mathMin(x, x + dx) : canvasX) + strokeWidth * 0.5,
                    y: (zoomY ? mathMin(y, y + dy) : canvasY) + strokeWidth * 0.5,
                    width: zoomX ? mathAbs(dx) : canvasW,
                    height: zoomY ? mathAbs(dy) : canvasH
                });
            break;
        }
    },

    onXYCanvasClick = function (e) {
        var tgt = e.target || e.originalTarget || e.srcElement ||
            e.relatedTarget || e.fromElement,
            config = e.data,
            eventType = e.type,
            layerX = e.layerX,
            layerY = e.layerY;

        if (layerX === undefined) {
            layerX = e.pageX - config.chartPosLeft;
            layerY = e.pageY - config.chartPosTop;
        };

        if (eventType === 'mousedown') {
            tgt.ishot = (layerX  > config.canvasX &&
                layerX  < config.canvasX2 && layerY  > config.canvasY &&
                layerY  < config.canvasY2);
        } if (eventType === 'mouseup') {
            setTimeout(function () {
                tgt.ishot = false;
            }, 1);
        }
    },

    bindSelectionEvent = function (chart, fn, config) {
        config = config || {};
        var chartOptions = chart.options.chart,
            container = chart.container,
            zoomType = chartOptions.zoomType,
            attr = extend2({}, (config.attr || {})),
            strokeWidth = attr['stroke-width'] = pluckNumber(attr.strokeWidth,
                attr['stroke-width'], 1),
            chartPosition = getPosition(container),
            config = {
                chart: chart,
                zoomX: /x/.test(zoomType),
                zoomY: /y/.test(zoomType),
                canvasY: chart.canvasTop,
                canvasX: chart.canvasLeft,
                canvasW: chart.canvasWidth,
                canvasH: chart.canvasHeight,
                canvasX2: chart.canvasLeft + chart.canvasWidth,
                canvasY2: chart.canvasTop + chart.canvasHeight,
                strokeWidth: strokeWidth,
                chartPosLeft: chartPosition.left,
                chartPosTop: chartPosition.top,
                attr: attr,
                callback: fn
            };

        attr.stroke = getFirstValue(attr.stroke, 'rgba(51,153,255,0.8)');
        attr.fill = getFirstValue(attr.fill, 'rgba(185,213,241,0.3)');
        attr.ishot = true;

        if (container) {
            removeEvent(container, 'dragstart drag dragend', selectionEventHandler);
            addEvent(container, 'dragstart drag dragend', selectionEventHandler, config);
        }

        if (chartOptions.link) {
            removeEvent(chart.container, 'mouseup mousedown', onXYCanvasClick);
            addEvent(chart.container, 'mouseup mousedown', onXYCanvasClick, config);
        }

    },

    getViewPortDimension = (function () {
        var pw = 'innerWidth',
            ph = 'innerHeight',
            docEl = doc.documentElement || doc.body,
            vpEl = docEl;

        if (!('innerWidth' in win)) {
            pw = 'clientWidth';
            ph = 'clientHeight';
        }
        else {
            vpEl = win;
        }

        return function () {
            return {
                width : vpEl[pw],
                height : vpEl[ph],
                scrollTop: docEl.scrollTop,
                scrollLeft: docEl.scrollLeft
            };
        };
    }()),

    getPosition = function (el, noscroll) {
        var p = {
            left: (el.offsetLeft || 0),
            top: (el.offsetTop || 0)
        };
        el = el.offsetParent;
        while (el) {
            p.left += (el.offsetLeft || 0);
            p.top += (el.offsetTop || 0);
            if (el !== doc.body && el !== doc.documentElement && !noscroll) {
                p.left -= el.scrollLeft;
                p.top -= el.scrollTop;
            }
            el = el.offsetParent;
        }
        return p;
    },

    /**
     * Checks if a value sent as argument is 'valid' as per valid input
     * standards.
     * @param {object} arg
     * @param {object} value is the default value returned.
     */
    getValidValue = function (arg, value) {
        return !arg && arg !== false && arg !== 0 ? value : arg;
    },

    /**
     *  Return the defColor if color is undefined
     *  other wise always returns the color even if color is a blank string
     */
    getDefinedColor = function (color, defColor) {
        return (!color && color != 0 && color != false) ? defColor : color;
    },

    /**
     * Returns the first argument that is a 'valid' value or a blank string.
     */
    getFirstValue = function () {
        var arg,
        i,
        l;
        for (i = 0, l = arguments.length; i < l; i += 1) {
            arg = arguments[i];
            if (!arg && arg !== false && arg !== 0) {
                continue;
            }
            return arg;
        }
        return BLANK;
    },

    /**
     * Returns the first argument that is a 'valid' value or undefined.
     */
    pluck = function () {
        var arg, i, l;
        for (i = 0, l = arguments.length; i < l; i += 1) {
            arg = arguments[i];
            if (!arg && arg !== false && arg !== 0) {
                continue;
            }
            return arg;
        }
        return undefined;
    },

    touchMap = {
        mousedown: "touchstart",
        mousemove: "touchmove",
        mouseup: "touchend"
    },

    addEvent = function (el, event, fn, data) {
        jQuery(el).bind(hasTouch && touchMap[event] || event, data, fn);
    },

    /**
    * Remove event added with addEvent
    * @param {Object} el The object
    * @param {String} eventType The event type. Leave blank to remove all events.
    * @param {Function} handler The function to remove
    */
    removeEvent = function(el, eventType, handler) {
        // workaround for jQuery issue with unbinding custom events:
        // http://forum.jquery.com/topic/javascript-error-when-unbinding-a-custom-event-using-jquery-1-4-2
        var func = doc.removeEventListener ? 'removeEventListener' : 'detachEvent';
        if (doc[func] && !el[func]) {
            el[func] = function() {};
        }

        jQuery(el).unbind(hasTouch && touchMap[eventType] || eventType, handler);
    },

    /**
    * Fire an event on a custom object
    * @param {Object} el
    * @param {String} type
    * @param {Object} eventArguments
    * @param {Function} defaultFunction
    */
    fireEvent = function(el, type, eventArguments, defaultFunction) {
        var event = jQuery.Event(type),
        detachedType = 'detached'+ type;
        extend(event, eventArguments);

        // Prevent jQuery from triggering the object method that is named the
        // same as the event. For example, if the event is 'select', jQuery
        // attempts calling el.select and it goes into a loop.
        if (el[type]) {
            el[detachedType] = el[type];
            el[type] = null;
        }

        // trigger it
        jQuery(el).trigger(event);

        // attach the method
        if (el[detachedType]) {
            el[type] = el[detachedType];
            el[detachedType] = null;
        }

        if (defaultFunction && !event.isDefaultPrevented()) {
            defaultFunction(event);
        }
    },

    getTouchEvent = function (event) {
        var e = event.sourceEvent || event.originalEvent;
        return (hasTouch && e && e.touches && e.touches[0]) || event;
    },

    /**
    * This function is used to create html DOM
    *
    * @param {string} tagName the name of the HTML tag
    * @param {object} attributes Object contain all attribute name and value
    * @param {DOMobject} parentElement parent node of the newly created element
    */
    createElement = function(tagName, attributes, parentElement) {
        var elem = doc.createElement(tagName),
        x;
        //apply all attribute
        for (x in attributes) {
            elem.setAttribute(x, attributes[x]);
        }
        //append in parent element
        parentElement && parentElement.appendChild && parentElement.appendChild(elem);
        return elem;
    },

    hashify = function (color) {
        return color && color.replace(/^#?([a-f0-9]+)/ig, '#$1') || "none";
    },

    /**
     * Returns the first argument that is a 'valid' value even blankstring.
     */
    getFirstDefinedValue = function () {
        var arg, i, l;
        for (i = 0, l = arguments.length; i < l; i += 1) {
            arg = arguments[i];
            if (!arg && arg !== false && arg !== 0 && arg != BLANK) {
                continue;
            }
            return arg;
        }
        return undefined;
    },

    /**
     * Returns the first number in the argument array.
     *
     * @note
     * The expression here is same as getValidValue with isNaN check
     * added to it.
     */
    pluckNumber = function () {
        var arg,
        i,
        l;

        for (i = 0, l = arguments.length; i < l; i += 1) {
            arg = arguments[i];
            if (!arg && arg !== false && arg !== 0) {
                continue;
            }
            else if (isNaN(arg = Number(arg))) {
                continue;
            }
            return arg;
        }
        return undefined;
    },
    pluckFontSize = function () {
        var arg,
        i,
        l;

        for (i = 0, l = arguments.length; i < l; i += 1) {
            arg = arguments[i];
            if (!arg && arg !== false && arg !== 0) {
                continue;
            }
            else if (isNaN(arg = Number(arg))) {
                continue;
            }
            return arg < 1 ? 1 : arg;
        }
        return 1;
    },

    parsePointValue = function (value, abs) {
        

        value = !value && value !== false && value !== 0 ?
        NaN : Number(value);
        return isNaN(value) ? null : (abs ? mathAbs(value) : value);
    },

    parseUnsafeString = function (str) {
        

        if (typeof str === STRINGSTRING) {
            return str.replace(breakPlaceholder, BREAKSTRING);
        }
        else {
            return BLANK;
        }
    },

    getFirstColor = function (color) {
        color = color.split(COMMASTRING)[0];
        color = color.replace(stripWhitespace, BLANK);
        if (color == BLANK) {
            color = COLOR_BLACK;
        }
        return color.replace(dropHash, HASHSTRING);
    },

    getColorCodeString = function (color, fillString) {
        var returnString = "", colorEntry, len, i = 0, fillArray = fillString.split(COMMASTRING);
        for (len = fillArray.length; i < len; i += 1) {
            colorEntry = fillArray[i].split("-");
            if (colorEntry.length === 2) {
                if (colorEntry[0].indexOf("dark") !== "-1") {
                    returnString += (getLightColor(color, 100 - parseInt(colorEntry[1], 10)) + COMMASTRING);
                } else {
                    returnString += (getDarkColor(color, 100 - parseInt(colorEntry[1], 10)) + COMMASTRING);
                }
            } else {
                returnString += (fillArray[i] + COMMASTRING);
            }
        }
        return returnString.substring(0, returnString.length - 1);
    },

    pluckColor = function (color) {
        if (!getValidValue(color)) {
            return undefined;
        }
        color = color.split(COMMASTRING)[0];
        color = color.replace(stripWhitespace, BLANK);
        if (color == BLANK) {
            color = COLOR_BLACK;
        }
        return color.replace(dropHash, HASHSTRING);
    },

    getFirstAlpha = function (alpha) {
        alpha = parseInt(alpha, 10);
        if (isNaN(alpha) || alpha > 100 || alpha < 0) {
            alpha = 100;
        }
        return alpha;
    },
    arrayToStr = "[object Array]",
    objectToStr = "[object Object]",

    getSentenceCase = function (name) {
            name = name || BLANK;
            return (name.charAt(0).toUpperCase() + name.substr(1));
        },
    getCrispValue = function (position, distance, borderthickness) {
        var normalizer = borderthickness % 2 / 2,
        newposition = mathRound(position + normalizer) - normalizer,
        newdistance = mathRound(position + distance + normalizer) - normalizer - newposition;
        return {position: newposition, distance: newdistance};
    },
    trimString = function (str) {
        str = str.replace(/^\s\s*/, '');
        var ws = /\s/, i = str.length;
        while (ws.test(str.charAt(i -= 1))) {}
        return str.slice(0, i + 1);
    },

    merge = function (obj1, obj2, skipUndef) {
        var item, str;
        //check whether obj2 is an array
        //if array then iterate through it's index
        //**** MOOTOOLS precution
        if (obj2 instanceof Array) {
            for (item = 0; item < obj2.length; item += 1) {
                if (typeof obj2[item] !== OBJECTSTRING) {
                    if (!(skipUndef && obj2[item] === undefined)) {
                        obj1[item] = obj2[item];
                    }
                }
                else {
                    if (obj1[item] === null || typeof obj1[item] !== OBJECTSTRING) {
                        obj1[item] = obj2[item] instanceof Array ? [] : {};
                    }
                    merge(obj1[item], obj2[item], skipUndef);
                }
            }
        }
        else {
            for (item in obj2) {
                if (obj2[item] !== null && typeof obj2[item] === OBJECTSTRING) {
                    // Fix for issue BUG: FWXT-602
                    // IE < 9 Object.prototype.toString.call(null) gives
                    // "[object Object]" instead of "[object Null]"
                    // that's why null value becomes Object in IE < 9
                    str = objectToStrFn.call(obj2[item]);
                    if (str === objectToStr) {
                        if (obj1[item] === null || typeof obj1[item] !== OBJECTSTRING) {
                            obj1[item] = {};
                        }
                        merge(obj1[item], obj2[item], skipUndef);
                    }
                    else if (str === arrayToStr) {
                        if (obj1[item] === null || !(obj1[item] instanceof Array)) {
                            obj1[item] = [];
                        }
                        merge(obj1[item], obj2[item], skipUndef);
                    }
                    else {
                        obj1[item] = obj2[item];
                    }
                }
                else {
                    obj1[item] = obj2[item];
                }
            }
        }
        return obj1;
    },

    extend2 = function (obj1, obj2, skipUndef) {
        if (typeof obj1 !== OBJECTSTRING && typeof obj2 !== OBJECTSTRING) {//if none of the arguments are object then return back
            return null;
        }

        if (typeof obj2 !== OBJECTSTRING || obj2 === null) {
            return obj1;
        }

        if (typeof obj1 !== OBJECTSTRING) {
            obj1 = obj2 instanceof Array ? [] : {};
        }
        merge(obj1, obj2, skipUndef);
        return obj1;

    },

    //helper for deltend
    clean = function (obj1, obj2) {
        var item, str;
        //check whether obj2 is an array
        //if array then iterate through it's index
        //**** MOOTOOLS precution
        if (obj2 instanceof Array) {
            for (item = obj2.length - 1; item >= 0; item -= 1) {
                if (typeof obj2[item] !== OBJECTSTRING) {
                    if (obj2[item] === true && obj1 && obj1.splice) {
                        obj1.splice(item, 1);
                    }
                }
                else {
                    if (objectToStrFn.call(obj2[item]) === objectToStrFn.call(obj1[item])) {
                        clean(obj1[item], obj2[item]);
                    }
                }
            }
        }
        else {
            for (item in obj2) {
                if (typeof obj2[item] !== OBJECTSTRING) {
                    if (obj2[item] === true && obj1 && obj1.splice) {
                        obj1.splice(item, 1);
                    }
                }
                else {
                    if (objectToStrFn.call(obj2[item]) === objectToStrFn.call(obj1[item])) {
                        clean(obj1[item], obj2[item]);
                    }
                }
            }
        }
        return obj1;
    },
    //special function to perform deleted extend
    deltend = function (obj1, obj2) {
        //if any of the arguments is not object then return back
        if (typeof obj1 !== OBJECTSTRING || typeof obj2 !== OBJECTSTRING) {
            return null;
        }
        clean(obj1, obj2);
        return obj1;
    },

    imprint = function (obj1, obj2, ignoreNull) {
        var item;

        if (typeof obj1 !== OBJECTSTRING || obj1 === null) {
            obj1 = obj2;
            return obj2;
        }

        if(typeof obj2 !== OBJECTSTRING || obj2 === null) {
            return obj1;
        }

        for (item in obj2) {
            if (obj1[item] === undefined || (!ignoreNull && obj1[item] === null)) {
                obj1[item] = obj2[item];
            }
        }

        return obj1;
    },

    getLinkedChartDataJSON = function (linkedDataId, FCDataObj) {
        var linkedDataJSON = {
            "chart":{}
        },
        index,
        FcJSON = FCDataObj;

        linkedDataId = linkedDataId.toLowerCase();
        if (FcJSON.linkeddata) {
            for (index = 0; index < FcJSON.linkeddata.length; index += 1) {
                if (FcJSON.linkeddata[index].id.toLowerCase() === linkedDataId) {
                    linkedDataJSON = FcJSON.linkeddata[index].linkedchart ||
                        FcJSON.linkeddata[index].linkedmap;
                }
            }
        }
        return linkedDataJSON;
    },

    /**
     * This function call multylevel js function given as STR
     */
    limitedEvalParser = function () {

        var DOT = '.',
            windowPropIdentifier = /^@window_/g,
            FUNCTION = 'function';

        return function (expr, args) {
            var
                pattern = expr.replace(/\[[\'\"]/g, DOT)
                    .replace(/[\'\"]\]/g, BLANK) // remove all quotations.
                    // replace all opening "[" with identifier that it is a
                    // variable in global scope.
                    .replace(/\[/g, '.@window_')
                    .replace(/\]/g, BLANK), // romove all closing "]"
                tokens = pattern.split(DOT),
                obj = win,
                boxObj,
                windowProp,
                tokenEx = BLANK,
                token,
                l,
                i;

            l = tokens.length;
            for (i = 0; i < l; i += 1) {
                token = tokens[i];
                boxObj = obj;
                if (token.match(windowPropIdentifier)) {
                    windowProp = win[token.replace(windowPropIdentifier, BLANK)];
                    obj = obj[windowProp];
                }
                else if (obj === undefined || obj === null) {
                    throw (tokenEx || token).replace(windowPropIdentifier,
                            BLANK) + " is not defined";
                }
                else {
                    obj = obj[token]
                }
                tokenEx = token;
            }

            if (obj && (typeof obj.call === FUNCTION || obj === win.alert)) {
                if (obj === win.alert) { // for IE6 bug
                    obj(args);
                }
                else {
                    obj.call(boxObj, args);
                }
            }
            else {
                setTimeout(function ()  {
                    throw token.replace(windowPropIdentifier, BLANK) +
                        "() is not a function";
                }, 0);
            }
        }
    }(),

    secureEval = (function () {
        var evalKey = 'FusionChartslinkEval' + parseInt(+new Date(), 10);
        return function (expr) {
            // put under trial so that effective error in data does
            // not stall chart.
            try {
                // Creating anonymous function and removing it
                // from current scope and sending to global.
                win[evalKey] = new Function(expr);
                // Executing the banished function by
                // impersonating global scope.
                eval("window['" + evalKey + "']();");
            }
            catch (err) {
                // raise error asynchronously
                setTimeout(function () {
                    // strip line number trace from error before
                    // throwing
                    throw err;
                }, 0);
            }
            // remove delegate function
            if (hasSVG) {
                delete win[evalKey];
            }
            else {
                win[evalKey] = null;
            }
        };
    }()),

    getLinkAction = function (dataObj, chartInstance) {
        var secureLink = function (link) {
                return link;
            };

        return function () {
            var chartAttrs = dataObj.chart || dataObj.map || {},
                unescapeLinks = pluckNumber(chartAttrs.unescapelinks, 1),

                pointLink = getFirstValue(this.link, BLANK),
                pointChartLink = (this.series && this.series.chart &&
                    this.series.chart.options
                    && this.series.chart.options.chart &&
                    this.series.chart.options.chart.link) || BLANK,
                chartLink = (this.options && this.options.chart &&
                    this.options.chart.link) || BLANK,
                strLink = pluck(pointLink, chartLink, pointChartLink),
                originalLink = strLink,
                dashPos,
                frameDetails,
                commaPos,
                linkURL,
                delimiter,
                linkType,
                linkedDataId,
                linkedData,
                alias,
                firstBreak;
            //We continue only if the link is not empty
            if (strLink !== undefined) {
                // first we decode the link
                // And we trim the link
                if (unescapeLinks) {
                    strLink = win.decodeURIComponent ?
                        win.decodeURIComponent(strLink) : unescape(strLink);
                }

                strLink = strLink.replace(/^\s+/,
                    BLANK).replace(/\s+$/, BLANK);

                if (strLink.search(/^[a-z]*\s*[\-\:]\s*/i) !== -1) {
                    delimiter = strLink.split(/\s*[\-\:]\s*/)[0].toLowerCase();
                    firstBreak = delimiter.length;
                }

                // Now based on what the first character in the link is (N, F, P, S, J)
                // And (NEWCHART, JAVASCRIPT:)
                // we invoke the link.
                setTimeout(function() {

                    switch (delimiter) {
                        case "j":
                            // We remove blank spaces between "j" and "-" if any
                            strLink = strLink.replace(/^j\s*\-/i, "j-");

                            dashPos = strLink.indexOf("-", 2);
                            //If no arguments, just call the link
                            if (dashPos === -1) {
                                limitedEvalParser(strLink.slice(2));
                            }
                            // There could be multiple parameters.
                            // We just pass them as a single string to JS method.
                            else {
                                limitedEvalParser(strLink.substr(2, dashPos - 2).replace(/\s/g, BLANK),
                                    strLink.slice(dashPos + 1));
                            }

                            break;

                        case "javascript":
                            // remove "javascript:" prefix and evaluate expression.
                            secureEval(strLink.replace(/^javascript\s*\:/i, BLANK));
                            break;

                        case "n":
                            strLink.replace(/^n\s*\-/i, "n-");
                            win.open(secureLink(strLink.slice(2), unescapeLinks));
                            break;

                        case "f":
                            strLink = strLink.replace(/^f\s*\-/i, "f-");

                            //strLink.slice(dashPos+1) indicates arguments if any
                            //strLink.substr(2, dashPos-2) indicates link
                            dashPos = strLink.indexOf("-", 2);
                            //If no arguments, just call the link
                            if (dashPos !== -1) {
                                frameDetails = strLink.substr(2, dashPos - 2);
                                if (frameDetails && win.frames[frameDetails]) {
                                    win.frames[frameDetails].location =
                                        secureLink(strLink.slice(dashPos + 1),
                                        unescapeLinks);
                                } else {
                                    win.open(secureLink(strLink.slice(dashPos + 1),
                                        unescapeLinks), frameDetails);
                                }
                            }
                            else {
                                win.open(secureLink(strLink.slice(2), unescapeLinks));
                            }
                            break;

                        case "p":
                            strLink = strLink.replace(/p\s*\-/i, "p-");
                            dashPos = strLink.indexOf ("-", 2);
                            commaPos = strLink.indexOf (COMMASTRING, 2);
                            if (dashPos === -1) {
                                dashPos = 1;
                            }

                            linkURL = secureLink(strLink.slice(dashPos + 1),
                                unescapeLinks);
                            win.open(linkURL,
                                strLink.substr(2, commaPos - 2),
                                strLink.substr(commaPos + 1, dashPos - commaPos - 1))
                            .focus();
                            break;

                        case "newchart":
                        case "newmap":
                            //Linked chart. if alias found
                            if (strLink.charAt(firstBreak) === ':') {
                                //find next '-'
                                dashPos = strLink.indexOf ("-", firstBreak + 1);
                                alias = strLink.substring(firstBreak + 1, dashPos);
                                firstBreak = dashPos;
                            }

                            // Find the second dash position
                            dashPos = strLink.indexOf ("-", firstBreak + 1);

                            // Figure out whether the sub-linked chart is xml or url
                            linkType = strLink.substring(firstBreak + 1,
                                    dashPos).toLowerCase();

                            switch (linkType) {
                                case "xmlurl":
                                case "jsonurl":
                                    linkedData = strLink.substring(dashPos + 1,
                                        strLink.length);
                                    break;
                                case "xml":
                                case "json":
                                    // Extract linked data identifier
                                    linkedDataId = strLink.substring(dashPos + 1,
                                        strLink.length);
                                    // Get the data for the linked chart
                                    linkedData = getLinkedChartDataJSON(linkedDataId,
                                    dataObj);
                                    // If linkedData is empty string, it means
                                    // data identifier or linked data was not found.
                                    linkType = "json";
                                    break;
                            }

                            global.raiseEvent('LinkedChartInvoked', {
                                alias: alias,
                                linkType : linkType.toUpperCase(),
                                data : linkedData
                            }, chartInstance);
                            break;

                        default:
                            win.location.href = secureLink(strLink, unescapeLinks);
                            break;
                    }

                    global.raiseEvent('linkclicked', {
                        linkProvided: originalLink,
                        linkInvoked: strLink,
                        linkAction: delimiter && delimiter.toLowerCase()
                    }, chartInstance);
                }, 0);
            }
        };
    },




    // GRAPHICS FUNCTION
    getAlpha = function (alpha, multiplyer) {
        alpha = Number(alpha);
        alpha = isNaN(alpha) ? 100 : alpha;
        if (multiplyer !== undefined) {
            alpha = alpha * multiplyer / 100;
        }
        return alpha % 101;
    },

    parseAlpha = function (alpha, length, multiplyer) {
        var alphaArr = alpha.split(COMMASTRING), x;
        if (multiplyer !== undefined) {
            multiplyer = pluckNumber(multiplyer.split(COMMASTRING)[0]);
        }
        alphaArr[0] = getAlpha(alphaArr[0], multiplyer);
        for (x = 1; x < length; x+= 1) {
            alphaArr[x] = alphaArr[0] * getAlpha(alphaArr[x], multiplyer) / 100;
        }
        return alphaArr.join(COMMASTRING);
    },

    //reduce gradient color take only first color
    //converts color to compatable color format
    //**** rgba must be rgbs(r,g,b,a) format
    

    convertColor = function (color, alpha, rgba) {
        var R = 0, G = 0, B = 0, colorStr, tempArr;

        if (rgba && rgba.match(startsRGBA)) {
            tempArr = rgba.split(COMMASTRING);
            R = tempArr[0].slice(tempArr[0].indexOf('(') + 1);
            G = tempArr[1];
            B = tempArr[2];
            if (!alpha && alpha !== 0) {
                alpha = parseInt((tempArr[3].slice(0, tempArr[3].indexOf(')')) * 100), 10);
            }
        }
        if (color) {
            if (color.match(startsRGBA)) {
                tempArr = color.split(COMMASTRING);
                R = tempArr[0].slice(tempArr[0].indexOf('(') + 1);
                G = tempArr[1];
                B = tempArr[2];
            }
            else {
                colorStr = color.replace(cleanColorCode, BLANK).split(COMMASTRING)[0];
                switch (colorStr.length) {
                    case 3:
                        colorStr = colorStr[0] + colorStr[0] + colorStr[1] + colorStr[1] + colorStr[2] + colorStr[2];
                        break;
                    case 6:
                        break;
                    default:
                        colorStr = (colorStr + COLOR_WHITE).slice(0, 6);
                        break;
                }
                R = parseInt(colorStr.slice(0, 2), 16);
                G = parseInt(colorStr.slice(2, 4), 16);
                B = parseInt(colorStr.slice(4, 6), 16);
            }
        }

        if (!alpha && alpha != 0) {
            alpha = 100;
        }
        if (typeof alpha === STRINGSTRING) {
            alpha = alpha.split(COMMASTRING)[0];
        }
        alpha = parseInt(alpha, 10) / 100;
        return 'rgba(' + R + COMMASTRING + G + COMMASTRING + B + COMMASTRING + alpha + ')';
    },

    // Returns a color code including # before it
    parseColor = function (color) {
        return color.replace(cleanColorCode, BLANK).replace(dropHash, HASHSTRING);
    },
    // Returns a valid color or undefined
    getValidColor = function (color) {
        return validhexcolor.test(parseColor(color)) && color;
    },
    /*
     *  Function to generate color shade of a color
     *  one shade to darker and another is the lighter
     */
    getColorOffset = function (arrColorRGB, offsetPercent, isLighter) {
        var R,G,B;
        offsetPercent = offsetPercent < 0 || offsetPercent > 100 ? 100 : offsetPercent;
        offsetPercent = offsetPercent / 100;
        if (isLighter) {
            // Creating darker shade in decimal
            // and convert single digit to two digit format
            R = mathRound(arrColorRGB[0] + ((255 - arrColorRGB[0]) * offsetPercent));
            G = mathRound(arrColorRGB[1] + ((255 - arrColorRGB[1]) * offsetPercent));
            B = mathRound(arrColorRGB[2] + ((255 - arrColorRGB[2]) * offsetPercent));
        } else {
            // Creating lighter shade in decimal
            // and convert single digit to two digit format
            R = mathRound(arrColorRGB[0] - (arrColorRGB[0] * offsetPercent));
            G = mathRound(arrColorRGB[1] - (arrColorRGB[1] * offsetPercent));
            B = mathRound(arrColorRGB[2] - (arrColorRGB[2] * offsetPercent));
        }
        return [R, G, B];
    },
    getDarkColor = function (color, offsetPercent) {
        offsetPercent = offsetPercent < 0 || offsetPercent > 100 ? 100 : offsetPercent;
        offsetPercent = offsetPercent / 100;
        // Removing spaces and # form color
        color = color.replace(cleanColorCode, BLANK);
        var sourceclrRGB = parseInt(color, 16),
        // Converting color in R B G
        R = Math.floor(sourceclrRGB/65536),
        G = Math.floor((sourceclrRGB-R*65536)/256),
        B = sourceclrRGB-R*65536-G*256;
        return (COLOR_BLACK + ((R*offsetPercent) << 16 | (G*offsetPercent) <<
            8 | (B*offsetPercent)).toString(16)).slice(-6);
    },
    getLightColor = function (color, offsetPercent) {
        offsetPercent = offsetPercent < 0 || offsetPercent > 100 ? 100 : offsetPercent;
        offsetPercent = offsetPercent / 100;
        // Removing spaces and # form color
        color = color.replace(cleanColorCode, BLANK);
        var sourceclrRGB = parseInt(color, 16),
        // Converting color in R B G
        R = Math.floor(sourceclrRGB/65536),
        G = Math.floor((sourceclrRGB-R*65536)/256),
        B = sourceclrRGB-R*65536-G*256;
        return (COLOR_BLACK + ((256-((256-R)*offsetPercent)) << 16 | (256-((256-G)*offsetPercent)) <<
            8 | (256-((256-B)*offsetPercent))).toString(16)).slice(-6);
    },

    /**
    * HSBtoRGB methods takes an array of HSB color values and convert them
    * RGB color values and return an array conatining the Red,Green and
    * Blue color value of the provided HSB color.
    *
    * @param   hsb	Array	The array of Hue,Saturation and Brightness property
    * 						of a color.
    *
    * @return  Array	The Array of RGB color value of the specified color.
    */

    HSBtoRGB = function (hsb){
        var h = hsb[0], s = hsb[1], v = hsb[2],

        r = 0,
        g = 0,
        b = 0,
        rgb = [],

        tempS = s / 100,
        tempV = v / 100,

        hi = Math.floor(h/60) % 6,
        f = h/60 - Math.floor(h/60),
        p = (tempV * (1 - tempS)),
        q = (tempV * (1 - f * tempS)),
        t = (tempV * (1 - (1 - f) * tempS));

        switch(hi){
            case 0:
                r = tempV;
                g = t;
                b = p;
                break;
            case 1:
                r = q;
                g = tempV;
                b = p;
                break;
            case 2:
                r = p;
                g = tempV;
                b = t;
                break;
            case 3:
                r = p;
                g = q;
                b = tempV;
                break;
            case 4:
                r = t;
                g = p;
                b = tempV;
                break;
            case 5:
                r = tempV;
                g = p;
                b = q;
                break;
        }

        rgb = [mathRound(r * 255), mathRound(g * 255), mathRound(b * 255)];
        return rgb;
    },


    /**
     * RGBtoHSB methods takes an array of RGB color values and convert them
     * HSB color values and return an array conatining the Hue,Saturation and
     * Brightness of the specified RGB color.
     *
     * @param   rgb Array	The array of RGB color values respective.The 0 index contains
     * 						Red color value, 1 index contains the Green color value and the
     * 						2nd or the last index conatins the blue color value.
     *
     * @return  Array	Color value array containing the Hue, Saturation and brightness of
     * 					The provided Color.
     */
    RGBtoHSB = function (rgb){

        var r = rgb[0],  g = rgb[1],  b =rgb[2],

        max = Math.max(Math.max(r,g),b),
        min = Math.min(Math.min(r,g),b),

        hue = 0,  saturation = 0,  value = 0;

        //get Hue
        if(max == min){
            hue = 0;
        }else if(max == r){
            hue = (60 * (g-b) / (max-min) + 360) % 360;
        }else if(max == g){
            hue = (60 * (b-r) / (max-min) + 120);
        }else if(max == b){
            hue = (60 * (r-g) / (max-min) + 240);
        }


        //get Saturation
        if(max == 0){
            saturation = 0;
        }else{
            saturation = (max - min) / max;
        }

        return [mathRound(hue), mathRound(saturation * 100), mathRound(max / 255 * 100)];
    },

    /**
     * RGBtoHex methods takes an array of RGB color values and convert them to
     * a hexadecimal color value.And return the string.
     *
     * @param   rgb Array	The array of RGB color values respective.The 0 index contains
     * 						Red color value, 1 index contains the Green color value and the
     * 						2nd or the last index conatins the blue color value.
     *
     * @return  String	The hexadecimal color string of the provided RGB value.
     */
    RGBtoHex = function (rgb){
        return (COLOR_BLACK + (rgb[0] << 16 | rgb[1] << 8 | rgb[2]).toString(16)).slice(-6);
    },

    /**
     * HEXtoRGB method convert one hexColor string to HSB color
     * values.And return the value in an array, where the index value
     * containes Hue, saturaion and Brightness value of the provided
     * HexColor respectively.
     *
     * @param   sourceColor 	The hexadecimal Color string value.
     * @return  Array			The HSB color values in respective order.
     */
    HEXtoRGB = function (sourceColor){
        var sourceClrRGB = parseInt(sourceColor,16),
        r = Math.floor(sourceClrRGB/65536),
        g =  Math.floor((sourceClrRGB-r*65536)/256),
        b =  Math.floor((sourceClrRGB-r*65536)-(g*256));

        return [r, g, b];
    },


    symbolStr = {
        circle : 'circle',
        triangle : 'triangle',
        square : 'square',
        diamond : 'diamond',
        poly : 'poly_',
        spoke : 'spoke_'
    },

    //map FusionCharts anchor sides to HC anchor symbol
    //anchorside > 4 will show the down triangle
    mapSymbolName = function (num, isSpoke) {
        var x = symbolStr.circle;
        num = parsePointValue(num);
        if (num >= 3) {
            x = (isSpoke ? symbolStr.spoke : symbolStr.poly) + num;
        }
        return x;
    },

    // helper fnction for draw3Drect
    getAngle = function (width, height, type) {
        var angle = Math.atan(height / width) * 180 / Math.PI;
        if (type == 2) {
            angle = 180 - angle;
        }
        else if (type == 3) {
            angle += 180;
        }
        else if (type == 4) {
            angle = 360 - angle;
        }
        return angle;
    },

    

    //this function create the column color depending upon the configuration
    getColumnColor = function (setColor, setAlpha, ratio, angle, isRoundEdges, bdColor, bdAlpha, isBar, is3d) {
        var bgColor, borderColor, colorArr, alphaArr, bdColorArr, color, alpha, bdAlphaArr;
        colorArr = setColor.split(COMMASTRING);
        alphaArr = setAlpha.split(COMMASTRING);
        bdColorArr = bdColor.split(COMMASTRING);
        bdAlphaArr = bdAlpha.split(COMMASTRING);
        // remove extra comma if there at the end.
        setColor = setColor.replace(/\s/g, BLANK).replace(/\,$/, BLANK);
        if (is3d) {
            bgColor = {
                FCcolor: {
                    color: colorArr[0],
                    alpha: alphaArr[0]
                }
            };
        }
        else if (isRoundEdges) {
            color = colorArr[0];
            alpha = alphaArr[0]
            bgColor = {
                FCcolor: {
                    // [ColorExt.getDarkColor(this.color, 0.75),
                    // ColorExt.getLightColor(this.color, 0.25),
                    // ColorExt.getDarkColor(this.color, 0.8),
                    // ColorExt.getLightColor(this.color, 0.65),
                    // ColorExt.getDarkColor(this.color, 0.8)]
                    color: getDarkColor(color, 75) + COMMASTRING + getLightColor(color, 10) + COMMASTRING +
                    getDarkColor(color, 90) + COMMASTRING + getLightColor(color, 55) + COMMASTRING + getDarkColor(color, 80),
                    alpha: alpha + COMMASTRING + alpha + COMMASTRING + alpha +
                    COMMASTRING + alpha + COMMASTRING + alpha,
                    ratio: "0,11,14,57,18",
                    angle: isBar ? "90" : "0"
                }
            };
            bdColorArr = [getDarkColor(color, 70)];
        }
        else {
            setAlpha = parseAlpha(setAlpha, colorArr.length);
            bgColor = {
                FCcolor: {
                    color: setColor,
                    alpha: setAlpha,
                    ratio: ratio,
                    angle: isBar? -angle : angle
                }
            };

        }
        borderColor = {
            FCcolor: {
                color: bdColorArr[0],
                alpha: bdAlphaArr[0]
            }
        }


        return [bgColor, borderColor];
    },

    toPrecision = function (obj, value) {
        var tenPow = mathPow(10, value);
        return mathRound(obj * tenPow) / tenPow;
    },

    supportedStyle = {
        font: 'font',
        fontFamily: 'font-family',
        'font-family' : 'font-family',
        fontWeight: 'font-weight',
        'font-weight' : 'font-weight',
        fontSize: 'font-size',
        'font-size' : 'font-size',
        lineHeight: 'line-height',
        'line-height': 'line-height',
        textDecoration: 'text-decoration',
        'text-decoration' : 'text-decoration',
        color: 'color',
        whiteSpace : 'white-space',
        'white-space' : 'white-space',
        padding : 'padding',
        margin : 'margin',
        background : 'background',
        backgroundColor : 'background-color',
        'background-color' : 'background-color',
        backgroundImage : 'background-image',
        'background-image' : 'background-image',
        backgroundPosition : 'background-position',
        'background-position' : 'background-position',
        backgroundPositionLeft : 'background-position-left',
        'background-position-left' : 'background-position-left',
        backgroundPositionTop : 'background-position-top',
        'background-position-top' : 'background-position-top',
        backgroundRepeat : 'background-repeat',
        'background-repeat' : 'background-repeat',
        border : 'border',
        borderColor : 'border-color',
        'border-color' : 'border-color',
        borderStyle : 'border-style',
        'border-style' : 'border-style',
        borderThickness : 'border-thickness',
        'border-thickness' : 'border-thickness',
        borderTop: 'border-top',
        'border-top' : 'border-top',
        borderTopColor : 'border-top-color',
        'border-top-color' : 'border-top-color',
        borderTopStyle : 'border-top-style',
        'border-top-style' : 'border-top-style',
        borderTopThickness : 'border-top-thickness',
        'border-top-thickness' : 'border-top-thickness',
        borderRight : 'border-right',
        'border-right' : 'border-right',
        borderRightColor : 'border-right-color',
        'border-right-color' : 'border-right-color',
        borderRightStyle : 'border-right-style',
        'border-right-style' : 'border-right-style',
        borderRightThickness : 'border-right-thickness',
        'border-right-thickness' : 'border-right-thickness',
        borderBottom : 'border-bottom',
        'border-bottom' : 'border-bottom',
        borderBottomColor : 'border-bottom-color',
        'border-bottom-color' : 'border-bottom-color',
        borderBottomStyle : 'border-bottom-style',
        'border-bottom-style' : 'border-bottom-style',
        borderBottomThickness : 'border-bottom-thickness',
        'border-bottom-thickness' : 'border-bottom-thickness',
        borderLeft : 'border-left',
        'border-left' : 'border-left',
        borderLeftColor : 'border-left-color',
        'border-left-color' : 'border-left-color',
        borderLeftStyle : 'border-left-style',
        'border-left-Style' : 'border-left-style',
        borderLeftThickness: 'border-left-thickness',
        'border-left-thickness' : 'border-left-thickness'
    },

    setLineHeight = (function () {
        var container = document.createElement('span'), getLineHeight,
        donotUseStyle = {
            lineHeight : true,
            'line-height' : true
        },
        calculateLH = function () {
            var fontSize = pluckNumber(parseInt(container.style.fontSize, 10), 10);
            return (fontSize * 1.4) + 'px';
        };
        container.innerHTML = 'fy';
        if (window.getComputedStyle) {
            getLineHeight = function () {
                // Procure a reference to the style node.
                var styleNode = window.getComputedStyle(container, null);
                // Verify if the style node returns a valid line-height
                if (styleNode && styleNode.getPropertyValue(LINEHEIGHT)) {
                    return styleNode.getPropertyValue(LINEHEIGHT);
                }
                // In case the style node does not exist, return manually
                // calculated line-height
                else {
                    return calculateLH.apply(this, arguments);
                }
            }
        }
        else if (container.currentStyle){
            getLineHeight = function () {
                return container.currentStyle.lineHeight;
            }
        }
        else {
            getLineHeight = calculateLH;
        }
        return function (styleObj) {
            var key, styleStr = '';
            for (key in styleObj) {
                if (!donotUseStyle[key] && supportedStyle[key]) {
                    styleStr += supportedStyle[key] + ' : ' + styleObj[key] + ';';
                }
            }

            if (isIE && !hasSVG) {
                container.style.setAttribute('cssText', styleStr);
            }
            else {
                container.setAttribute('style', styleStr);
            }

            var lineHeight = getLineHeight();
            if (!parseFloat(lineHeight)) {
                lineHeight = calculateLH();
            }
            styleObj.lineHeight = lineHeight;
            return lineHeight;
        };
    }()),

    /**
     * BG Image align attribute managing function
     */
    setImageDisplayMode = function (bgImageDisplayMode, bgImageVAlign,
        bgImageHAlign, bgImageScale, chartBorderWidth, chartWidth,
        chartHeight, imageEle) {
        var imageWidth = imageEle.width * (bgImageScale / 100),
        imageHeight = imageEle.height * (bgImageScale / 100),
        alignImage = {},
        imgAspectRatio, cAspectRatio, scaleFactor,
        xCount, yCount,
        //Consider the borderthickness and find out chart width and height
        cWidth = chartWidth - (chartBorderWidth * 2),
        cHeight = chartHeight - (chartBorderWidth * 2),
        // Function to align the image
        // returns x y position of the image
        getImageAlignment = function (bgImageVAlign, bgImageHAlign, imageWidth, imageHeight, chartWidth, chartHeight) {
            var alignObj = {};
            switch (bgImageVAlign) {
                case "top":
                    alignObj.y = chartBorderWidth;
                    break;
                case "bottom":
                    alignObj.y = chartHeight - imageHeight - chartBorderWidth;
                    break;
                case "middle":
                    alignObj.y = (chartHeight - imageHeight) / 2;
                    break;
            }


            switch (bgImageHAlign) {
                case "left":
                    alignObj.x = chartBorderWidth;
                    break;
                case "right":
                    alignObj.x = chartWidth - imageWidth - chartBorderWidth;
                    break;
                case "middle":
                    alignObj.x = (chartWidth - imageWidth) / 2;
                    break;
            }
            return alignObj;
        };


        switch (bgImageDisplayMode) {
            case "center":
                alignImage.width = imageWidth;
                alignImage.height = imageHeight;
                alignImage.y = (chartHeight / 2) - (imageHeight / 2);
                alignImage.x = (chartWidth / 2) - (imageWidth / 2);
                break;

            case "stretch"://Stretch Display Mode
                alignImage.width = (chartWidth - chartBorderWidth * 2);
                alignImage.height = (chartHeight - chartBorderWidth * 2);
                alignImage.y = chartBorderWidth;
                alignImage.x = chartBorderWidth;
                break;

            case "tile"://Tile Display Mode
                alignImage.width = imageWidth;
                alignImage.height = imageHeight;
                alignImage.tileInfo = {};
                alignImage.tileInfo.xCount = xCount = Math.ceil(cWidth / imageWidth);
                alignImage.tileInfo.yCount = yCount =  Math.ceil(cHeight / imageHeight);

                alignObj = getImageAlignment (bgImageVAlign, bgImageHAlign,
                    imageWidth * xCount, imageHeight * yCount, chartWidth, chartHeight);

                alignImage.y = alignObj.y;
                alignImage.x = alignObj.x;
                break;

            case "fit"://Fit Display Mode

                //Original image's aspect ratio.
                imgAspectRatio = imageWidth / imageHeight;
                //Chart's background aspect ratio
                cAspectRatio = cWidth / cHeight;
                scaleFactor = (imgAspectRatio > cAspectRatio) ?  cWidth / imageWidth : cHeight / imageHeight;

                alignImage.width = imageWidth * scaleFactor;
                alignImage.height = imageHeight * scaleFactor;

                alignObj = getImageAlignment (bgImageVAlign, bgImageHAlign,
                    alignImage.width, alignImage.height, chartWidth, chartHeight);

                alignImage.y = alignObj.y;
                alignImage.x = alignObj.x;
                break;

            case "fill"://Fill Display Mode

                //Original image's aspect ratio.
                imgAspectRatio = imageWidth / imageHeight;
                //Chart's background aspect ratio
                cAspectRatio = cWidth / cHeight;
                //Find out scale factor
                scaleFactor = (imgAspectRatio > cAspectRatio) ?  cHeight / imageHeight : cWidth / imageWidth;

                alignImage.width = imageWidth * scaleFactor;
                alignImage.height = imageHeight * scaleFactor;

                alignObj = getImageAlignment (bgImageVAlign, bgImageHAlign,
                    alignImage.width, alignImage.height, chartWidth, chartHeight);

                alignImage.y = alignObj.y;
                alignImage.x = alignObj.x;

                break;

            default : // None
                //In none mode image only need alignment.
                alignObj = getImageAlignment (bgImageVAlign, bgImageHAlign,
                    imageWidth, imageHeight, chartWidth, chartHeight);

                alignImage.width = imageWidth;
                alignImage.height = imageHeight;
                alignImage.y = alignObj.y;
                alignImage.x = alignObj.x;
        }

        return alignImage;
    },


    /*
     *manager to add axis labels
     */
    axisLabelAdder = (function () {
        var TEXTPOSITION = {
            top : {
                align: 'center',
                verticalAlign: 'top',
                textAlign: 'center'
            },
            right : {
                align: 'right',
                verticalAlign: 'middle',
                textAlign: 'left'
            },
            bottom : {
                align: 'center',
                verticalAlign: 'bottom',
                textAlign: 'center'
            },
            left : {
                align: 'left',
                verticalAlign: 'middle',
                textAlign: 'right'
            }
        },
        alphaRetriveRegx = /([^\,^\s]+)\)$/g,
        labelAdder = function (defaultSeries, FCchartObj) {
            var labelStep;
            

            if (/^(bar|bar3d)$/.test(defaultSeries)) {
                this.isBar = true;
                this.yPos = 'bottom';
                this.yOppPos = 'top';
                this.xPos = 'left';
                this.xOppPos = 'right';
            }
            //steping attr
            labelStep = parseInt(FCchartObj.labelstep, 10);
            this.labelStep = labelStep > 1 ? labelStep : 1;
            this.showLabel = pluckNumber(FCchartObj.showlabels, FCchartObj.shownames, 1);
            this.is3D = /3d$/.test(defaultSeries);

        };
        labelAdder.prototype = {
            isBar : false,
            yPos : 'left',
            yOppPos : 'right',
            xPos : 'bottom',
            xOppPos : 'top',
            //Note: linecolor must be in rgba str
            addAxisGridLine : function (axisObj, value, text, width, dashStyle, lineColor, zIndex, isXxis) {
                var hasText = text === '' ? false : true, hasVisibleLine = width > 0 ||
                lineColor.match(alphaRetriveRegx)[1] > 0 ? true : false, axisPos, textAttrs, gridLine;
                if (hasText || hasVisibleLine) {
                    if (!hasVisibleLine) {
                        lineColor = COLOR_TRANSPARENT;
                        width = 0.1;
                    }
                    gridLine = {
                        isGrid : true,
                        width: width,
                        dashStyle  : dashStyle,
                        color  : lineColor,
                        value: value,
                        zIndex : zIndex === undefined ? 2 : zIndex
                    };
                    if (hasText) {
                        axisPos = axisObj.opposite ? (isXxis ? this.xOppPos : this.yOppPos) : (isXxis ? this.xPos : this.yPos);
                        textAttrs = TEXTPOSITION[axisPos];
                        gridLine.label = {
                            text : text,
                            style : axisObj.labels.style,
                            textAlign : textAttrs.textAlign,
                            align  : textAttrs.align,
                            verticalAlign : textAttrs.verticalAlign,
                            rotation : 0,
                            x : 0,
                            y : 0
                        };
                    }
                    axisObj.plotLines.push(gridLine);
                }
                return gridLine;
            },
            addAxisAltGrid : function (axisObj, currentValue) {
                if (!this.is3D) {
                    var lastValue = pluckNumber(axisObj['_lastValue'], axisObj.min),
                    altGrid = pluck(axisObj['_altGrid'], false);
                    if (altGrid) {
                        axisObj.plotBands.push({
                            isGrid : true,
                            color  : axisObj.alternateGridColor,
                            to : currentValue,
                            from : lastValue,
                            zIndex : 1
                        });
                    }
                    axisObj['_lastValue'] = currentValue;
                    axisObj['_altGrid'] = !altGrid;
                }
            },
            addXaxisCat : function (axisObj, value, index, label) {
                var axisPosition = axisObj.opposite ? this.xOppPos : this.xPos,
                textAttrs = TEXTPOSITION[axisPosition],
                gridLine = {
                    isGrid : true,
                    width: 0.1,
                    color  : COLOR_TRANSPARENT,
                    value: value,
                    label : {
                        text : label,
                        style : axisObj.labels.style,
                        textAlign : textAttrs.textAlign,
                        align  : textAttrs.align,
                        verticalAlign : textAttrs.verticalAlign,
                        rotation : 0,
                        x : 0,
                        y : 0
                    }
                };

                if (index % this.labelStep !== 0) {
                    gridLine.stepped = true;
                    gridLine.label.style = axisObj.steppedLabels.style;
                }
                axisObj.plotLines.push(gridLine);
            },
            addVline : function (axisObj, dataObj, index, hcObj) {
                //Extract attributes
                var conf = hcObj[FC_CONFIG_STRING],
                isBar = conf.isBar,
                plotBorderWidth = hcObj.chart.plotBorderWidth,
                pbwMod2 = (plotBorderWidth % 2),
                divlineStyle = conf.divlineStyle,
                label = parseUnsafeString(dataObj.label),
                showLabelBorder = Boolean(pluckNumber(dataObj.showlabelborder, conf.showVLineLabelBorder, 1)),
                showLabelBackground = Boolean(pluckNumber(dataObj.showlabelbackground, 1)),
                labelHAlign = pluck(dataObj.labelhalign, isBar ? POSITION_LEFT : POSITION_CENTER),
                labelVAlign = pluck(dataObj.labelvalign, isBar ? POSITION_MIDDLE : POSITION_BOTTOM).toLowerCase(),
                labelPosition = pluckNumber(dataObj.labelposition, 0), 

                linePosition = pluckNumber(dataObj.lineposition, 0.5),
                showVLines = pluckNumber(dataObj.showvlines, conf.showVLines, 1),
                alpha = pluckNumber(dataObj.alpha, conf.vLineAlpha, 80),
                color = pluck(dataObj.color, conf.vLineColor, "333333").replace(/^#?/, "#"),
                bgColor = showLabelBackground ? pluck(dataObj.labelbgcolor, conf.vLineLabelBgColor,
                        "333333").replace(/^#?/, "#") : BLANK,
                labelColor = color,
                thickness = pluckNumber(dataObj.thickness, conf.vLineThickness, 1),
                halfThickness = thickness * 0.5,
                isDashed = Boolean(Number (pluck (dataObj.dashed, 0))),
                dashLen = pluckNumber(dataObj.dashlen, 5),
                dashGap = pluckNumber(dataObj.dashgap, 2),
                smartLabel = conf.smartLabel,
                fontSizeInt = parseInt(divlineStyle.fontSize, 10),
                y = fontSizeInt + 2,
                x = 0,
                smartText,
                labelRotation = pluckNumber(dataObj.rotatelabel,
                    conf.rotateVLineLabels) ? 270 : 0;

                linePosition = (linePosition < 0 || linePosition > 1) ? 0.5 : linePosition;
                labelPosition = (labelPosition < 0 || labelPosition > 1) ? 0 : labelPosition;
                smartLabel.setStyle(divlineStyle);
                smartText = smartLabel.getOriSize(label);

                color = convertColor(color, showVLines ? alpha : '0');

                if (!isBar) {
                    switch (labelVAlign) {
                        case POSITION_TOP:
                            y -= smartText.height + 2 + (plotBorderWidth || 1) *
                            (1 - labelPosition) + labelPosition;
                            break;
                        case POSITION_MIDDLE:
                            y -= (smartText.height * 0.5) + plotBorderWidth * (1 - labelPosition * 2);
                            break;
                        default:
                            y += (plotBorderWidth - pbwMod2) * labelPosition;

                    }
                    switch (labelHAlign) {
                        case POSITION_LEFT:
                            x += thickness;
                            break;
                        case POSITION_RIGHT:
                            x -= thickness + 1;
                            break;
                    }
                }
                else {
                    switch (labelVAlign) {
                        case POSITION_TOP:
                            y -= smartText.height + halfThickness + 2;
                            break;
                        case POSITION_MIDDLE:
                            y -= (smartText.height * 0.5) + 1;
                            break;
                        default:
                            y += halfThickness;
                    }

                    if (!dataObj.labelhalign) {
                        x -= smartText.width * labelPosition;
                    }
                }

                axisObj.plotLines.push({
                    isVline : true,
                    color: color,
                    width: thickness,
                    value: (index - 1) + linePosition,
                    zIndex : pluckNumber(dataObj.showontop, conf.showVLinesOnTop) ? 5 : 3, // extra for js charts
                    dashStyle : isDashed ? getDashStyle(dashLen, dashGap, thickness) : undefined,
                    label: {
                        text: label,
                        align: isBar ? POSITION_LEFT : POSITION_CENTER,
                        offsetScale : labelPosition,
                        rotation: labelRotation,
                        y: y,
                        x: x,
                        textAlign: labelHAlign,
                        backgroundColor: bgColor,
                        borderWidth: showVLines && showLabelBorder ? '1px' : BLANK,
                        borderType:  showVLines && showLabelBorder ? 'solid' : BLANK,
                        borderColor: showVLines && showLabelBorder ? labelColor : BLANK,
                        backgroundOpacity: showVLines && showLabelBackground ?
                            pluck(dataObj.labelbgalpha, conf.vLineLabelBgAlpha) / 100 : 0,
                        style: {
                            color: showVLines ? labelColor : color,
                            fontSize : divlineStyle.fontSize,
                            fontFamily : divlineStyle.fontFamily,
                            lineHeight : divlineStyle.lineHeight,
                            backgroundColor: bgColor
                        }
                    }
                });
            }
        };
        labelAdder.prototype.constructor = labelAdder;
        return labelAdder;
    })(),

    NumberFormatter = (function () {

        

        var TWOSTRING = "2",
        AUTOSTRING = 'auto',

        numberFormatDefaults = {
            formatnumber: ONESTRING,
            formatnumberscale: ONESTRING,
            defaultnumberscale: BLANK,
            numberscaleunit: ['K', 'M'],//'K,M',
            numberscalevalue: [1000, 1000], //'1000,1000',
            numberprefix: BLANK,
            numbersuffix: BLANK,
            // Decimals default value is different in different charts
            decimals: BLANK,
            forcedecimals: ZEROSTRING,
            yaxisvaluedecimals: TWOSTRING,
            decimalseparator: DECIMALSTRING,
            thousandseparator: COMMASTRING,
            // thousandSeparatorPosition new attribute added in numberFormatter
            // this defines the placement of thousandSeparator, defaultValue = 3
            // accepts comma separated value
            thousandseparatorposition: [3],
            indecimalseparator: BLANK,
            inthousandseparator: BLANK,
            sformatnumber: ONESTRING,
            sformatnumberscale: ZEROSTRING,
            sdefaultnumberscale: BLANK,
            snumberscaleunit: ['K','M'],
            snumberscalevalue: [1000, 1000],
            snumberprefix: BLANK,
            snumbersuffix: BLANK,
            sdecimals: TWOSTRING,
            sforcedecimals: ZEROSTRING,
            syaxisvaluedecimals: TWOSTRING,

            xFormatNumber : ZEROSTRING,
            xFormatNumberScale : ZEROSTRING,
            xDefaultNumberScale : BLANK,
            xNumberScaleUnit : ['K','M'],
            xNumberScaleValue : [1000, 1000],
            xNumberPrefix : BLANK,
            xNumberSuffix : BLANK
        },

        numberFormatOverrides = {
            mscombidy2d: {
                formatnumberscale: ONESTRING
            }
        },

        /*
         *  NumberFormatter function
         **/
        NumberFormatter = function (chartObj, chartAPI, isMultyAxis) {
            var numberscaleunit,
                snumberscaleunit, xnumberscaleunit, ticknumberscaleunit, ynumberscaleunit,
                numberscalevalue, xnumberscalevalue, ticknumberscalevalue, ynumberscalevalue,
                chartName = chartAPI.name,
                // chartSpecificConf
                csConf = extend2({}, numberFormatDefaults),//,
                thousandseparatorposition,
                snumberscalevalue,
                paramLabels,
                paramLabels2,
                param1,
                param2,
                baseConf,
                overrideConf = numberFormatOverrides[chartName];

            if (overrideConf) {
                csConf = extend2(csConf, overrideConf);
            }
            this.csConf = csConf;
            this.chartAPI = chartAPI;

            // Converting user given numberScaleUnit into array
            if (getValidValue(chartObj.numberscaleunit)) {
                numberscaleunit = chartObj.numberscaleunit.split(COMMASTRING);
            }
            if ((snumberscaleunit = getValidValue(chartObj.snumberscaleunit, chartObj.numberscaleunit))) {
                snumberscaleunit = snumberscaleunit.split(COMMASTRING);
            }
            if ((xnumberscaleunit = getValidValue(chartObj.xnumberscaleunit, chartObj.numberscaleunit))) {
                xnumberscaleunit = xnumberscaleunit.split(COMMASTRING);
            }
            if ((ticknumberscaleunit = getValidValue(chartObj.ticknumberscaleunit, chartObj.numberscaleunit))) {
                ticknumberscaleunit = ticknumberscaleunit.split(COMMASTRING);
            }
            if ((ynumberscaleunit = getValidValue(chartObj.ynumberscaleunit, chartObj.numberscaleunit))) {
                ynumberscaleunit = ynumberscaleunit.split(COMMASTRING);
            }

            // Converting user given numberScaleValue into array
            if (getValidValue(chartObj.numberscalevalue)) {
                numberscalevalue = chartObj.numberscalevalue.split(COMMASTRING);
            }
            if ((snumberscalevalue = getValidValue(chartObj.snumberscalevalue, chartObj.numberscalevalue))) {
                snumberscalevalue = snumberscalevalue.split(COMMASTRING);
            }
            if ((xnumberscalevalue = getValidValue(chartObj.xnumberscalevalue, chartObj.numberscalevalue))) {
                xnumberscalevalue = xnumberscalevalue.split(COMMASTRING);
            }
            if ((ticknumberscalevalue = getValidValue(chartObj.ticknumberscalevalue, chartObj.numberscalevalue))) {
                ticknumberscalevalue = ticknumberscalevalue.split(COMMASTRING);
            }
            if ((ynumberscalevalue = getValidValue(chartObj.ynumberscalevalue, chartObj.numberscalevalue))) {
                ynumberscalevalue = ynumberscalevalue.split(COMMASTRING);
            }
            // Converting user given numberScaleValue into array
            if(getValidValue(chartObj.thousandseparatorposition)) {
                thousandseparatorposition = chartObj.thousandseparatorposition.split(COMMASTRING);
                var length = thousandseparatorposition.length, value,
                lastValue = pluckNumber(thousandseparatorposition[length]);
                lastValue = lastValue ? lastValue : numberFormatDefaults
                .thousandseparatorposition[0];
                // Filtering the user given values
                while (length) {
                    length -= 1;
                    value = pluckNumber(Math.abs(thousandseparatorposition[length]));
                    if (!value) {
                        value = lastValue;
                    } else {
                        lastValue = value;
                    }
                    thousandseparatorposition[length] = value;
                }
            }

            if (!chartAPI) {
                chartAPI = {};
            }

            var scaleRecursively = pluckNumber(chartObj.scalerecursively, 0),
            sScaleRecursively = pluckNumber(chartObj.sscalerecursively, scaleRecursively),
            xScaleRecursively = pluckNumber(chartObj.xscalerecursively, scaleRecursively),
            maxScaleRecursion = pluckNumber(chartObj.maxscalerecursion, -1),
            sMaxScaleRecursion = pluckNumber(chartObj.smaxscalerecursion, maxScaleRecursion),
            xMaxScaleRecursion = pluckNumber(chartObj.xmaxscalerecursion, maxScaleRecursion),
            scaleSeparator = getValidValue(chartObj.scaleseparator, ' '),
            sScaleSeparator = getValidValue(chartObj.sscaleseparator, scaleSeparator),
            xScaleSeparator = getValidValue(chartObj.xscaleseparator, scaleSeparator);
            //(chartObj.maxscalerecursion == 0 || maxScaleRecursion == null) ? -1 : maxScaleRecursion,
            if (!maxScaleRecursion || maxScaleRecursion == 0) {
                maxScaleRecursion = -1;
            }

            //create base number formater
            this.baseConf = baseConf = {
                cacheStore: [],
                formatnumber        : pluck(chartObj.formatnumber, chartAPI.formatnumber, csConf.formatnumber),
                formatnumberscale   : pluck(chartObj.formatnumberscale, chartAPI.formatnumberscale, csConf.formatnumberscale),
                defaultnumberscale  : getFirstValue(chartObj.defaultnumberscale, chartAPI.defaultnumberscale, csConf.defaultnumberscale),
                numberscaleunit     : pluck(numberscaleunit, chartAPI.numberscaleunit, csConf.numberscaleunit).concat(),
                numberscalevalue    : pluck(numberscalevalue, chartAPI.numberscalevalue, csConf.numberscalevalue).concat(),
                numberprefix        : getFirstValue(chartObj.numberprefix, chartAPI.numberprefix, csConf.numberprefix),
                numbersuffix        : getFirstValue(chartObj.numbersuffix, chartAPI.numbersuffix, csConf.numbersuffix),
                decimalprecision    : parseInt(chartObj.decimals === AUTOSTRING ? csConf.decimalprecision :
                    pluck(chartObj.decimals, chartObj.decimalprecision, chartAPI.decimals, csConf.decimals, chartAPI.decimalprecision, csConf.decimalprecision), 10),
                forcedecimals       : pluck(chartObj.forcedecimals, chartAPI.forcedecimals, csConf.forcedecimals),
                decimalseparator    : pluck(chartObj.decimalseparator, chartAPI.decimalseparator, csConf.decimalseparator),
                thousandseparator   : pluck(chartObj.thousandseparator, chartAPI.thousandseparator, csConf.thousandseparator),
                thousandseparatorposition : pluck(thousandseparatorposition, chartAPI.thousandseparatorposition, csConf.thousandseparatorposition),
                indecimalseparator  : getFirstValue(chartObj.indecimalseparator, chartAPI.indecimalseparator, csConf.indecimalseparator),
                inthousandseparator : getFirstValue(chartObj.inthousandseparator, chartAPI.inthousandseparator, csConf.inthousandseparator),
                scalerecursively: scaleRecursively,
                maxscalerecursion: maxScaleRecursion,
                scaleseparator: scaleSeparator
            };
            this.Y = [];

            if (isMultyAxis){
                //do all MultyAxis specific calculation
            }
            else {

                // Parameters passed with this function
                paramLabels = {
                    cacheStore: [],
                    formatnumber: baseConf.formatnumber,
                    formatnumberscale: baseConf.formatnumberscale,
                    //defaultnumberscale  : pluck(chartObj.defaultnumberscale, (numberFormatOverrides[chartName] && numberFormatOverrides[chartName].defaultnumberscale)) || numberFormatDefaults.defaultnumberscale,
                    defaultnumberscale: baseConf.defaultnumberscale,
                    numberscaleunit: baseConf.numberscaleunit.concat(),
                    numberscalevalue: baseConf.numberscalevalue.concat(),
                    numberprefix: baseConf.numberprefix,
                    numbersuffix: baseConf.numbersuffix,
                    decimalprecision: baseConf.decimalprecision,
                    forcedecimals: baseConf.forcedecimals,
                    decimalseparator: baseConf.decimalseparator,
                    thousandseparator: baseConf.thousandseparator,
                    thousandseparatorposition: baseConf.thousandseparatorposition,
                    indecimalseparator: baseConf.indecimalseparator,
                    inthousandseparator: baseConf.inthousandseparator,
                    scalerecursively: scaleRecursively,
                    maxscalerecursion: maxScaleRecursion,
                    scaleseparator: scaleSeparator
                };
                // scaleRecursively will use only by Widgets.
                if (!chartAPI.useScaleRecursively || ((paramLabels.numberscalevalue && paramLabels.numberscalevalue.length) !=
                        (paramLabels.numberscaleunit && paramLabels.numberscaleunit.length))) {
                    paramLabels.scalerecursively = scaleRecursively = 0;
                }

                param1 = {
                    cacheStore: [],
                    formatnumber: paramLabels.formatnumber,
                    formatnumberscale: paramLabels.formatnumberscale,
                    defaultnumberscale: paramLabels.defaultnumberscale,
                    numberscaleunit: paramLabels.numberscaleunit.concat(),
                    numberscalevalue: paramLabels.numberscalevalue.concat(),
                    numberprefix: paramLabels.numberprefix,
                    numbersuffix: paramLabels.numbersuffix,
                    decimalprecision: parseInt(pluck(chartObj.yaxisvaluedecimals, paramLabels.decimalprecision, 2)),
                    forcedecimals: pluck(chartObj.forceyaxisvaluedecimals, paramLabels.forcedecimals),
                    decimalseparator: paramLabels.decimalseparator,
                    thousandseparator: paramLabels.thousandseparator,
                    thousandseparatorposition: paramLabels.thousandseparatorposition.concat(),
                    indecimalseparator: paramLabels.indecimalseparator,
                    inthousandseparator: paramLabels.inthousandseparator,
                    scalerecursively: scaleRecursively,
                    maxscalerecursion: maxScaleRecursion,
                    scaleseparator: scaleSeparator
                };


                // Parameters for sScale (secondary axis)
                param2 = {
                    cacheStore: [],
                    formatnumber: pluck(chartObj.sformatnumber, chartAPI.sformatnumber, numberFormatDefaults.sformatnumber),
                    formatnumberscale: pluck(chartObj.sformatnumberscale, chartAPI.sformatnumberscale, numberFormatDefaults.sformatnumberscale),
                    defaultnumberscale: getFirstValue(chartObj.sdefaultnumberscale, chartAPI.sdefaultnumberscale, paramLabels.defaultnumberscale),
                    numberscaleunit: pluck(snumberscaleunit, chartAPI.snumberscaleunit, numberFormatDefaults.snumberscaleunit).concat(),
                    numberscalevalue: pluck(snumberscalevalue, chartAPI.snumberscalevalue, numberFormatDefaults.snumberscalevalue).concat(),
                    numberprefix: getFirstValue(chartObj.snumberprefix, chartAPI.snumberprefix, numberFormatDefaults.snumberprefix),
                    numbersuffix: getFirstValue(chartObj.snumbersuffix, chartAPI.snumbersuffix, numberFormatDefaults.snumbersuffix),
                    decimalprecision: parseInt(pluck(chartObj.syaxisvaluedecimals, chartObj.sdecimals, chartObj.decimals, chartAPI.sdecimals, numberFormatDefaults.sdecimals), 10),
                    forcedecimals: pluck(chartObj.forcesyaxisvaluedecimals, chartObj.sforcedecimals, chartObj.forcedecimals, chartAPI.sforcedecimals, numberFormatDefaults.sforcedecimals),
                    decimalseparator: pluck(chartObj.decimalseparator, chartAPI.decimalseparator, numberFormatDefaults.decimalseparator),
                    thousandseparator: pluck(chartObj.thousandseparator, chartAPI.thousandseparator, numberFormatDefaults.thousandseparator),
                    thousandseparatorposition: paramLabels.thousandseparatorposition.concat(),
                    indecimalseparator: pluck(chartObj.indecimalseparator, chartAPI.indecimalseparator, numberFormatDefaults.indecimalseparator),
                    inthousandseparator: pluck(chartObj.inthousandseparator, chartAPI.inthousandseparator, numberFormatDefaults.inthousandseparator),
                    scalerecursively: sScaleRecursively,
                    maxscalerecursion: sMaxScaleRecursion,
                    scaleseparator: sScaleSeparator
                };

                // MultiAxisLine chart secondary yAxis numberFormatter attribute mapping wrt primary yAxis
//                if (/^(multiaxisline)$/.test(chartName)) {
//                    param2.formatnumber = pluck(chartObj.sformatnumber, chartObj.formatnumber, chartAPI.sformatnumber, numberFormatDefaults.sformatnumber);
//                    param2.formatnumberscale = pluck(chartObj.sformatnumberscale, chartObj.formatnumberscale, chartAPI.sformatnumberscale, numberFormatDefaults.sformatnumberscale);
//                    param2.defaultnumberscale = getFirstValue(chartObj.sdefaultnumberscale, chartObj.defaultnumberscale, chartAPI.sdefaultnumberscale, paramLabels.defaultnumberscale);
//                    param2.numberprefix = getFirstValue(chartObj.snumberprefix, chartObj.numberprefix, chartAPI.snumberprefix, numberFormatDefaults.snumberprefix);
//                    param2.numbersuffix = getFirstValue(chartObj.snumbersuffix, chartObj.numbersuffix, chartAPI.snumbersuffix, numberFormatDefaults.snumbersuffix);
//                    param2.decimalprecision = parseInt(pluck(chartObj.syaxisvaluedecimals, chartObj.yaxisvaluedecimals, chartObj.sdecimals, chartObj.decimals, chartAPI.sdecimals, numberFormatDefaults.sdecimals), 10);
//                    param2.forcedecimals = pluck(chartObj.forcesyaxisvaluedecimals, chartObj.forceyaxisvaluedecimals, chartObj.sforcedecimals, chartObj.forcedecimals, chartAPI.sforcedecimals, numberFormatDefaults.sforcedecimals);
//                }
                // For secondary yAxis datalabels
                paramLabels2 = extend2({}, param2);
                paramLabels2.decimalprecision = parseInt(pluck(chartObj.sdecimals, chartObj.decimals, chartObj.syaxisvaluedecimals, chartAPI.sdecimals, numberFormatDefaults.sdecimals), 10);
                paramLabels2.forcedecimals = pluck(chartObj.sforcedecimals, chartObj.forcedecimals, chartObj.forcesyaxisvaluedecimals, chartAPI.sforcedecimals, numberFormatDefaults.sforcedecimals);
                //add new cache store
                paramLabels2.cacheStore = [];

                // scaleRecursively will use only by Widgets.
                if (!chartAPI.useScaleRecursively || ((param2.numberscalevalue && param2.numberscalevalue.length) !=
                        (param2.numberscaleunit && param2.numberscaleunit.length))) {
                    param2.scalerecursively = sScaleRecursively = 0;
                }



                

                if (/^(bubble|scatter|selectscatter)$/.test(chartName)) {
                    param1.formatnumber = pluck(chartObj.yformatnumber, param1.formatnumber);
                    param1.formatnumberscale = pluck(chartObj.yformatnumberscale, param1.formatnumberscale);
                    param1.defaultnumberscale = getFirstValue(chartObj.ydefaultnumberscale, param1.defaultnumberscale);
                    param1.numberscaleunit = pluck(ynumberscaleunit, param1.numberscaleunit);
                    param1.numberscalevalue = pluck(ynumberscalevalue, param1.numberscalevalue);
                    param1.numberprefix = pluck(chartObj.ynumberprefix, param1.numberprefix);
                    param1.numbersuffix = pluck(chartObj.ynumbersuffix, param1.numbersuffix);
                    //
                    paramLabels.formatnumber = pluck(chartObj.yformatnumber, paramLabels.formatnumber);
                    paramLabels.formatnumberscale = pluck(chartObj.yformatnumberscale, paramLabels.formatnumberscale);
                    paramLabels.defaultnumberscale = getFirstValue(chartObj.ydefaultnumberscale, paramLabels.defaultnumberscale);
                    paramLabels.numberscaleunit = pluck(chartObj.ynumberscaleunit, paramLabels.numberscaleunit.concat());
                    paramLabels.numberscalevalue = pluck(chartObj.ynumberscalevalue, paramLabels.numberscalevalue.concat());
                    paramLabels.numberprefix = pluck(chartObj.ynumberprefix, paramLabels.numberprefix);
                    paramLabels.numbersuffix = pluck(chartObj.ynumbersuffix, paramLabels.numbersuffix);
                }

                // Adding special attributes for secondary yAxis
                if (/^(mscombidy2d|mscombidy3d)$/.test(chartName)) {
                    param2.formatnumberscale = pluckNumber(chartObj.sformatnumberscale, ONESTRING);
                }

                // Fix for some chart decimals default value different
                if (/^(pie2d|pie3d|doughnut2d|doughnut3d|marimekko|pareto2d|pareto3d)$/.test(chartName)) {
                    paramLabels.decimalprecision = pluck(chartObj.decimals, TWOSTRING);
                }

                // Adjusting numberScaleValue and numberScaleUnit array to be use in
                // the calculation of scaleRecursively
                if (scaleRecursively) {
                    paramLabels.numberscalevalue.push(1);
                    paramLabels.numberscaleunit.unshift(paramLabels.defaultnumberscale);

                    param1.numberscalevalue.push(1);
                    param1.numberscaleunit.unshift(param1.defaultnumberscale);
                }
                if (sScaleRecursively) {
                    param2.numberscalevalue.push(1);
                    param2.numberscaleunit.unshift(param2.defaultnumberscale);

                    paramLabels2.numberscalevalue.push(1);
                    paramLabels2.numberscaleunit.unshift(paramLabels2.defaultnumberscale);
                }

               this.Y[0] = {
                   yAxisLabelConf: param1,
                   dataLabelConf: paramLabels
               };
               this.Y[1] = {
                   yAxisLabelConf: param2,
                   dataLabelConf: paramLabels2
               } ;
               //for backword compatibility issue
               

               this.paramLabels = paramLabels;
               this.param1 = param1;
               this.param2 = param2;
               this.paramLabels2 = paramLabels2;
            }

            


            //xAxis Label formatter for scatter type X-y plot charts
             // Parameters for xScale
            this.paramX = {
                cacheStore: [],
                formatnumber: pluck(chartObj.xformatnumber, baseConf.formatnumber),
                formatnumberscale: pluck(chartObj.xformatnumberscale, baseConf.formatnumberscale),
                defaultnumberscale: getFirstValue(chartObj.xdefaultnumberscale, baseConf.defaultnumberscale),
                numberscaleunit: pluck(xnumberscaleunit, baseConf.numberscaleunit.concat()),
                numberscalevalue: pluck(xnumberscalevalue, baseConf.numberscalevalue.concat()),
                numberprefix: pluck(chartObj.xnumberprefix, baseConf.numberprefix),
                numbersuffix: pluck(chartObj.xnumbersuffix, baseConf.numbersuffix),
                decimalprecision: parseInt(pluck(chartObj.xaxisvaluedecimals, chartObj.xaxisvaluesdecimals, baseConf.decimalprecision, 2), 10),
                forcedecimals: pluck(chartObj.forcexaxisvaluedecimals, 0),
                decimalseparator: baseConf.decimalseparator,
                thousandseparator: baseConf.thousandseparator,
                thousandseparatorposition: baseConf.thousandseparatorposition.concat(),
                indecimalseparator: baseConf.indecimalseparator,
                inthousandseparator: baseConf.inthousandseparator,
                scalerecursively: xScaleRecursively,
                maxscalerecursion: xMaxScaleRecursion,
                scaleseparator: xScaleSeparator
            };
            // scaleRecursively will use only by Widgets.
            if (!chartAPI.useScaleRecursively || ((this.paramX.numberscalevalue && this.paramX.numberscalevalue.length) !=
                    (this.paramX.numberscaleunit && this.paramX.numberscaleunit.length))) {
                this.paramX.scalerecursively = xScaleRecursively = 0;
            }

            if (xScaleRecursively) {
                this.paramX.numberscalevalue.push(1);
                this.paramX.numberscaleunit.unshift(this.paramX.defaultnumberscale);
            }

            this.paramScale = {
                cacheStore: [],
                formatnumber: pluck(chartObj.tickformatnumber, baseConf.formatnumber),
                formatnumberscale: pluck(chartObj.tickformatnumberscale, baseConf.formatnumberscale),
                defaultnumberscale: getFirstValue(chartObj.tickdefaultnumberscale, baseConf.defaultnumberscale),
                numberscaleunit: pluck(ticknumberscaleunit, baseConf.numberscaleunit.concat()),
                numberscalevalue: pluck(ticknumberscalevalue, baseConf.numberscalevalue.concat()),
                numberprefix: pluck(chartObj.ticknumberprefix, baseConf.numberprefix),
                numbersuffix: pluck(chartObj.ticknumbersuffix, baseConf.numbersuffix),
                decimalprecision: parseInt(pluck(chartObj.tickvaluedecimals, baseConf.decimalprecision, TWOSTRING)),
                forcedecimals: pluck(chartObj.forcetickvaluedecimals, baseConf.forcedecimals, 0),
                decimalseparator: baseConf.decimalseparator,
                thousandseparator: baseConf.thousandseparator,
                thousandseparatorposition: baseConf.thousandseparatorposition.concat(),
                indecimalseparator: baseConf.indecimalseparator,
                inthousandseparator: baseConf.inthousandseparator,
                scalerecursively: scaleRecursively,
                maxscalerecursion: maxScaleRecursion,
                scaleseparator: scaleSeparator
            };

            // Adjusting numberScaleValue and numberScaleUnit array to be use in
            // the calculation of scaleRecursively
            if (scaleRecursively) {
                this.paramScale.numberscalevalue.push(1);
                this.paramScale.numberscaleunit.unshift(this.paramScale.defaultnumberscale);
            }

            //dateTime parser conf
            this.timeConf = {
                inputDateFormat: pluck(chartObj.inputdateformat, chartObj.dateformat),
                outputDateFormat: pluck(chartObj.outputdateformat, chartObj.inputdateformat, chartObj.dateformat),
                days: ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'],
                months: ['January', 'February', 'March', 'April', 'May', 'June', 'July', 'August', 'September', 'October', 'November', 'December'],
                daySuffix: ['st', 'nd', 'rd', 'th', 'th', 'th', 'th', 'th', 'th', 'th', 'th', 'th', 'th', 'th', 'th', 'th', 'th', 'th', 'th', 'th', 'st', 'nd', 'rd', 'th', 'th', 'th', 'th', 'th', 'th', 'th', 'st']
            };
        };

        NumberFormatter.prototype = {
            cleaneValueCacheStore: {},
            percentStrCacheStore: {},
            //delete all object ref and cache store
            dispose: function () {
                var Numberformatter = this,
                        l = (Numberformatter.Y && Numberformatter.Y.length) || 0,
                        i = 0;
                //delete y axis params
                if (Numberformatter.Y){
                   delete Numberformatter.Y;
                }
                //delete cleaneValueCacheStore
                if (Numberformatter.cleaneValueCacheStore){
                   delete Numberformatter.cleaneValueCacheStore;
                }
                //delete cleaneValueCacheStore
                if (Numberformatter.percentStrCacheStore){
                   delete Numberformatter.percentStrCacheStore;
                }
                //delete baseConf
                if (Numberformatter.baseConf){
                   delete Numberformatter.baseConf;
                }
                //delete timeConf
                if (Numberformatter.timeConf){
                   delete Numberformatter.timeConf;
                }
                //delete paramX
                if (Numberformatter.paramX){
                   delete Numberformatter.paramX;
                }
                //delete paramScale
                if (Numberformatter.paramScale){
                   delete Numberformatter.paramScale;
                }
            },
            parseMLAxisConf: function (axisObj, index){
                var baseConf = this.baseConf,
                    csConf = this.csConf,
                    chartAPI = this.chartAPI,
                    scaleRecursively = pluckNumber(axisObj.scalerecursively, baseConf.scalerecursively),
                    maxScaleRecursion = pluckNumber(axisObj.maxscalerecursion, baseConf.maxscalerecursion),
                    scaleSeparator = getValidValue(axisObj.scaleseparator, baseConf.scaleseparator),
                    paramLabels,
                    numberscaleunit,
                    numberscalevalue,
                    param,
                    thousandseparatorposition,
                    length,
                    value,
                    lastValue;

                index = pluckNumber(index, this.Y.length);

                 if (getValidValue(axisObj.numberscaleunit)) {
                    numberscaleunit = axisObj.numberscaleunit.split(COMMASTRING);
                }
                // Converting user given numberScaleValue into array
                if (getValidValue(axisObj.numberscalevalue)) {
                    numberscalevalue = axisObj.numberscalevalue.split(COMMASTRING);
                }
                if (!maxScaleRecursion) {
                    maxScaleRecursion = -1;
                }
                // Converting user given numberScaleValue into array
                if(getValidValue(axisObj.thousandseparatorposition)) {
                    thousandseparatorposition = axisObj.thousandseparatorposition.split(COMMASTRING);
                    length = thousandseparatorposition.length;
                    value;
                    lastValue = numberFormatDefaults.thousandseparatorposition[0];
                    // Filtering the user given values
                    while (length--) {
                        value = pluckNumber(mathAbs(thousandseparatorposition[length]));
                        if (!value) {
                            value = lastValue;
                        } else {
                            lastValue = value;
                        }
                        thousandseparatorposition[length] = value;
                    }
                }
                // Parameters passed with this function
                paramLabels = {
                    cacheStore: [],
                    formatnumber: pluck(axisObj.formatnumber, baseConf.formatnumber),
                    formatnumberscale: pluck(axisObj.formatnumberscale, baseConf.formatnumberscale),
                    //defaultnumberscale  : pluck(chartObj.defaultnumberscale, (numberFormatOverrides[chartName] && numberFormatOverrides[chartName].defaultnumberscale)) || numberFormatDefaults.defaultnumberscale,
                    defaultnumberscale: getFirstValue(axisObj.defaultnumberscale, baseConf.defaultnumberscale),
                    numberscaleunit: pluck(numberscaleunit, baseConf.numberscaleunit).concat(),
                    numberscalevalue: pluck(numberscalevalue, baseConf.numberscalevalue).concat(),
                    numberprefix: getFirstValue(axisObj.numberprefix, baseConf.numberprefix),
                    numbersuffix: getFirstValue(axisObj.numbersuffix, baseConf.numbersuffix),
                    forcedecimals: pluck(axisObj.forcedecimals, baseConf.forcedecimals),
                    decimalprecision:parseInt(axisObj.decimals === AUTOSTRING ? csConf.decimalprecision :
                                pluck(axisObj.decimals, baseConf.decimalprecision), 10),
                    decimalseparator: pluck(axisObj.decimalseparator, baseConf.decimalseparator),
                    thousandseparator: pluck(axisObj.thousandseparator, baseConf.thousandseparator),
                    thousandseparatorposition:  pluck(thousandseparatorposition, baseConf.thousandseparatorposition),
                    indecimalseparator: getFirstValue(axisObj.indecimalseparator, baseConf.indecimalseparator),
                    inthousandseparator: getFirstValue(axisObj.inthousandseparator, baseConf.inthousandseparator),
                    scalerecursively: scaleRecursively,
                    maxscalerecursion: maxScaleRecursion,
                    scaleseparator: scaleSeparator
                };
                // scaleRecursively will use only by Widgets.
                if (!chartAPI.useScaleRecursively || ((paramLabels.numberscalevalue && paramLabels.numberscalevalue.length) !=
                        (paramLabels.numberscaleunit && paramLabels.numberscaleunit.length))) {
                    paramLabels.scalerecursively = scaleRecursively = 0;
                }

                param = {
                    cacheStore: [],
                    formatnumber: paramLabels.formatnumber,
                    formatnumberscale: paramLabels.formatnumberscale,
                    defaultnumberscale: paramLabels.defaultnumberscale,
                    numberscaleunit: paramLabels.numberscaleunit.concat(),
                    numberscalevalue: paramLabels.numberscalevalue.concat(),
                    numberprefix: paramLabels.numberprefix,
                    numbersuffix: paramLabels.numbersuffix,
                    decimalprecision: parseInt(pluck(axisObj.yaxisvaluedecimals, paramLabels.decimalprecision, 2)),
                    forcedecimals: pluck(axisObj.forceyaxisvaluedecimals, paramLabels.forcedecimals),
                    decimalseparator: paramLabels.decimalseparator,
                    thousandseparator: paramLabels.thousandseparator,
                    thousandseparatorposition: paramLabels.thousandseparatorposition.concat(),
                    indecimalseparator: paramLabels.indecimalseparator,
                    inthousandseparator: paramLabels.inthousandseparator,
                    scalerecursively: scaleRecursively,
                    maxscalerecursion: maxScaleRecursion,
                    scaleseparator: scaleSeparator
                };

                // Adjusting numberScaleValue and numberScaleUnit array to be use in
                // the calculation of scaleRecursively
                if (scaleRecursively) {
                    paramLabels.numberscalevalue.push(1);
                    paramLabels.numberscaleunit.unshift(paramLabels.defaultnumberscale);

                    param.numberscalevalue.push(1);
                    param.numberscaleunit.unshift(param.defaultnumberscale);
                }

                this.Y[index] = {
                    dataLabelConf: paramLabels,
                    yAxisLabelConf: param
                };
            },
            percentValue : function (num) {//don't use 2'nd argument it may conflict with yAxis()'s 2'nd arg
                var rtn = this.percentStrCacheStore[num],
                        precision;
                if (rtn === undefined) {
                    precision = isNaN(this.paramLabels.decimalprecision) ? "2" : this.paramLabels.decimalprecision;
                    rtn = this.percentStrCacheStore[num] = formatCommas (formatDecimals(num, precision, this.paramLabels.forcedecimals),
                    this.paramLabels.decimalseparator,
                    this.paramLabels.thousandseparator, this.paramLabels.thousandseparatorposition) + '%';
                }
                return rtn;
            },
            // configuration of getCleanValue will be same across all dataset/axis
            getCleanValue: function (numStr, abs) {
                var rtn = this.cleaneValueCacheStore[numStr],
                        num;
                if (rtn === undefined){
                    num = convertNumberSeps(numStr, this.baseConf.indecimalseparator,
                    this.baseConf.inthousandseparator);
                    this.cleaneValueCacheStore[numStr] = rtn = isNaN(num) ? null : (abs ? mathAbs(num) : num);
                }
                return rtn;
            },
            dataLabels: function (num, axisIndex) {
                var formatterConf = this.Y[axisIndex] || (axisIndex ? this.Y[1] : this.Y[0]),
                        rtn;
                formatterConf = (formatterConf && formatterConf.dataLabelConf) || this.baseConf;
                rtn = formatterConf.cacheStore[num];
                if (rtn === undefined){
                    rtn = formatterConf.cacheStore[num] = formatNumber(num, formatterConf);
                }
                return rtn;
            },
            yAxis: function (num, axisIndex) {
                var formatterConf = this.Y[axisIndex] || (axisIndex ? this.Y[1] : this.Y[0]),
                        rtn;
                formatterConf = (formatterConf && formatterConf.yAxisLabelConf) || this.baseConf;
                rtn = formatterConf.cacheStore[num];
                if (rtn === undefined){
                    rtn = formatterConf.cacheStore[num] = formatNumber(num, formatterConf);
                }
                return rtn;
            },
            xAxis: function (num) {//don't use 2'nd argument it may conflict with y axis 2'nd arg
                var rtn = this.paramX.cacheStore[num];
                if (rtn === undefined){
                    rtn = this.paramX.cacheStore[num] = formatNumber(num, this.paramX);
                }
                return rtn;
            },
            sYAxis: function (num) {
                var formatterConf = this.Y[1],
                        rtn;
                formatterConf = (formatterConf && formatterConf.yAxisLabelConf) || this.baseConf;
                rtn = formatterConf.cacheStore[num];
                if (rtn === undefined){
                    rtn = formatterConf.cacheStore[num] = formatNumber(num, formatterConf);
                }
                return rtn;
            },
            scale: function (num) {
                var rtn = this.paramScale.cacheStore[num];
                if (rtn === undefined){
                    rtn = this.paramScale.cacheStore[num] = formatNumber(num, this.paramScale);
                }
                return rtn;
            },
            //for time type date
            getCleanTime: function(date){
                var dateObj;
                if (this.timeConf.inputDateFormat && Date.parseExact) {
                    dateObj = Date.parseExact(date, this.timeConf.inputDateFormat);
                }
                //store all dateobj and converted values as index for further fast access

                return dateObj && dateObj.getTime();
            },

            getDateValue: function(date) {
                var DATE;

                date = date && /^dd/.test(this.timeConf.inputDateFormat) &&
                        date.replace(/(\d{1,2})\/(\d{1,2})\/(\d{2,4})/, "$2/$1/$3") || date;

                DATE = new Date(date);
                


                return {
                    ms: DATE.getTime(),
                    date: DATE
                }
            },

            getFormatedDate: function (date, format) {
                var D = typeof date === 'object' && date || this.getDateValue(date).date,
                    timeConf = this.timeConf,
                    output = pluck(format, timeConf.outputDateFormat),
                    year = D.getFullYear(),
                    month = D.getMonth(),
                    day = D.getDate(),
                    nday = D.getDay(),
                    min = D.getMinutes(),
                    sec = D.getSeconds(),
                    hours = D.getHours();

                output.match(/dnl/) && (output = output.replace(/dnl/ig, timeConf.days[nday]));
                output.match(/dns/) && (output = output.replace(/dns/ig, timeConf.days[nday].substr(0, 3)));
                output.match(/dd/) && (output = output.replace(/dd/ig, day));

                output.match(/mnl/) && (output = output.replace(/mnl/ig, timeConf.months[month]));
                output.match(/mns/) && (output = output.replace(/mns/ig, timeConf.months[month].substr(0, 3)));
                output.match(/mm/) && (output = output.replace(/mm/ig, month + 1));

                output.match(/yyyy/) && (output = output.replace(/yyyy/ig, year));
                output.match(/yy/) && (output = output.replace(/yy/ig, ((year % 1000 % 100) + '').replace(/^(\d)$/, '0$1')));

                output.match(/hh12/) && (output = output.replace(/hh12/ig, hours % 12 || 12));
                output.match(/hh/) && (output = output.replace(/hh/ig, hours));

                output.match(/mn/) && (output = output.replace(/mn/ig, min));
                output.match(/ss/) && (output = output.replace(/ss/ig, sec));
                output.match(/ampm/) && (output = output.replace(/ampm/ig, hours < 12 ? 'AM' : 'PM'));
                output.match(/ds/) && (output = output.replace(/ds/ig, timeConf.daySuffix[day]));

                return output;
            }

        };

        NumberFormatter.prototype.constructor = NumberFormatter;

        var formatNumber = function (num, attributes) {
            // We convert the number to a valid number
            // If inDecimalsSeparator and in thousandSeparator is given
            // we replace the thousandSeparator and decimalSeparator with
            // proper valid number format
            //num = convertNumberSeps(num, attributes.indecimalseparator, attributes.inthousandseparator);

            // Change for JS Charts:
            // After initial return from getCleanValue, we get either null or a
            // number. So, we validate presence of null only.
            if (num === null) {
                return; //throw TypeError("Not a Valid number");
            }

            // Failsafe conversion of value to proper type.
            num = Number(num);

            //First, if number is to be scaled, scale it
            //Number in String format
            var strNum = num + BLANK;

            //Number Scale
            var strScale;
            if (attributes.formatnumberscale == 1) {
                strScale = attributes.defaultnumberscale;
            }
            else {
                strScale = BLANK;
            }

            // Fix to show the decimal place
            // if there is more than 2 decimal place in data
            // Finding the decimal place in value
            var valueArr, decimalPlaceLen;
            valueArr = strNum.split('.')[1];
            decimalPlaceLen = valueArr ? valueArr.length : attributes.forcedecimals ? TWOSTRING : BLANK;


            // Whether to add K (thousands) and M (millions) to a number
            if (attributes.formatnumberscale == 1) {
                //Get the formatted scale and number
                var objNum = formatNumberScale (num, attributes.defaultnumberscale, attributes.numberscalevalue, attributes.numberscaleunit, attributes.scalerecursively);
                //Store from return in local primitive variables

                strNum = objNum.value;
                num = objNum.value;
                strScale = objNum.scale;
            }

            if (attributes.scalerecursively && attributes.formatnumberscale != 0) {
                //Store the list of numbers and scales.
                var numList = objNum.value;
                var scaleList = objNum.scale;

                //Based on max scale recursion, we decide the upper index to which we've to iterate
                var upperIndex = ((attributes.maxscalerecursion == -1) ? numList.length : Math.min(numList.length, attributes.maxscalerecursion));
                //Now, based on whether we've to format decimals and commas.
                if (attributes.formatnumber == 1) {
                    //If recursive scaling was applied and format number is true, we need to :
                    //- format comma of all values
                    //- format decimals of just the last value (last based on max recursion or actual).
                    strNum = "";
                    var tempNum , tempStr;
                    for (var i = 0; i < upperIndex; i++) {
                        //Convert all but first number to absolute values.
                        tempNum = (i == 0) ? numList[i] : Math.abs(numList[i]);
                        tempStr = String(tempNum);
                        //If it's the last value, format decimals
                        if (i == upperIndex-1) {
                            tempStr = formatDecimals(tempNum, pluck(attributes.decimalprecision, decimalPlaceLen), attributes.forcedecimals);
                        }
                        //Append to strNum after formatting commas
                        //We separate the scales using scale separator. The last token doesn't append
                        //the scale separator, as we append number suffix after that.
                        strNum = strNum +
                        formatCommas(tempStr, attributes.decimalseparator, attributes.thousandseparator, attributes.thousandseparatorposition) +
                        scaleList[i] + (i<upperIndex-1 ? attributes.scaleseparator : "");
                    }
                } else {
                    strNum = "";
                    for (i = 0; i < upperIndex; i++) {
                        //Convert all but first number to absolute values and append to strNum.
                        //We separate the scales using scale separator. The last token doesn't append
                        //the scale separator, as we append number suffix after that.
                        strNum = strNum+String((i == 0) ? numList[i] : Math.abs(numList[i]))+scaleList[i]+(i<upperIndex-1 ? attributes.scaleseparator : "");
                    }
                }
                //Now, add scale, number prefix and suffix
                //strNum = numberPrefix + strNum + strScale + numberSuffix;
                strNum = (attributes.numberprefix || BLANK) + strNum + (attributes.numbersuffix || BLANK);
                //Clear up
                delete numList;
                delete scaleList;
            } else {
                //Now, if we've to format the decimals and commas
                if (attributes.formatnumber == 1) {
                    //Format decimals
                    strNum = formatDecimals (num, pluck(attributes.decimalprecision, decimalPlaceLen), attributes.forcedecimals);
                    //Format commas now
                    strNum = formatCommas (strNum, attributes.decimalseparator, attributes.thousandseparator, attributes.thousandseparatorposition);
                }

                //Now, add scale, number prefix and suffix
                //strNum = numberPrefix + strNum + strScale + numberSuffix;
                strNum = (attributes.numberprefix || BLANK) + strNum + strScale + (attributes.numbersuffix || BLANK);
            }
            return strNum;
        };

        /**
         * formatNumberScale formats the number as per given scale.
         * For example, if number Scale Values are 1000,1000 and
         * number Scale Units are K,M, this method will divide any
         * value over 1000000 using M and any value over 1000 (less than 1M) using K
         * so as to give abbreviated figures.
         * Number scaling lets you define your own scales for numbers.
         * To clarify further, let's consider an example. Say you're plotting
         * a chart which indicates the time taken by a list of automated
         * processes. Each process in the list can take time ranging from a
         * few seconds to few days. And you've the data for each process in
         * seconds itself. Now, if you were to show all the data on the chart
         * in seconds only, it won't appear too legible. What you can do is
         * build a scale of yours and then specify it to the chart. A scale,
         * in human terms, would look something as under:
         * 60 seconds = 1 minute
         * 60 minute = 1 hr
         * 24 hrs = 1 day
         * 7 days = 1 week
         * First you would need to define the unit of the data which you're providing.
         * Like, in this example, you're providing all data in seconds. So, default
         * number scale would be represented in seconds. You can represent it as under:
         * <graph defaultNumberScale='s' ...>
         * Next, the scale for the chart is defined as under:
         * <graph numberScaleValue='60,60,24,7' numberScaleUnit='min,hr,day,wk' >
         * If you carefully see this and match it with our range, whatever numeric
         * figure was present on the left hand side of the range is put in
         * numberScaleValue and whatever unit was present on the right side of
         * the scale has been put under numberScaleUnit - all separated by commas.
         * @param intNum The number to be scaled.
         * @param defaultNumberScale Scale of the number provided.
         * @param numScaleValues Incremental list of values (divisors) on
         * which the number will be scaled.
         * @param
         */
        function formatNumberScale (intNum, defaultNumberScale, numScaleValues, numScaleUnits, scaleRecursively) {
            //Create an object, which will be returned
            var objRtn = {},
            //Scale Unit to be stored (assume default)
            strScale = defaultNumberScale,
            i = 0,
            numScaleValue,
            THOUSAND = 1000;
            //Array of values & scales to be returned.
            var arrValues = [];
            var arrScales = [];
            if (scaleRecursively) {
                for (i = 0; i < numScaleValues.length; i++) {
                    // Garbage handling, if comma  separated value of
                    // numberScaleValues is not a number or 0, we use 1000 as the value
                    numScaleValue = pluckNumber(numScaleValues[i]) || THOUSAND;
                    if (Math.abs(Number(intNum)) >= numScaleValue &&  i < numScaleValues.length - 1) {
                        //Carry over from division
                        var carry = intNum % numScaleValue;
                        //Deduct carry over and then divide.
                        intNum = (intNum-carry) / numScaleValue;
                        //Push to return array if carry is non 0
                        if (carry != 0) {
                            arrValues.push(carry);
                            arrScales.push(numScaleUnits[i]);
                        }
                    } else {
                        //This loop executes for first token value (l to r) during recusrive scaling
                        //Or, if original number < first number scale value.
                        arrValues.push(intNum);
                        arrScales.push(numScaleUnits[i]);
                        break;
                    }
                }
                //Reverse the arrays - So that lead value stays at 0 index.
                arrValues.reverse();
                arrScales.reverse();
                objRtn.value = arrValues;
                objRtn.scale = arrScales;
            } else {
                //If the scale unit or values have something fed in them
                //we manipulate the scales.
                if (numScaleValues.length === numScaleUnits.length) {
                    for (i = 0; i < numScaleValues.length; i ++) {
                        // Garbage handling, if comma  separated value of
                        // numberScaleValues is not a number or 0, we use 1000 as the value
                        numScaleValue = pluckNumber(numScaleValues[i]) || THOUSAND;
                        if (numScaleValue && Math.abs (Number (intNum)) >= numScaleValue) {
                            strScale = numScaleUnits[i] || BLANK;
                            intNum = Number (intNum) / numScaleValue;
                        }
                        else {
                            break;
                        }
                    }
                }
                //Set the values as properties of objRtn
                objRtn.value = intNum;
                objRtn.scale = strScale;
            }
            return objRtn;
        }
        /**
        * parseNumberScale method checks whether we've been provided
        * with number scales. If yes, we parse them and store them in
        * local containers.
        *	@return	Nothing.

        function parseNumberScale(numberScaleValues, numberScaleUnits) {
            var bNumberScaleDefined, scaleRecursively;
            //Check if either has been defined
            if (numberScaleValues.length == 0 || numberScaleUnits.length == 0) {
                //Set flag to false
                bNumberScaleDefined = false;
                scaleRecursively = false;
            } else {
                //Set flag to true
                bNumberScaleDefined = true;
                //Split the data into arrays
                attributes.numberscalevalues = new Array();
                attributes.numberscaleunits = new Array();
                //Parse the number scale value
                attributes.numberscalevalues = numberScaleValues.split(",");
                //Convert all number scale values to numbers as they're
                //currently in string format.
                var i;
                for (i=0; i<attributes.numberscalevalues.length; i++) {
                    attributes.numberscalevalues[i] = Number(attributes.numberscalevalues[i]);
                    //If any of numbers are NaN, set defined to false
                    if (isNaN(attributes.numberscalevalues[i])) {
                        bNumberScaleDefined = false;
                        scaleRecursively = false;
                    }
                }
                //Parse the number scale unit
                attributes.numberscaleunits = numberScaleUnits.split(",");
                //If the length of two arrays do not match, set defined to false.
                if (attributes.numberscaleunits.length != attributes.numberscalevalues.length) {
                    bNumberScaleDefined = false;
                    scaleRecursively = false;
                }
                //Push the default scales at start - Value as 1 (universal divisor)
                attributes.numberscalevalues.push(1);
                attributes.numberscaleunits.unshift(this.defaultNumberScale);
                //If number scale is not defined, clear up
                if (!bNumberScaleDefined) {
                    delete attributes.numberscaleunits;
                    delete attributes.numberscalevalues;
                }
            }
        }*/

        /**
         * formatDecimals method formats the decimal places of a number.
         * Requires the following to be defined:
         * params.decimalSeparator
         * params.thousandSeparator
         * @param intNum Number on which we've to work.
         * @param decimalPrecision Number of decimal places to which we've
         * to format the number to.
         * @param forceDecimals Boolean value indicating whether to add decimal
         * padding to numbers which are falling as whole
         * numbers?
         * @return A number with the required number of decimal places
         * in String format. If we return as Number, Flash will remove
         * our decimal padding or un-wanted decimals.
         */
        function formatDecimals (intNum, decimalPrecision, forceDecimals) {
            var tenToPower, strRounded;

            // if negative decimal precision is sent, we set it to 0, as per
            // FusionCharts Policy
            if(decimalPrecision <= 0) {
                return String(mathRound (intNum));
            //decimalPrecision = 0;
            }
            //If no decimal places are needed, just round the number and return
            if (isNaN(decimalPrecision)) {
                intNum = intNum.toString();
                if (intNum.length > 12 && intNum.indexOf(DECIMALSTRING) != -1) {
                    decimalPrecision = 12 - intNum.split(DECIMALSTRING)[0].length;
                    tenToPower = mathPow (10, decimalPrecision);
                    strRounded = String (mathRound (intNum * tenToPower) / tenToPower);
                    intNum = strRounded;
                }
                return intNum;
            //return mathRound (intNum) + BLANKSTRING;
            }
            //Round the number to specified decimal places
            //e.g. 12.3456 to 3 digits (12.346)
            //Step 1: Multiply by 10^decimalPrecision - 12345.6
            //Step 2: Round it - i.e., 12346
            //Step 3: Divide by 10^decimalPrecision - 12.346
            tenToPower = mathPow (10, decimalPrecision);
            strRounded = String (mathRound (intNum * tenToPower) / tenToPower);

            //Now, strRounded might have a whole number or a number with required
            //decimal places. Our next job is to check if we've to force Decimals.
            //If yes, we add decimal padding by adding 0s at the end.
            if (forceDecimals == 1) {
                //Add a decimal point if missing
                //At least one decimal place is required (as we split later on .)
                //10 -> 10.0
                if (strRounded.indexOf (DECIMALSTRING) == - 1) {
                    strRounded += ".0";
                }
                //Finally, we start add padding of 0s.
                //Split the number into two parts - pre & post decimal
                var parts = strRounded.split (DECIMALSTRING);
                //Get the numbers falling right of the decimal
                //Compare digits in right half of string to digits wanted
                var paddingNeeded = decimalPrecision - parts [1].length;
                //Number of zeros to add
                for (var i = 1; i <= paddingNeeded; i ++) {
                    //Add them
                    strRounded += ZEROSTRING;
                }
            }
            return (strRounded);
        }

        /**
         * formatCommas method adds proper commas to a number in blocks of 3
         * i.e., 123456 would be formatted as 123,456
         * @param strNum The number to be formatted (as string).
         * Why are numbers taken in string format?
         * Here, we are asking for numbers in string format
         * to preserve the leading and padding 0s of decimals
         * Like as in -20.00, if number is just passed as number,
         * Flash automatically reduces it to -20. But, we've to
         * make sure that we do not disturb the original number.
         * @return Formatted number with commas.
         */
        function formatCommas (strNum, decimalseparator, thousandseparator, thSepPos) {

            //intNum would represent the number in number format
            var intNum = Number (strNum);

            //If the number is invalid, return an empty value
            if (isNaN (intNum)){
                return BLANK;
            }
            var strDecimalPart = BLANK;
            var boolIsNegative = false;
            var strNumberFloor = BLANK;
            var formattedNumber = BLANK;
            var startPos = 0;
            var endPos = 0;
            //Define startPos and endPos
            startPos = 0;
            endPos = strNum.length;

            //Extract the decimal part
            if (strNum.indexOf (DECIMALSTRING) != - 1) {
                strDecimalPart = strNum.substring (strNum.indexOf (DECIMALSTRING) + 1, strNum.length);
                endPos = strNum.indexOf (DECIMALSTRING);
            }
            //Now, if the number is negative, get the value into the flag
            if (intNum < 0) {
                boolIsNegative = true;
                startPos = 1;
            }
            //Now, extract the floor of the number
            strNumberFloor = strNum.substring (startPos, endPos);

            var strNumberLen = strNumberFloor.length,
            sepPosLen = thSepPos.length - 1,
            sepDigit = thSepPos[sepPosLen];
            if (strNumberLen < sepDigit) {
                formattedNumber = strNumberFloor;
            } else {
                while (strNumberLen >= sepDigit) {
                    formattedNumber = (strNumberLen-sepDigit ?  thousandseparator : BLANK) +
                    strNumberFloor.substr( strNumberLen-sepDigit, sepDigit) + formattedNumber;
                    strNumberLen -= sepDigit;
                    sepDigit = (sepPosLen-=1) <= 0 ? thSepPos[0] : thSepPos[sepPosLen];
                    if (strNumberLen < sepDigit) {
                        formattedNumber =  strNumberFloor.substring(strNumberLen, 0) + formattedNumber;
                    }
                }
            }

            // Now, append the decimal part back
            if (strDecimalPart != BLANK) {
                formattedNumber = formattedNumber + decimalseparator + strDecimalPart;
            }
            //Now, if neg num
            if (boolIsNegative == true) {
                formattedNumber = "-" + formattedNumber;
            }

            //Return
            return formattedNumber;
        }

        /**
         * convertNumberSeps method helps us convert the separator (thousands and decimal)
         * character from the user specified input separator characters to normal numeric
         * values that Flash can handle. In some european countries, commas are used as
         * decimal separators and dots as thousand separators. In XML, if the user specifies
         * such values, it will give a error while converting to number. So, we accept the
         * input decimal and thousand separator from user, so thatwe can covert it accordingly
         * into the required format.
         * If the number is still not a valid number after converting the characters, we log
         * the error and return 0.
         * @param num Number in string format containing user defined separator characters.
         * @return Number in numeric format.
         */
        // convertNumberSeps function modified on [12-04-2011] to fix the issue [FCXTCOMMON-37]
        

        function convertNumberSeps (num, indecimalseparator, inthousandseparator) {
            // convert the given number to string
            num = num + BLANK;
            if (getValidValue(inthousandseparator)) {
                inthousandseparator = inthousandseparator.replace(/(\W)/ig, '\\$1')
                // Replace the inthousandseparator value with decimal to perform numeric operations
                var regExp = new RegExp(inthousandseparator, 'g');
                num = num.toString().replace(regExp, BLANK);
            }
            // Replace the indecimalseparator value with decimal to perform numeric operations
            if (getValidValue(indecimalseparator)) {
                num = num.replace(indecimalseparator, DECIMALSTRING);
            }

            // parseFloat is used here instead of Number so that parseFloat()'s
            // returning of NaN on blank string can be utilized.
            return !isNaN(num = parseFloat(num)) && isFinite(num) ? num : NaN;
        }
        /*
        function convertNumberSeps (num, indecimalseparator, inthousandseparator) {
            // Replace the indecimalseparator value with decimal to perform numeric operations
            num = indecimalseparator !== BLANKSTRING ?
            num.toString().replace(indecimalseparator, DECIMALSTRING) : num;

            if (inthousandseparator && inthousandseparator.toString) {
                inthousandseparator = inthousandseparator.toString().replace(/(\W)/ig, '\\$1')
            }

            // Replace the inthousandseparator value with decimal to perform numeric operations
            var re = new RegExp(inthousandseparator, "g");
            num = inthousandseparator !== BLANKSTRING ?
            num.toString().replace(re, BLANKSTRING) : num;

            // old code: intNum = !strNum && strNum !== false && strNum !== 0 ?
            //NaN : Number(strNum);

            return !isNaN(num = parseFloat(num)) && isFinite(num) ? num : NaN;
        }
         */
        return NumberFormatter;

    })(),


    ///////// *********Linear Axis Min Max module****** ////////////


    getAxisLimits =(function () {

        var getDivisibleRange =  function  (yMin, yMax, numDivLines, interval, interceptRange)
        {
            //Get the range division for current yMin, yMax and numDivLines
            var range = Math.abs (yMax - yMin);
            var rangeDiv = range / (numDivLines + 1);
            //Now, the range is not divisible
            if ( ! isRangeDivisible (range, numDivLines, interval))
            {
                //We need to get new rangeDiv which can be equally distributed.
                //If intercept range is set to true
                if (interceptRange)
                {
                    //Re-adjust interval so that gap is not much (conditional)
                    //Condition check limit based on value
                    var checkLimit = (interval > 1) ? 2 : 0.5;
                    if ((Number (rangeDiv) / Number (interval)) < checkLimit)
                    {
                        //Decrease power of ten to get closer rounding
                        interval = interval / 10;
                    }
                }
                //Adjust range division based on new interval
                rangeDiv = (Math.floor (rangeDiv / interval) + 1) * interval;
                //Get new range
                range = rangeDiv * (numDivLines + 1);
            }
            //Return range
            return range;
        },

        /**
         * isRangeDivisible method helps us judge whether the given range is
         * perfectly divisible for specified y-interval, numDivLines, yMin and yMax.
         * To check that, we divide the given range into (numDivLines+1) section.
         * If the decimal places of this division value is <= that of interval,
         * that means, this range fits in our purpose. We return a boolean value
         * accordingly.
         *	@param	range		Range of y-axis (Max - Min). Absolute value
         *	@param	numDivLines	Number of div lines to be plotted.
         *	@param	interval	Y-axis Interval (power of ten).
         *	@return			Boolean value indicating whether this range is divisible
         *						by the given number of div lines.
         */
        isRangeDivisible = function (range, numDivLines, interval)
        {
            //Get range division
            var rangeDiv = range / (numDivLines + 1);
            //Now, if the decimal places of rangeDiv and interval do not match,
            //it's not divisible, else it's divisible
            if (numDecimals (rangeDiv) > numDecimals (interval))
            {
                return false;
            } else {
                return true;
            }
        },

        /**
         * numDecimals method returns the number of decimal places provided
         * in the given number.
         *	@param	num	Number for which we've to find the decimal places.
         *	@returns	Number of decimal places found.
         */
        numDecimals = function (num) {
            //Absolute value (to avoid floor disparity for negative num)
            num = Math.abs(num);
            //Convert to string and find the position of dot.
            var strNum = String(num);
            var decimals = 0;
            var dotPos = strNum.indexOf(DECIMALSTRING);
            //See if the number has decimal at all
            if (dotPos!=-1){
                //Find the position of decimal.
                decimals = strNum.length - dotPos - 1;
            }
            //Return the number of decimal digits
            return decimals;
        };



        /**
         * getAxisLimits method helps calculate the axis limits based
         * on the given maximum and minimum value.
         *       @param	maxValue		Maximum numerical value present in data
         *	@param	minValue		Minimum numerical value present in data
         *	@param	stopMaxAtZero	Flag indicating whether maximum value can
         *							be less than 0.
         *	@param	setMinAsZero	Whether to set the lower limit as 0 or a greater
         *	appropriate value (when dealing with positive numbers)
         */

        return function  (maxValue, minValue, yAxisMaxValue, yAxisMinValue, stopMaxAtZero, setMinAsZero, numDivLines, adjustDiv) {
            //write the variable which are added as an param in as object
            var yMaxGiven, yMinGiven, yMax, yMin, range, interval;
            //First check if both maxValue and minValue are proper numbers.
            //Else, set defaults as 90,0
            maxValue = (isNaN (maxValue) == true || maxValue == undefined) ? 0.1 : maxValue;
            minValue = (isNaN (minValue) == true || minValue == undefined) ? 0 : minValue;
            //Or, if only 0 data is supplied
            if ((maxValue == minValue) && (maxValue == 0))
            {
                maxValue = 0.1;
            }
            //Defaults for stopMaxAtZero and setMinAsZero
            stopMaxAtZero = typeof stopMaxAtZero === undefined ? true : stopMaxAtZero;
            setMinAsZero = typeof setMinAsZero === undefined ? true : setMinAsZero;
            //Get the maximum power of 10 that is applicable to maxvalue
            //The Number = 10 to the power maxPowerOfTen + x (where x is another number)
            //For e.g., in 99 the maxPowerOfTen will be 1 = 10^1 + 89
            //And for 102, it will be 2 = 10^2 + 2
            var maxPowerOfTen = Math.floor (Math.log (Math.abs (maxValue)) / Math.LN10);
            //Get the minimum power of 10 that is applicable to maxvalue
            var minPowerOfTen = Math.floor (Math.log (Math.abs (minValue)) / Math.LN10);
            //Find which powerOfTen (the max power or the min power) is bigger
            //It is this which will be multiplied to get the y-interval
            var powerOfTen = Math.max (minPowerOfTen, maxPowerOfTen);
            var y_interval = Math.pow (10, powerOfTen);
            //For accomodating smaller range values (so that scale doesn't represent too large an interval
            if (Math.abs (maxValue) / y_interval < 2 && Math.abs (minValue) / y_interval < 2)
            {
                powerOfTen --;
                y_interval = Math.pow (10, powerOfTen);
            }
            //If the y_interval of min and max is way more than that of range.
            //We need to reset the y-interval as per range
            var rangePowerOfTen = Math.floor (Math.log (maxValue - minValue) / Math.LN10);
            var rangeInterval = Math.pow (10, rangePowerOfTen);
            //Now, if rangeInterval is 10 times less than y_interval, we need to re-set
            //the limits, as the range is too less to adjust the axis for max,min.
            //We do this only if range is greater than 0 (in case of 1 data on chart).
            if (((maxValue - minValue) > 0) && ((y_interval / rangeInterval) >= 10))
            {
                y_interval = rangeInterval;
                powerOfTen = rangePowerOfTen;
            }
            //Calculate the y-axis upper limit
            var y_topBound = (Math.floor (maxValue / y_interval) + 1) * y_interval;
            //Calculate the y-axis lower limit
            var y_lowerBound;
            //If the min value is less than 0
            if (minValue < 0)
            {
                //Then calculate by multiplying negative numbers with y-axis interval
                y_lowerBound = - 1 * ((Math.floor (Math.abs (minValue / y_interval)) + 1) * y_interval);
            } else {
                //Else, simply set it to 0.
                if (setMinAsZero)
                {
                    y_lowerBound = 0;
                }
                else {
                    y_lowerBound = Math.floor (Math.abs (minValue / y_interval) - 1) * y_interval;
                    //Now, if minValue>=0, we keep x_lowerBound to 0 - as for values like minValue 2
                    //lower bound goes negative, which is not required.
                    y_lowerBound = (y_lowerBound < 0) ?0 : y_lowerBound;
                }
            }
            //MaxValue cannot be less than 0 if stopMaxAtZero is set to true
            if (stopMaxAtZero && maxValue <= 0) {
                y_topBound = 0;
            }
            //Now, we need to make a check as to whether the user has provided an upper limit
            //and lower limit.
            if (yAxisMaxValue == null || yAxisMaxValue == undefined || yAxisMaxValue == BLANK)
            {
                yMaxGiven = false;
            } else {
                yMaxGiven = true;
            }
            if (yAxisMinValue == null || yAxisMinValue == undefined || yAxisMinValue == BLANK || isNaN(Number (yAxisMinValue))) {
                yMinGiven = false;
            } else {
                yMinGiven = true;
            }
            //If he has provided it and it is valid, we leave it as the upper limit
            //Else, we enforced the value calculate by us as the upper limit.
            if (yMaxGiven == false || (yMaxGiven == true && Number (yAxisMaxValue) < maxValue && maxValue - Number (yAxisMaxValue) > EPSILON))
            {
                yMax = y_topBound;
            } else {
                yMax = Number (yAxisMaxValue);
            }
            //Now, we do the same for y-axis lower limit
            if (yMinGiven == false || (yMinGiven == true && Number (yAxisMinValue) > minValue && Number(yAxisMinValue) - minValue > EPSILON))
            {
                yMin = y_lowerBound;
            } else {
                yMin = Number (yAxisMinValue);
            }
            //Store axis range
            range = Math.abs (yMax - yMin);
            //Store interval
            interval = y_interval;
            //}




            /**
             * calcDivs method calculates the best div line interval for the given/calculated
             * yMin, yMax, specified numDivLines and adjustDiv.
             * We re-set the y axis min and max value, if both were calculated by our
             * us, so that we get a best value according to numDivLines. The idea is to have equal
             * intervals on the axis, based on numDivLines specified. We do so, only if both yMin and
             * yMax have been calculated as per our values. Else, we adjust the numDiv Lines.
             */
            //function calcDivs ()
            //{
            /**
             * There can be four cases of yMin, yMax.
             * 1. User doesn't specify either. (our program calculates it).
             * 2. User specifies both in XML. (which our program still validates)
             * 3. User specifies only yMin. (we provide missing data)
             * 4. User specifies only yMax. (we provide missing data)
             *
             * Apart from this, the user can specify numDivLines (which if not specified takes a
             * default value of 4). Also, the user can specify adjustDiv (which can be 1 or 0).
             * adjustDiv works in all four cases (1,2,3,4).
             * Case 1 is modified to occur as under now: User doesn't specify either yMin or yMax
             * and adjustDiv is set to true (by default). If the user doesn't specify either yMin or
             * yMax, but adjustDiv is set to false, it doesn't appear as Case 1. However, if adjustDiv
             * is set to true and yMin,yMax is automatically calculated by FusionCharts, we adjust the
             * calculated yMin,yMax so that the given number of div lines can be well adjusted within.
             *
             * In case 2,3,4, we adjust numDivLines so that they space up equally based on the interval
             * and decimals required.
             *
             * So, the difference between Case 1 and Case 2,3,4 is that in Case 1, we adjust limits
             * to accomodate specified number of div lines. In Case 2,3,4, we adjust numDivLines to
             * accomodate within the given limits (y-axis range).
             *
             * numDivLines is always our primary focus when calculating them in all cases. In Case 1,
             * it's kept constant as center of calculation. In Case 2, it's modified to get a best
             * value.
             *
             * Now, for case 1, we can have three sub cases:
             * 1.1. yMax, yMin >=0
             * 1.2. yMin, yMax <=0
             * 1.3. yMax > 0 and yMin <0.
             * Case 1.1 and 1.2 are simple, as we just need to adjust the range between two positive
             * or two negative numbers such that the range can be equally divided into (numDivLines+1)
             * division.
             * Case 1.3 is tricky, as here, we additionally need to make sure that 0 plane is included
             * as a division.
             * We use two different methods to solved Case 1.1,1.2 and Case 1.3.
             * Note that in all Cases (1.1, 1.2 & 1.3), we adjust the auto-calculated yMax and yMin
             * to get best div line value. We do NOT adjust numDivLines here.
             */
            //Check condition for case 1 first - limits not specified and adjustDiv is true
            if (yMinGiven == false && yMaxGiven == false && adjustDiv == true)
            {
                //Means neither chart max value nor min value has been specified and adjustDiv is true
                //Now, if it's case 1.3 (yMax > 0 & yMin <0)
                if (yMax > 0 && yMin < 0)
                {
                    //Case 1.3
                    /**
                     * Here, in this case, we start by generating the best fit range
                     * for the given yMin, yMax, numDivLines and interval. We generate
                     * range by adding sequential increments (rangeDiv * (ND+1) * interval).
                     * Interval has been adjusted to smaller interval for larger values.
                     * Now, for each divisible range generated by the program, we adjust the
                     * yMin and yMax to check if 0 can land as a division in between them on
                     * a proper distance.
                     * We divide the y-axis range into two parts - small arm and big arm.
                     * Say y-axis range is from 1 to -5. So, small arm is 1 and big arm is -5.
                     * Or, if its from 16 to -3, small arm is -3 and big arm is 16.
                     * Now, we try and get a value for extended small arm, which is multiple
                     * of rangeDiv. Say chart min,max is 16,-3. So range becomes 19.
                     * Let's assume numDivLines to be 2. So for 2 numDivLines, we get closest
                     * adjusted range value as 21. Delta range = 21 - 19 (original range) = 2
                     * Also, range division value = 21 / (ND + 1) = 21 / 3 = 7
                     * We now get values for extended small arm as i*range division, where i
                     * runs from 1 to (numDivLines+1)/2. We go only halfway as it's the smaller
                     * arm and so cannot extend to a division beyond half way - else it would have
                     * been the bigger arm.
                     * So, first extended small arm = -7 * 1 = -7.
                     * We get the difference between extended small arm and original small arm.
                     * In this case it's 7 - 3 = 4 (all absolute values now - to avoid sign disparities).
                     * We see that delta arm > delta range. So, we ignore this range and get a new range.
                     * So, next range comes as = prev Range (21) + (numDivLines + 1)*interval
                     * = 21 + (2+1)*1 = 24
                     * Since the increment is sequential as a multiplication factor of
                     * (numDivLines + 1)*interval, it is also a valid divisible range.
                     * So we again check whether 0 can appear as a division. In this case, we
                     * get rangeDiv as 8 and extended smaller arm as 8. For this extended smaller
                     * arm, we get bigger arm as 16. Both of these are divisible by rangeDiv. That
                     * means, this range can include 0 as division line. So, we store it and proceed.
                     */
                    //Flag to indicate whether we've found the perfect range or not.
                    var found = false;
                    //We re-calculate the interval to get smaller increments for large values.
                    //For example, for 300 to -100 (with ND as 2), if we do not adjust interval, the min
                    //max come as -200, 400. But with adjusted intervals, it comes as -150, 300, which is
                    //more appropriate.
                    var adjInterval = (interval > 10) ? (interval / 10) : interval;
                    //Get the first divisible range for the given yMin, yMax, numDivLines and interval.
                    //We do not intercept and adjust interval for this calculation here.
                    var rangeD = getDivisibleRange (yMin, yMax, numDivLines, adjInterval, false);
                    //Now, deduct delta range from nextRange initially, so that in while loop,
                    //there's a unified statement for increment instead of 2 checks.
                    var nextRange = rangeD - (numDivLines + 1) * (adjInterval);
                    //Range division
                    var rangeDiv;
                    //Delta in range
                    var deltaRange;
                    //Multiplication factor
                    var mf;
                    //Smaller and bigger arm of y-axis
                    var smallArm, bigArm;
                    //Exntended small and big arm
                    var extSmallArm, extBigArm;
                    //Loop variable
                    var i;
                    //Now, we need to search for a range which is divisible in (numDivLines+1)
                    //segments including 0. Run a while loop till that is found.
                    while (found == false)
                    {
                        //Get range
                        nextRange = nextRange + (numDivLines + 1) * (adjInterval);
                        //If it's divisible for the given range and adjusted interval, proceed
                        if (isRangeDivisible (nextRange, numDivLines, adjInterval))
                        {
                            //Delta Range
                            deltaRange = nextRange - range;
                            //Range division
                            rangeDiv = nextRange / (numDivLines + 1);
                            //Get the smaller arm of axis
                            smallArm = Math.min (Math.abs (yMin) , yMax);
                            //Bigger arm of axis.
                            bigArm = range - smallArm;
                            //Get the multiplication factor (if smaller arm is negative, set -1);
                            mf = (smallArm == Math.abs (yMin)) ? - 1 : 1;
                            //If num div lines ==0, we do not calculate anything
                            if (numDivLines == 0)
                            {
                                //Set flag to true to exit loop
                                found = true;
                            } else {
                                //Now, we need to make sure that the smaller arm of axis is a multiple
                                //of rangeDiv and the multiplied result is greater than smallArm.
                                for (i = 1; i <= Math.floor ((numDivLines + 1) / 2); i ++)
                                {
                                    //Get extended small arm
                                    extSmallArm = rangeDiv * i;
                                    //If extension is more than original intended delta, we move to next
                                    //value of loop as this range is smaller than our intended range
                                    if ((extSmallArm - smallArm) > deltaRange)
                                    {
                                        //Iterate to next loop value
                                        continue;
                                    }
                                    //Else if extended arm is greater than smallArm, we do the 0 div test
                                    if (extSmallArm > smallArm)
                                    {
                                        //Get extended big arm
                                        extBigArm = nextRange - extSmallArm;
                                        //Check whether for this range, 0 can come as a div
                                        //By checking whether both extBigArm and extSmallArm
                                        //are perfectly divisible by rangeDiv
                                        if (((extBigArm / rangeDiv) == (Math.floor (extBigArm / rangeDiv))) && ((extSmallArm / rangeDiv) == (Math.floor (extSmallArm / rangeDiv))))
                                        {
                                            //Store in global containers
                                            range = nextRange;
                                            yMax = (mf == - 1) ? extBigArm : extSmallArm;
                                            yMin = (mf == - 1) ? ( - extSmallArm) : ( - extBigArm);
                                            //Set found flag to true to exit loop
                                            found = true;
                                        }
                                    } else {
                                        //Iterate to next loop value, as we need the arm to be greater
                                        //than original value.
                                        continue;
                                    }
                                }
                            }
                        }
                    }
                } else {
                    //Case 1.1 or 1.2
                    /**
                     * In this case, we first get apt divisible range based on yMin, yMax,
                     * numDivLines and the calculated interval. Thereby, get the difference
                     * between original range and new range and store as delta.
                     * If yMax>0, add this delta to yMax. Else substract from yMin.
                     */
                    //Get the adjusted divisible range
                    var adjRange = getDivisibleRange (yMin, yMax, numDivLines, interval, true);
                    //Get delta (Calculated range minus original range)
                    var deltaRange = adjRange - range;
                    //Update global range storage
                    range = adjRange;
                    //Now, add the change in range to yMax, if yMax > 0, else deduct from yMin
                    if (yMax > 0)
                    {
                        yMax = yMax + deltaRange;
                    } else {
                        yMin = yMin - deltaRange;
                    }
                }
            } else {
                /**
                 * Here, we've to handle the following cases
                 * 2. User specifies both yMin, yMax in XML. (which our program still validates)
                 * 3. User specifies only yMin. (we provide yMax)
                 * 4. User specifies only yMax. (we provide yMin)
                 * Now, for each of these, there can be two cases. If the user has opted to
                 * adjust div lines or not. If he has opted to adjustDiv, we calculate the best
                 * possible number of div lines for the given range. If not, we simply divide
                 * the given (or semi-calculated) axis limits by the number of div lines.
                 */
                if (adjustDiv == true)
                {
                    //We iterate from given numDivLines to 0,
                    //Count helps us keep a counter of how many div lines we've checked
                    //For the sake of optimization, we check only 25 div lines values
                    //From (numDivLines to 0) and (numDivLines to (25-numDivLines))
                    //We do it in a yoyo order - i.e., if numDivLines is set as 5,
                    //we first check 6 and then 4. Next would be (8,3), (9,2), (10,1),
                    //(11, (no value here, as we do not check for 0), 12, 13, 14, 15, 16,
                    //17,18,19,20. So, in this way, we check for 25 possible numDivLines and
                    //see if any one them fit in. If yes, we store that value. Else, we set it
                    //as 0 (indicating no div line feasible for the given value).
                    //Perform only if numDivLines>0
                    if (numDivLines > 0)
                    {
                        var counter = 0;
                        var multiplyFactor = 1;
                        var divLines;
                        while (1)
                        {
                            //Increment,Decrement numDivLines
                            divLines = numDivLines + (counter * multiplyFactor);
                            //Cannot be 0
                            divLines = (divLines == 0) ? 1 : divLines;
                            //Check whether this number of numDivLines satisfy our requirement
                            if (isRangeDivisible (range, divLines, interval))
                            {
                                //Exit loop
                                break;
                            }
                            //Each counter comes twice: one for + count, one for - count
                            counter = (multiplyFactor == - 1 || (counter > numDivLines)) ? ( ++ counter) : (counter);
                            if (counter > 25)
                            {
                                //We do not go beyond 25 count to optimize.
                                //If the loop comes here, it means that divlines
                                //counter is not able to achieve the target.
                                //So, we assume no div lines are possible and exit.
                                divLines = 0;
                                break;
                            }
                            //Switch to increment/decrement mode. If counter
                            multiplyFactor = (counter <= numDivLines) ? (multiplyFactor * - 1) : (1);
                        }
                        //Store the value in params
                        numDivLines = divLines;
                    }
                } else
{
                //Div lines intevals need to formatted to the given precision.
                }
            }
            /*	//Set flags pertinent to zero plane
                    if (yMax > 0 && yMin < 0)
                    {
                            zeroPRequired = true;
                    } else
                    {
                            zeroPRequired = false;
                    }*/
            //Div interval
            var divInterval = (yMax - yMin) / (numDivLines + 1);
            /*	//Flag to keep a track whether zero plane is included
                    zeroPIncluded = false;
                    //We now need to store all the div line segments in the array this.divLines
                    //We include yMin and yMax too in div lines to render in a single loop
                    var divLineValue = yMin - divInterval;
                    //Keeping a count of div lines
                    var count = 0;
                    while (count <= (numDivLines + 1))
                    {
                            //Converting to string and back to number to avoid Flash's rounding problems.
                            divLineValue = Number (String (divLineValue + divInterval));
                            //Check whether zero plane is included
                            zeroPIncluded = (divLineValue == 0) ? true : zeroPIncluded;
                            //Add the div line to this.divLines
                            this.divLines [count] = this.returnDataAsDivLine (divLineValue);
                            //Based on yAxisValueStep, we need to hide required div line values
                            if (count % yAxisValuesStep == 0)
                            {
                                    divLines [count].showValue = true;
                            } else
                            {
                                    divLines [count].showValue = false;
                            }
                            //Increment counter
                            count ++;
                    }
                    //Now, the array this.divLines contains all the divisional values. But, it might
                    //not contain 0 value in Case 2,3,4 (i.e., when the user manually sets things).
                    //So, if zero plane is required but not included, we include it.
                    if (zeroPRequired == true && zeroPIncluded == false)
                    {
                            //Include zero plane at the right place in the array.
                            divLines.push (returnDataAsDivLine (0));
                            //Now, sort on value so that 0 automatically appears at right place
                            divLines.sortOn ("value", Array.NUMERIC);
                            //Also increase numDivLines
                            numDivLines ++;
                    }
                    //We finally have the sorted div lines in this.divLines		*/

            //////fix of error in renderer for infinite loop
            divInterval = divInterval;

            return {
                Max: yMax,
                Min: yMin,
                Range: range,
                interval: interval,
                divGap: divInterval
            };

        };
    })(),

    //HC compatiable JSON to Show a message in Chart
    //store blank Chart to show message
    ///special configuration
    

    createDialog =  (function () {

        var api = function (container, text) {
            this.title.y = container.offsetHeight / 2;
            if (text !== undefined) {
                this.title.text = text;
            }
        };

        api.prototype = {//jsonstructutr for a blank chart which will be used to show a messege
            chart: {
                events: {},
                margin: [0, 0, 0, 0],
                backgroundColor: {
                    FCcolor: {
                        alpha: 0
                    }
                }
            },
            credits: {
                href: 'http://www.fusioncharts.com?BS=FCHSEvalMark',
                text: 'FusionCharts',
                enabled: true
            },
            legend: {
                enabled: false
            },
            title: {
                text: '',
                style: {
                    fontFamily: 'Verdana',
                    fontSize:  '10px',
                    color: '#666666'
                }
            },
            plotOptions: {
                series: {}
            },
            series : [{}],
            exporting: {
                enabled: false
            },
            nativeMessage: true
        };

        return api.prototype.constructor = api;
    })(),



    /**
     * This object allows to make decision as to where to position the label
     * based on certain decisions. This pre-decision saves on a small amount
     * of computation time per trenline.
     * @example
     * trendLineLabelPosition[zone][inverse][startValue > endValue][!!isOnOppositeAxis]
     */
    trendLineLabelPosition = {
        'true' : {
            'true': {
                'true': {
                    'true': POSITION_MIDDLE,
                    'false': POSITION_MIDDLE
                },
                'false': {
                    'true': POSITION_MIDDLE,
                    'false': POSITION_MIDDLE
                }
            },
            'false': {
                'true': {
                    'true': POSITION_MIDDLE,
                    'false': POSITION_MIDDLE
                },
                'false': {
                    'true': POSITION_MIDDLE,
                    'false': POSITION_MIDDLE
                }
            }
        },
        'false': {
            'true' : {
                'true': {
                    // Axis oppositality
                    'true': POSITION_BOTTOM,
                    'false': POSITION_TOP
                },
                'false': {
                    // Axis oppositality
                    'true': POSITION_MIDDLE,
                    'false': POSITION_MIDDLE
                }
            },
            'false' : {
                'false': {
                    // Axis oppositality
                    'true': POSITION_BOTTOM,
                    'false': POSITION_TOP
                },
                'true': {
                    // Axis oppositality
                    'true': POSITION_TOP,
                    'false': POSITION_BOTTOM
                }
            }
        }
    },
    // [zone][!inverse][start < end]
    trendLineLabelPositionHoriz = {
        'true' : {
            'true': {
                'true': POSITION_CENTER,
                'false': POSITION_CENTER
            },
            'false': {
                'true': POSITION_CENTER,
                'false': POSITION_CENTER
            }
        },
        'false': {
            // Relative value position: start < end
            'true': {
                // Axis oppositality
                'true': POSITION_RIGHT,
                'false': POSITION_LEFT
            },
            'false': {
                // Axis oppositality
                'true': POSITION_LEFT,
                'false': POSITION_RIGHT
            }
        }
    },



    //Function to insart trend Line
    

    createTrendLine = (function () {
        return function (trendObj, axis, hcConf, isDY, isBar, isVtrend, isInverse) {
            var x,
            trendStyle = hcConf.trendStyle,
            z,
            l,
            m,
            trendLineObj,
            isOpp,
            isZone,
            displayvalue,
            trendLabelObj,
            plotBandOrLineEvents,
            toolText,
            labelColor,
            axisObj,
            width,
            trendStartValue,
            trendEndValue,
            slopeDirection,
            slopeDirectionHoriz,
            max, min,
            axisIndex,
            halfFontSize = (parseInt(trendStyle.fontSize, 10) / 2);// + 2;//a tolerance of 2 pixel present in HC

            if (isVtrend ? !hcConf.showVLines : !hcConf.showTrendlines) {
                return;

            }
            for (x = 0, l = trendObj.length; x < l; x += 1) {
                if (trendObj[x].line) {
                    for (z = 0, m = trendObj[x].line.length; z < m; z += 1) {

                        trendLineObj = trendObj[x].line[z];

                        trendStartValue = hcConf.numberFormatter.getCleanValue(pluck(trendLineObj.startvalue,
                            trendLineObj.value, 0));
                        trendEndValue = hcConf.numberFormatter.getCleanValue(pluck(trendLineObj.endvalue,
                            pluck(trendLineObj.startvalue, trendLineObj.value, 0)));

                        //check which axis object will be added
                        if (isVtrend) {
                            axisObj = axis;
                        }
                        else if (isDY && trendLineObj.parentyaxis && /^s$/i.test(trendLineObj.parentyaxis)) {
                            axisObj = axis[1];
                            axisIndex = 1;
                        }
                        else {
                            axisObj = axis[0];
                        }
                        max = axisObj.max;
                        min = axisObj.min;
                        //isOpp variable needs to be re-evaluated in each iteration
                        //as trendlines might be of different axis.
                        isOpp = false;
                        if (max >= trendStartValue && max >= trendEndValue && min <= trendStartValue && min <= trendEndValue) {
                            //for secondary y axis we have to place its trendlines on right
                            //by default. attribute valueonleft for secondary y axis is not
                            //documented. So its usage at this moment will be a hack
                            if (isDY && trendLineObj.parentyaxis && /^s$/i.test(trendLineObj.parentyaxis)) {
                                isOpp = pluck(trendLineObj.valueonleft, hcConf.trendlineValuesOnOpp) !== ONESTRING;
                            }
                            //But for any DY axis chart trendlines should not be placed on
                            //right.
                            else if(!isDY){
                                isOpp = pluck(trendLineObj.valueonright, hcConf.trendlineValuesOnOpp) === ONESTRING;
                            }

                            /*isOpp = (trendLineObj.valueonright === ONESTRING ||
                                (trendLineObj.parentyaxis && /^s$/i.test(trendLineObj.parentyaxis))) ? true : false;*/

                            // Calculate from input values whether the object would
                            // be trendline or trendzone
                            isZone = Boolean(pluckNumber(trendLineObj.istrendzone, isVtrend ? 1 : 0));

                            //if there has a display value the create it
                            if (!(isVtrend ? hcConf.showVLineLabels : hcConf.showTrendlineLabels)) {
                                displayvalue = BLANK;
                            }
                            else {
                                displayvalue = parseUnsafeString(pluck(trendLineObj.displayvalue,
                                        hcConf.numberFormatter[isVtrend ?
                                        'xAxis' : 'dataLabels'](trendStartValue, axisIndex)));
                            }


                            if (displayvalue) {
                                slopeDirection = (trendStartValue > trendEndValue);
                                slopeDirectionHoriz = (trendStartValue < trendEndValue);
                                trendLabelObj = {
                                    text: displayvalue,
                                    textAlign: isBar ? POSITION_CENTER : (isOpp ? POSITION_LEFT : POSITION_RIGHT),
                                    align: isBar ? trendLineLabelPositionHoriz[isZone][!isInverse][slopeDirectionHoriz] :
                                    (isOpp ? POSITION_RIGHT : POSITION_LEFT),
                                    /*verticalAlign: isBar ? POSITION_BOTTOM :
                                        trendLineLabelPosition[isZone][!isInverse][slopeDirection][isOpp],*/
                                    verticalAlign: isBar ? POSITION_BOTTOM : POSITION_MIDDLE,
                                    rotation: 0,
                                    x: 0,
                                    y: 0, //isBar ? halfFontSize : 2,
                                    style: trendStyle
                                }
                                labelColor = pluck(trendLineObj.color, hcConf.trendlineColor);
                                trendLineObj.alwaysVisible = isZone; // always show zones (even if 0 width)
                                if (labelColor) {
                                    trendLabelObj.style = extend2({}, trendStyle);
                                    trendLabelObj.style.color  = labelColor.replace(dropHash, HASHSTRING);
                                }
                            }
                            else {
                                trendLabelObj = undefined;
                            }
                            //add options for tooltext
                            toolText = pluck(trendLineObj.tooltext)

                            width = pluckNumber(trendLineObj.thickness, hcConf.trendlineThickness, 1)

                            if (isZone) {
                                axisObj.plotBands.push({
                                    isTrend : true,
                                    color: convertColor(pluck(trendLineObj.color, hcConf.trendlineColor), pluck(trendLineObj.alpha, hcConf.trendlineAlpha, 40)),
                                    from: trendStartValue,
                                    to: trendEndValue,
                                    label: trendLabelObj,
                                    //for 3d series never will be on top
                                    zIndex : !hcConf.is3d && pluck(trendLineObj.showontop, hcConf.showTrendlinesOnTop) === ONESTRING ? 5 : 3,
                                    tooltext : toolText,
                                    alwaysVisible: trendLineObj.alwaysVisible
                                });
                            }
                            else {
                                axisObj.plotLines.push({
                                    isTrend : true,
                                    color: convertColor(pluck(trendLineObj.color, hcConf.trendlineColor, hcConf.trendlineColor), pluck(trendLineObj.alpha, hcConf.trendlineAlpha, 99)),
                                    value: trendStartValue,
                                    to: trendEndValue,
                                    width: width,
                                    dashStyle : pluck(trendLineObj.dashed, hcConf.trendlinesAreDashed) == ONESTRING ? getDashStyle(pluckNumber(trendLineObj.dashlen, hcConf.trendlinesDashLen), pluckNumber(trendLineObj.dashgap, hcConf.trendlinesDashGap), width) : undefined,
                                    label: trendLabelObj,
                                    //for 3d series never will be on top
                                    zIndex : !hcConf.is3d && pluck(trendLineObj.showontop, hcConf.showTrendlinesOnTop) === ONESTRING ? 5 : 3,
                                    tooltext : toolText
                                });
                            }

                        }
                    }
                }
            }
        }
    })(),


    //Function to convert FC dash style to HC dash style
    

    getDashStyle = function (len, gap, thickness, apply) {
        return (apply || apply === undefined) ? [len, gap] : BLANK;

        


    },



    /**
     * Internally used to create a chart api store. Creating chart api store in
     * this way (instead of just creating a new object,) allows us to easily
     * identify whether an object is part of chartAPI or not.
     * @constructor
     * @private
     */
    ChartAPIItem = function () { },

    /**
     * Function to define chart-api and configuration. This has to be used to
     * define the configuration of various chart types.
     *
     * @param {string} type specifies the name of the chart/series for which
     * the API has to be set.
     *
     * @paran {object} api is the key-value pair that defines various object.
     *
     * @param {ChartAPIItem} parent refers to the possibility of inheriting this
     * new chart from an existing chart.
     *
     * @type object
     * @return The chartAPI created from the mapping api provided.
     *
     * @code
     * chartAPI('column', {
     *     series: {
     *         sample: function () { return 'column.series.sample'; }
     *     },
     *     point: function () {};
     * });
     * var column2d = chartAPI('column2d', {
     *     series: 'column'
     * });
     *
     * column2d.series.sample2 = function () {
     *     return 'column2d.series.sample2';
     * };
     *
     * // Also be accessed as:
     * chartAPI.column.point();
     */
    chartAPI = function (type, api, parent) {
        var item,
        typeAPI = chartAPI[type],
        extensibleTypeObject,
        IAPIInterface;

        // If the object that holds the chart API is not already defined,
        // then we set the api to a blank object.
        if (!typeAPI) {
            IAPIInterface = function () { };
            // If a parent APIItem is specified, we set the prototype of the new
            // item as the parent.
            IAPIInterface.prototype = parent instanceof ChartAPIItem ?
            parent : new ChartAPIItem();
            IAPIInterface.prototype.constructor = IAPIInterface;
            typeAPI = chartAPI[type] = new IAPIInterface();
        }

        // Set the base api
        if (parent) {
            typeAPI.base = parent;
        }
        // Set the type name
        typeAPI.name = type;

        // Now we loop through the entire set of groups (immediate sibling)
        // in the API and depending upon its type, we perform various actions.
        for (item in api) {
            switch (typeof api[item]) {
                // If the value is string, we know it is an instruction to
                // inherit the object from the typeName specified as value.
                case OBJECTSTRING:
                    if (api[item] instanceof ChartAPIItem) {
                        typeAPI[item] = api[item][item];
                        break;
                    }

                // Otherwise we know that we are to simply set the API as
                // provided.
                default:
                    typeAPI[item] = api[item];
                    break;

                // In case the value is undefined, we know that the instruction
                // is to delete that API item.
                case STRINGUNDEFINED:
                    delete typeAPI[item];
                    break;

            }
        }

        // If a new instance is wanted, create one and return
        if (this instanceof chartAPI) {
            extensibleTypeObject = function () { };
            extensibleTypeObject.prototype = typeAPI;
            extensibleTypeObject.prototype.constructor = extensibleTypeObject;
            return new extensibleTypeObject();
        }
        else {
            // Return the resultant chart API created from the above algorithm.
            return typeAPI;
        }
    };

    // Add Renderer global library
    global.extend(global.hcLib, {
        BLANKSTRINGPLACEHOLDER: BLANKSTRINGPLACEHOLDER,
        BLANKSTRING: BLANK,
        COLOR_BLACK: COLOR_BLACK,
        COLOR_GLASS: COLOR_GLASS,
        COLOR_WHITE: COLOR_WHITE,
        COLOR_TRANSPARENT : COLOR_TRANSPARENT,
        HASHSTRING: HASHSTRING,
        BREAKSTRING: BREAKSTRING,
        STRINGSTRING: STRINGSTRING,
        OBJECTSTRING: OBJECTSTRING,
        COMMASTRING: COMMASTRING,
        ZEROSTRING : ZEROSTRING,
        SAMPLESTRING : 'Ay0',
        TESTSTR : TESTSTR,
        ONESTRING : ONESTRING,
        DECIMALSTRING : DECIMALSTRING,
        STRINGUNDEFINED: STRINGUNDEFINED,
        POSITION_TOP  : POSITION_TOP,
        POSITION_RIGHT  : POSITION_RIGHT,
        POSITION_BOTTOM  : POSITION_BOTTOM,
        POSITION_LEFT  : POSITION_LEFT,
        POSITION_CENTER : POSITION_CENTER,
        POSITION_MIDDLE : POSITION_MIDDLE,
        POSITION_START : POSITION_START,
        POSITION_END : POSITION_END,
        FC_CONFIG_STRING : FC_CONFIG_STRING,
        SHAPE_RECT : SHAPE_RECT,
        HUNDREDSTRING : HUNDREDSTRING,
        PXSTRING : PXSTRING,
        COMMASPACE : COMMASPACE,
        TEXTANCHOR: TEXTANCHOR,

        regex: {
            stripWhitespace: stripWhitespace,
            dropHash: dropHash,
            startsRGBA: startsRGBA,
            cleanColorCode: cleanColorCode,
            breakPlaceholder: breakPlaceholder,
            hexcode : hexcode
        },
        fireEvent: fireEvent,
        addEvent: addEvent,
        removeEvent: removeEvent,
        getTouchEvent: getTouchEvent,
        extend2: extend2,
        deltend: deltend,
        imprint: imprint,
        pluck: pluck,
        pluckNumber: pluckNumber,
        getFirstDefinedValue: getFirstDefinedValue,
        createElement: createElement,
        hashify: hashify,
        pluckFontSize: pluckFontSize,
        getValidValue: getValidValue,
        getPosition: getPosition,
        getViewPortDimension: getViewPortDimension,
        bindSelectionEvent: bindSelectionEvent,
        createContextMenu: createContextMenu,
        getDefinedColor: getDefinedColor,
        getFirstValue: getFirstValue,
        getFirstColor: getFirstColor,
        getColorCodeString: getColorCodeString,
        pluckColor: pluckColor,
        trimString: trimString,
        getFirstAlpha: getFirstAlpha,
        parsePointValue: parsePointValue,
        parseUnsafeString: parseUnsafeString,
        toPrecision: toPrecision,
        hasTouch: hasTouch,
        getSentenceCase: getSentenceCase,
        getCrispValues: getCrispValue,
        stubFN : function () {},
        falseFN : function () {
            return false;
        },
            /**
        * Utility method that sorts an object array and keeping the order of equal items.
        * ECMA script standard does not specify the behaviour when items are equal.
        */
        stableSort: function (arr, sortFunction) {
            var length = arr.length,
            i;

            // Add index to each item
            for (i = 0; i < length; i++) {
                arr[i].ss_i = i; // stable sort index
            }

            arr.sort(function (a, b) {
                var sortValue = sortFunction(a, b);
                return sortValue === 0 ? a.ss_i - b.ss_i : sortValue;
            });

            // Remove index from items
            for (i = 0; i < length; i++) {
                delete arr[i].ss_i; // stable sort index
            }
        },

        hasSVG : hasSVG,
        isIE: isIE,

        getLinkAction : getLinkAction,


        graphics: {
            parseAlpha: parseAlpha,
            convertColor: convertColor,
            getDarkColor : getDarkColor,
            getLightColor : getLightColor,
            mapSymbolName: mapSymbolName,
            getColumnColor : getColumnColor,
            getAngle : getAngle,
            parseColor: parseColor,
            getValidColor: getValidColor,
            HSBtoRGB: HSBtoRGB,
            RGBtoHSB: RGBtoHSB,
            RGBtoHex: RGBtoHex,
            HEXtoRGB: HEXtoRGB
        },

        setImageDisplayMode: setImageDisplayMode,
        setLineHeight : setLineHeight,
        supportedStyle: supportedStyle,
        getAxisLimits : getAxisLimits,
        createTrendLine : createTrendLine,
        getDashStyle : getDashStyle,
        axisLabelAdder : axisLabelAdder,

        chartAPI: chartAPI,
        createDialog: createDialog,


        defaultPaletteOptions: {
            //Palette color arrays
            // ------------- For 2D Chart ---------------//
            bgColor : ["CBCBCB,E9E9E9", "CFD4BE,F3F5DD", "C5DADD,EDFBFE", "A86402,FDC16D", "FF7CA0,FFD1DD"],
            bgAngle : [270, 270, 270, 270, 270],
            bgRatio : [BGRATIOSTRING, BGRATIOSTRING, BGRATIOSTRING, BGRATIOSTRING, BGRATIOSTRING],
            bgAlpha : ["50,50", "60,50", "40,20", "20,10", "30,30"],
            canvasBgColor : [COLOR_WHITE, COLOR_WHITE, COLOR_WHITE, COLOR_WHITE, COLOR_WHITE],
            canvasBgAngle : [0, 0, 0, 0, 0],
            canvasBgAlpha : [HUNDREDSTRING, HUNDREDSTRING, HUNDREDSTRING, HUNDREDSTRING, HUNDREDSTRING],
            canvasBgRatio : [BLANK, BLANK, BLANK, BLANK, BLANK],
            canvasBorderColor : ["545454", "545454", "415D6F", "845001", "68001B"],
            canvasBorderAlpha : [100, 100, 100, 90, 100],
            showShadow : [0, 1, 1, 1, 1],
            divLineColor : ["717170", "7B7D6D", "92CDD6", "965B01", "68001B"],
            divLineAlpha : [40, 45, 65, 40, 30],
            altHGridColor : ["EEEEEE", "D8DCC5", "99C4CD", "DEC49C", "FEC1D0"],
            altHGridAlpha : [50, 35, 10, 20, 15],
            altVGridColor : ["767575", "D8DCC5", "99C4CD", "DEC49C", "FEC1D0"],
            altVGridAlpha : [10, 20, 10, 15, 10],
            anchorBgColor : [COLOR_WHITE, COLOR_WHITE, COLOR_WHITE, COLOR_WHITE, COLOR_WHITE],
            toolTipBgColor : [COLOR_WHITE, COLOR_WHITE, COLOR_WHITE, COLOR_WHITE, COLOR_WHITE],
            toolTipBorderColor : ["545454", "545454", "415D6F", "845001", "68001B"],
            baseFontColor : ["555555", "60634E", "025B6A", "A15E01", "68001B"],
            borderColor : ["767575", "545454", "415D6F", "845001", "68001B"],
            borderAlpha : [50, 50, 50, 50, 50],
            legendBgColor : [COLOR_WHITE, COLOR_WHITE, COLOR_WHITE, COLOR_WHITE, COLOR_WHITE],
            legendBorderColor : ["545454", "545454", "415D6F", "845001", "D55979"],
            plotGradientColor : [COLOR_WHITE, COLOR_WHITE, COLOR_WHITE, COLOR_WHITE, COLOR_WHITE],
            plotBorderColor : ["333333", "8A8A8A", COLOR_WHITE, COLOR_WHITE, COLOR_WHITE],
            plotFillColor : ["767575", "D8DCC5", "99C4CD", "DEC49C", "FEC1D0"],
            // -------------- For 3D Chart --------------//
            bgColor3D : [COLOR_WHITE, COLOR_WHITE, COLOR_WHITE, COLOR_WHITE, COLOR_WHITE],
            bgAlpha3D : [HUNDREDSTRING, HUNDREDSTRING, HUNDREDSTRING, HUNDREDSTRING, HUNDREDSTRING],
            bgAngle3D : [90, 90, 90, 90, 90],
            bgRatio3D : [BLANK, BLANK, BLANK, BLANK, BLANK],
            canvasBgColor3D : ["DDE3D5", "D8D8D7", "EEDFCA", "CFD2D8", "FEE8E0"],
            canvasBaseColor3D : ["ACBB99", "BCBCBD", "C8A06C", "96A4AF", "FAC7BC"],
            divLineColor3D : ["ACBB99", "A4A4A4", "BE9B6B", "7C8995", "D49B8B"],
            divLineAlpha3D : [100, 100, 100, 100, 100],
            legendBgColor3D : ["F0F3ED", "F3F3F3", "F7F0E8", "EEF0F2", "FEF8F5"],
            legendBorderColor3D : ["C6CFB8", "C8C8C8", "DFC29C", "CFD5DA", "FAD1C7"],
            toolTipbgColor3D : [COLOR_WHITE, COLOR_WHITE, COLOR_WHITE, COLOR_WHITE, COLOR_WHITE],
            toolTipBorderColor3D : ["49563A", "666666", "49351D", "576373", "681C09"],
            baseFontColor3D : ["49563A", "4A4A4A", "49351D", "48505A", "681C09"],
            anchorBgColor3D : [COLOR_WHITE, COLOR_WHITE, COLOR_WHITE, COLOR_WHITE, COLOR_WHITE]
        }
    });
}());


/**
 * Modified version of jQuery.event.drag from original code by FusionCharts.
 * All third-party attributions implied.
 */
(function( $ ){

    // add the jquery instance method
    $.fn.drag = function( str, arg, opts ){
        // figure out the event type
        var type = typeof str == "string" ? str : "",
        // figure out the event handler...
        fn = $.isFunction( str ) ? str : $.isFunction( arg ) ? arg : null;
        // fix the event type
        if ( type.indexOf("drag") !== 0 )
            type = "drag"+ type;
        // were options passed
        opts = ( str == fn ? arg : opts ) || {};
        // trigger or bind event handler
        return fn ? this.bind( type, opts, fn ) : this.trigger( type );
    };

    // local refs (increase compression)
    var $event = $.event,
    hasTouch = 'ontouchstart' in document.documentElement,
    initBindings = hasTouch ? 'touchstart' : 'mousedown',
    dragBindings = hasTouch ? 'touchmove touchend' : 'mousemove mouseup',
    touchEventXY = function (event, dd) {
        var origEvent, touches;
        if (!dd.touchXY || !event.originalEvent) {
            return event;
        }

        // check whether mouse click or screentap
        origEvent = event.originalEvent || event.sourceEvent
        touches = origEvent.changedTouches || origEvent.touches;

        if (touches && touches.length) {
            $.extend(event, touches[0]);
        }

        return event;
    },

    $special = $event.special,
    // configure the drag special event
    drag = $special.drag = {

        // these are the default settings
        defaults: {
            which: 1, // mouse button pressed to start drag sequence
            distance: 0, // distance dragged before dragstart
            not: ':input', // selector to suppress dragging on target elements
            handle: null, // selector to match handle target elements
            relative: false, // true to use "position", false to use "offset"
            drop: false, // false to suppress drop events, true or selector to allow
            click: false, // false to suppress click events after dragend (no proxy)
            touchXY: true // Make touch XY match event XY
        },

        // the key name for stored drag data
        datakey: "dragdata",

        // the namespace for internal live events
        livekey: "livedrag",

        // count bound related events
        add: function( obj ){
            // read the interaction data
            var data = $.data( this, drag.datakey ) || $.data(this, drag.datakey, $.extend({
                related:0
            }, drag.defaults )),
            // read any passed options
            opts = obj.data || {};
            // count another realted event
            data.related += 1;
            // bind the live "draginit" delegator
            if ( !data.live && obj.selector ){
                data.live = true;
                $event.add( this, "draginit."+ drag.livekey, drag.delegate );
            }
            // extend data options bound with this event
            // don't iterate "opts" in case it is a node
            $.each( drag.defaults, function( key, def ){
                if ( opts[ key ] !== undefined )
                    data[ key ] = opts[ key ];
            });
        },

        // forget unbound related events
        remove: function(){
            ($.data( this, drag.datakey ) || {}).related -= 1;
        },

        // configure interaction, capture settings
        setup: function(){
            // check for related events
            if ( $.data( this, drag.datakey ) )
                return;
            // initialize the drag data with copied defaults
            var data = $.extend({
                related:0
            }, drag.defaults );
            // store the interaction data
            $.data( this, drag.datakey, data );
            // bind the mousedown event, which starts drag interactions
            $event.add( this, initBindings, drag.init, data );
            // prevent image dragging in IE...
            if ( this.attachEvent )
                this.attachEvent("ondragstart", drag.dontstart );
        },

        // destroy configured interaction
        teardown: function(){
            // check for related events
            if ( ($.data( this, drag.datakey ) || {}).related )
                return;
            // remove the stored data
            $.removeData( this, drag.datakey );
            // remove the mousedown event
            $event.remove( this, initBindings, drag.init );
            // remove the "live" delegation
            $event.remove( this, "draginit", drag.delegate );
            // enable text selection
            drag.textselect( true );
            // un-prevent image dragging in IE...
            if ( this.detachEvent )
                this.detachEvent("ondragstart", drag.dontstart );
        },

        // initialize the interaction
        init: function( event ){
            // the drag/drop interaction data
            var dd = event.data, results,
                origEvent = event.originalEvent || event.sourceEvent,
                touches = origEvent ? (origEvent.changedTouches ||
                    origEvent.touches) : [];

            // check whether mouse click or screentap
            if (touches && touches.length) {
                // let the system handle multitouch operations like two finger scroll
                // and pinching
                if (touches.length > 1) {
                    return;
                }
                else {
                    touchEventXY(event, dd);
                }
            }
            else {
                // check the which directive
                if ( dd.which > 0 && event.which != dd.which ) {
                    return;
                }
            }

            // check for suppressed selector
            if ( $( event.target ).is( dd.not ) )
                return;
            // check for handle selector
            if ( dd.handle && !$( event.target ).closest( dd.handle, event.currentTarget ).length )
                return;
            // store/reset some initial attributes
            dd.propagates = 1;
            dd.interactions = [ drag.interaction( this, dd ) ];
            dd.target = event.target;
            dd.pageX = event.pageX;
            dd.pageY = event.pageY;
            dd.dragging = null;
            // handle draginit event...
            results = drag.hijack( event, "draginit", dd );
            //if ()
            // early cancel
            if ( !dd.propagates )
                return;
            // flatten the result set
            results = drag.flatten( results );
            // insert new interaction elements
            if ( results && results.length ){
                dd.interactions = [];
                $.each( results, function(){
                    dd.interactions.push( drag.interaction( this, dd ) );
                });
            }
            // remember how many interactions are propagating
            dd.propagates = dd.interactions.length;
            // locate and init the drop targets
            if ( dd.drop !== false && $special.drop )
                $special.drop.handler( event, dd );
            // disable text selection
            drag.textselect( false );
            // bind additional events...
            $event.add( document, dragBindings, drag.handler, dd );
            // helps prevent text selection
            if (!hasTouch) {
                return false;
            }
        },
        // returns an interaction object
        interaction: function( elem, dd ){
            return {
                drag: elem,
                callback: new drag.callback(),
                droppable: [],
                offset: $( elem )[ dd.relative ? "position" : "offset" ]() || {
                    top:0,
                    left:0
                }
            };
        },
        // handle drag-releatd DOM events
        handler: function( event ){
            // read the data before hijacking anything
            var dd = event.data, origEvent, touches;
            // mousemove, check distance, start dragging
            if (!dd.dragging && (event.type === 'mousemove' || event.type === 'touchmove')) {
                //  drag tolerance, x² + y² = distance²
                if ( Math.pow(  event.pageX-dd.pageX, 2 ) + Math.pow(  event.pageY-dd.pageY, 2 ) < Math.pow( dd.distance, 2 ) )
                    return; // distance tolerance not reached
                event.target = dd.target; // force target from "mousedown" event (fix distance issue)
                drag.hijack( event, "dragstart", dd ); // trigger "dragstart"
                if ( dd.propagates ) // "dragstart" not rejected
                    dd.dragging = true; // activate interaction
            }
            // handle various events
            switch ( event.type ){
                // mousemove, dragging
                case 'touchmove':
                    // check whether mouse click or screentap
                    origEvent = event.originalEvent || event.sourceEvent;
                    touches = origEvent.touches;
                    // prevent touch device screen scrolling.
                    if (dd.dragging) {
                        touches && (touches.length > 1) || event.preventDefault();
                        touchEventXY(event, dd);
                    }

                case 'mousemove':
                    if ( dd.dragging ){
                        // trigger "drag"
                        drag.hijack( event, "drag", dd );
                        if ( dd.propagates ){
                            // manage drop events
                            if ( dd.drop !== false && $special.drop )
                                $special.drop.handler( event, dd ); // "dropstart", "dropend"
                            break; // "drag" not rejected, stop
                        }
                        event.type = "mouseup"; // helps "drop" handler behave
                    }
                // mouseup, stop dragging
                case 'touchend':
                    if (dd.dragging) {
                        touchEventXY(event, dd);
                    }

                case 'mouseup':
                    $event.remove( document, dragBindings, drag.handler ); // remove page events
                    if ( dd.dragging ){
                        if ( dd.drop !== false && $special.drop )
                            $special.drop.handler( event, dd ); // "drop"
                        drag.hijack( event, "dragend", dd ); // trigger "dragend"
                    }
                    drag.textselect( true ); // enable text selection

                    // if suppressing click events...
                    if ( dd.click === false && dd.dragging ){
                        jQuery.event.triggered = true;
                        setTimeout(function(){
                            jQuery.event.triggered = false;
                        }, 20 );
                        dd.dragging = false; // deactivate element
                    }
                    break;
            }
        },

        // identify potential delegate elements
        delegate: function( event ){
            // local refs
            var elems = [], target,
            // element event structure
            events = $.data( this, "events" ) || {};
            // query live events
            $.each( events.live || [], function( i, obj ){
                // no event type matches
                if ( obj.preType.indexOf("drag") !== 0 )
                    return;
                // locate the element to delegate
                target = $( event.target ).closest( obj.selector, event.currentTarget )[0];
                // no element found
                if ( !target )
                    return;
                // add an event handler
                $event.add( target, obj.origType+'.'+drag.livekey, obj.origHandler, obj.data );
                // remember new elements
                if ( $.inArray( target, elems ) < 0 )
                    elems.push( target );
            });
            // if there are no elements, break
            if ( !elems.length )
                return false;
            // return the matched results, and clenup when complete
            return $( elems ).bind("dragend."+ drag.livekey, function(){
                $event.remove( this, "."+ drag.livekey ); // cleanup delegation
            });
        },

        // re-use event object for custom events
        hijack: function( event, type, dd, x, elem ){
            // not configured
            if ( !dd )
                return;
            // remember the original event and type
            var orig = {
                event:event.originalEvent,
                type: event.type
            },
            // is the event drag related or drog related?
            mode = type.indexOf("drop") ? "drag" : "drop",
            // iteration vars
            result, i = x || 0, ia, $elems, callback,
            len = !isNaN( x ) ? x : dd.interactions.length;
            // modify the event type
            event.type = type;
            // copy the originalEvent as 'source event'
            event.sourceEvent = orig.event;
            // remove the original event
            event.originalEvent = null;
            // initialize the results
            dd.results = [];
            // handle each interacted element
            do if ( ia = dd.interactions[ i ] ){
                // validate the interaction
                if ( type !== "dragend" && ia.cancelled )
                    continue;
                // set the dragdrop properties on the event object
                callback = drag.properties( event, dd, ia );

                // prepare for more results
                ia.results = [];
                // handle each element
                $( elem || ia[ mode ] || dd.droppable ).each(function( p, subject ){
                    // identify drag or drop targets individually
                    callback.target = subject;
                    // handle the event
                    result = subject ? $event.handle.call( subject, event, callback ) : null;
                    // stop the drag interaction for this element
                    if ( result === false ){
                        if ( mode == "drag" ){
                            ia.cancelled = true;
                            dd.propagates -= 1;
                        }
                        if ( type == "drop" ){
                            ia[ mode ][p] = null;
                        }
                    }
                    // assign any dropinit elements
                    else if ( type == "dropinit" )
                        ia.droppable.push( drag.element( result ) || subject );
                    // accept a returned proxy element
                    if ( type == "dragstart" )
                        ia.proxy = $( drag.element( result ) || ia.drag )[0];
                    // remember this result
                    ia.results.push( result );
                    // forget the event result, for recycling
                    delete event.result;
                    // break on cancelled handler
                    if ( type !== "dropinit" )
                        return result;
                });
                // flatten the results
                dd.results[ i ] = drag.flatten( ia.results );
                // accept a set of valid drop targets
                if ( type == "dropinit" )
                    ia.droppable = drag.flatten( ia.droppable );
                // locate drop targets
                if ( type == "dragstart" && !ia.cancelled )
                    callback.update();
            }
            while ( ++i < len )
            // restore the original event & type
            event.type = orig.type;
            event.originalEvent = orig.event;
            // return all handler results
            return drag.flatten( dd.results );
        },

        // extend the callback object with drag/drop properties...
        properties: function( event, dd, ia ){
            var obj = ia.callback;
            // elements
            obj.drag = ia.drag;
            obj.proxy = ia.proxy || ia.drag;
            // starting mouse position
            obj.startX = dd.pageX;
            obj.startY = dd.pageY;
            // current distance dragged
            obj.deltaX = event.pageX - dd.pageX;
            obj.deltaY = event.pageY - dd.pageY;
            // original element position
            obj.originalX = ia.offset.left;
            obj.originalY = ia.offset.top;
            // adjusted element position
            obj.offsetX = event.pageX - ( dd.pageX - obj.originalX );
            obj.offsetY = event.pageY - ( dd.pageY - obj.originalY );
            // assign the drop targets information
            obj.drop = drag.flatten( ( ia.drop || [] ).slice() );
            obj.available = drag.flatten( ( ia.droppable || [] ).slice() );
            return obj;
        },

        // determine is the argument is an element or jquery instance
        element: function( arg ){
            if ( arg && ( arg.jquery || arg.nodeType == 1 ) )
                return arg;
        },

        // flatten nested jquery objects and arrays into a single dimension array
        flatten: function( arr ){
            return $.map( arr, function( member ){
                return member && member.jquery ? $.makeArray( member ) :
                member && member.length ? drag.flatten( member ) : member;
            });
        },

        // toggles text selection attributes ON (true) or OFF (false)
        textselect: function( bool ){
            $( document )[ bool ? "unbind" : "bind" ]("selectstart", drag.dontstart )
            .attr("unselectable", bool ? "off" : "on" )
            .css("MozUserSelect", bool ? "" : "none" );
        },

        // suppress "selectstart" and "ondragstart" events
        dontstart: function(){
            return false;
        },

        // a callback instance contructor
        callback: function(){}

    };

    // callback methods
    drag.callback.prototype = {
        update: function(){
            if ( $special.drop && this.available.length )
                $.each( this.available, function( i ){
                    $special.drop.locate( this, i );
                });
        }
    };

    // share the same special event configuration with related events...
    $special.draginit = $special.dragstart = $special.dragend = drag;
})( jQuery );

/**
* Mouse Wheel event normalization support.
* All third-party attributions implied.
*/

(function($) {

    var types = ['DOMMouseScroll', 'mousewheel'];

    $.event.special.wheelchange = {
        setup: function() {
            if ( this.addEventListener ) {
                for ( var i=types.length; i; ) {
                    this.addEventListener( types[--i], handler, false );
                }
            } else {
                this.onmousewheel = handler;
            }
        },

        teardown: function() {
            if ( this.removeEventListener ) {
                for ( var i=types.length; i; ) {
                    this.removeEventListener( types[--i], handler, false );
                }
            } else {
                this.onmousewheel = null;
            }
        }
    };

    $.fn.extend({
        wheelchange: function(fn) {
            return fn ? this.bind("wheelchange", fn) : this.trigger("wheelchange");
        },

        unwheelchange: function(fn) {
            return this.unbind("wheelchange", fn);
        }
    });


    function handler(event) {
        var orgEvent = event || window.event, args = [].slice.call( arguments, 1 ), delta = 0, returnValue = true, deltaX = 0, deltaY = 0;
        event = $.event.fix(orgEvent);
        event.type = "wheelchange";

        // Old school scrollwheel delta
        if ( event.wheelDelta ) {
            delta = event.wheelDelta/120;
        }
        if ( event.detail     ) {
            delta = -event.detail/3;
        }

        // New school multidimensional scroll (touchpads) deltas
        deltaY = delta;

        // Gecko
        if ( orgEvent.axis !== undefined && orgEvent.axis === orgEvent.HORIZONTAL_AXIS ) {
            deltaY = 0;
            deltaX = -1*delta;
        }

        // Webkit
        if ( orgEvent.wheelDeltaY !== undefined ) {
            deltaY = orgEvent.wheelDeltaY/120;
        }
        if ( orgEvent.wheelDeltaX !== undefined ) {
            deltaX = -1*orgEvent.wheelDeltaX/120;
        }

        // Add event and delta to the front of the arguments
        args.unshift(event, delta, deltaX, deltaY);

        return $.event.handle.apply(this, args);
    }

})(jQuery);
/*global Array: false, FusionCharts, window: false,
    FusionChartsDataFormats: false */

/**
 * FusionCharts JavaScript Library
 * SmartLabel component module.
 */

FusionCharts(['private', 'modules.renderer.js-smartlabel', function () {
    var global = this,
        lib = global.hcLib,
        isIE = lib.isIE,
        hasSVG = lib.hasSVG,
        doc = document,
        hasCanvas = !!doc.createElement("canvas").getContext,

    SmartLabelManager = (function () {

        var supportedStyle = lib.supportedStyle,

            supportedCanvasStyle = {
                fontWeight: 1,
                'font-weight': 1,
                fontStyle: 1,
                'font-style': 1,
                fontSize: 1,
                'font-size': 1,
                fontFamily: 1,
                'font-family': 1
            },
            //style that will be set at the creation of the text container and will
            // not be changed
            fixedStyle = {
                position: "absolute",
                top: "-9999em",
                whiteSpace: "nowrap",
                padding: "0px",
                width: "1px",
                height: "1px",
                overflow: "hidden"
            },
            ellipsesWidth = 0,
            //class name
            className = '_SmartLabel',
            className2 = '_SmartLabelBR',
            //have to modyfy sothat it can retrive classname among more
            classNameReg = /\b_SmartLabel\b/,
            classNameBrReg = /\b_SmartLabelBR\b/,
            spanAdditionRegx = /(\<[^\<\>]+?\>)|(&(?:[a-z]+|#[0-9]+);|.)/ig,
            spanAdditionReplacer = '$1<span class="'+ className + '">$2</span>',
            spanRemovalRegx = new RegExp('\\<span[^\\>]+?'+ className +'[^\\>]{0,}\\>(.*?)\\<\\/span\\>', 'ig'),
            xmlTagRegEx = new RegExp('<[^>][^<]*[^>]+>', 'i'),
            testStrAvg = "WgI",
            lineHeight = 0,
            minWidth = 0,
            avgCharWidth = 0,
            dotWidth = 0,
            containerIdIncriment = 0,
            spanTagString = 'span',
            ChildRetriverFN,
            ChildRetriverSTRING,
            noClassTesting;

        if (doc.getElementsByClassName) {
            ChildRetriverFN = 'getElementsByClassName';
            ChildRetriverSTRING = className;
            noClassTesting = true;
        }
        else {
            ChildRetriverFN = 'getElementsByTagName';
            ChildRetriverSTRING = spanTagString;
            noClassTesting = false;
        }

        //this function will create a container
        function createContainer (containerParent) {
            var body, container;

            if (containerParent && containerParent.offsetWidth && containerParent.offsetHeight) {
                if (containerParent.appendChild) {
                    containerParent.appendChild(container = document.createElement('div'));
                    container.className = "_SmartLabel_Container";
                    return container;
                }
            }
            else {
                body = document.getElementsByTagName('body')[0];
                //if body ready then Execuate the function otherwise add it at dom ready

                if (body && body.appendChild) {
                    ////create the text container element
                    container = document.createElement('div');
                    container.className = "_SmartLabel_Container";
                    containerIdIncriment += 1;
                    //append the container element
                    body.appendChild(container);
                    return container;
                }
            }
            return undefined;
        }

        function getNearestChar(text, maxWidth, container, context) {

            if (!text || !text.length) {
                return 0;
            }

            var difference,
                getWidth = context ? function (str) {
                    return context.measureText(str).width;
                } : function (str) {
                    container.innerHTML = str;
                    return container.offsetWidth;
                },
                charLen = 0,
                increment = 0,
                oriWidth = getWidth(text),
                avgWidth = oriWidth / text.length;

            difference = maxWidth;
            charLen = Math.ceil(maxWidth / avgWidth);

            if (oriWidth < maxWidth) {
                return (text.length - 1);
            }

            if (charLen > text.length) {
                difference = maxWidth - oriWidth;
                charLen = text.length;
            }

            while (difference > 0) {
                difference = maxWidth - getWidth(text.substr(0, charLen));
                increment = Math.floor(difference / avgWidth);
                if (increment) {
                    charLen += increment;
                } else {
                    return charLen;
                }
            }

            while (difference < 0) {
                difference = maxWidth - getWidth(text.substr(0, charLen));
                increment = Math.floor(difference / avgWidth);
                if (increment) {
                    charLen += increment;
                } else {
                    return charLen;
                }
            }
            return charLen;
        }

        function ContainerManager (parentContainer, maxContainers) {
            // Limit the maximum container between MAXC and MINC.
            maxContainers = maxContainers > 5 ? maxContainers : 5;
            maxContainers = maxContainers < 20 ? maxContainers : 20;

            this.maxContainers = maxContainers;
            this.first = null;
            this.last = null;
            this.containers = {};
            this.length = 0;
            this.rootNode = parentContainer;
        }

        ContainerManager.prototype = {
            get: function (style) {
                var o = this,
                    containers = o.containers,
                    len = o.length,
                    max = o.maxContainers,
                    diff,
                    key,
                    keyStr = '',
                    canvasStr = '',
                    isCanvas = false,
                    containerObj;


                if (canvasStr = o.getCanvasFont(style)) {
                    isCanvas = true;
                }

                for (key in supportedStyle) {
                    if (style[key] !== undefined) {
                        keyStr += supportedStyle[key] + ':' + style[key] + ';';
                    }
                }

                if (!keyStr) {
                    return false;
                }

                if (containers[keyStr]) {
                    // move to the beginning of the chain.
                    containerObj = containers[keyStr];
                    if (o.first !== containerObj) {
                        containerObj.prev && (containerObj.prev.next = containerObj.next);
                        containerObj.next && (containerObj.next.prev = containerObj.prev);
                        containerObj.next = o.start;
                        containerObj.prev = null;
                        (o.last === containerObj) && (o.last = containerObj.prev);
                        o.start = containerObj;
                    }
                }
                else {
                    if (len >= max) {
                        diff = (len - max) + 1;
                        // +1 is to remove an extra entry to make space for the new container to be added.
                        while (diff--) {
                            o.removeContainer(o.last);
                        }
                    }
                    containerObj = o.addContainer(keyStr, canvasStr);
                }

                return containerObj;
            },
            getCanvasFont: function (style) {
                var o = this,
                    key,
                    fontArr = [];

                    // Check if canvas tag is supported or not.
                    if (!hasCanvas) {
                        return false;
                    }

                    // Check if there are any non-canvas styles present.
                    // If present, return false.
                    /*for (key in style) {
                        if (!supportedCanvasStyle[key]) {
                            return false;
                        }
                    }*/

                    for (key in supportedCanvasStyle) {
                        if (style[key] !== undefined) {
                            fontArr.push(style[key]);
                        }
                    }

                    return fontArr.join(" ");
            },
            setMax: function (maxContainers) {
                var o = this,
                    len = o.length,

                    diff;

                maxContainers = maxContainers > 5 ? maxContainers : 5;
                maxContainers = maxContainers < 20 ? maxContainers : 20;

                if (maxContainers < len) {
                    

                    diff = len - maxContainers;
                    while (diff--) {
                        o.removeContainer(o.last);
                    }
                    o.length = maxContainers;
                }

                o.maxContainers = maxContainers;
            },
            addContainer: function (keyStr, canvasStr) {
                var o = this,
                    node,
                    context,
                    container;

                o.containers[keyStr] = container = {
                    next: null,
                    prev: null,
                    node: null,
                    ellipsesWidth: 0,
                    lineHeight: 0,
                    dotWidth: 0,
                    avgCharWidth: 4,
                    keyStr: keyStr,
                    canvasStr: canvasStr,
                    charCache: {}
                };

                // Since the container objects are arranged from
                // most recent to least recent order, we need to add the new object
                // at the beginning of the list.
                container.next = o.start;
                container.next && (container.next.prev = container);
                o.start = container;
                o.length += 1;

                node = container.node = doc.createElement("span");
                o.rootNode.appendChild(node);

                if (isIE && !hasSVG) {
                    node.style.setAttribute('cssText', keyStr);
                }
                else {
                    node.setAttribute('style', keyStr);
                }

                node.style.display = 'inline-block';

                node.innerHTML = testStrAvg; // A test string.
                container.lineHeight = node.offsetHeight;
                container.avgCharWidth = (node.offsetWidth / 3);

                if (canvasStr) {
                    node = container.canvas = doc.createElement("canvas");
                    node.style.height = node.style.width = "0px";
                    o.rootNode.appendChild(node);

                    container.context = context = node.getContext('2d');
                    context.font = canvasStr;

                    container.ellipsesWidth = context.measureText("...").width;
                    container.dotWidth = context.measureText(".").width;
                }
                else {
                    node.innerHTML = "...";
                    container.ellipsesWidth = node.offsetWidth;
                    node.innerHTML = ".";
                    container.dotWidth = node.offsetWidth;
                    node.innerHTML = "";
                }

                return container;

            },
            removeContainer: function (cObj) {
                var o = this,
                    keyStr = cObj.keyStr;

                if (!keyStr || !o.length || !cObj) {
                    return;
                }
                o.length -= 1;

                cObj.prev && (cObj.prev.next = cObj.next);
                cObj.next && (cObj.next.prev = cObj.prev);
                (o.first === cObj) && (o.first = cObj.next);
                (o.last === cObj) && (o.last = cObj.prev);

                delete o.containers[keyStr];
                delete cObj;
            }
        };

        ContainerManager.prototype.constructor = ContainerManager;

        /**
         * PORTING TO THE NEW SMARTLABEL.
         */
        function SmartLabelManager(id, container, useEllipses) {

            if (typeof id === "undefined" || typeof id === "object") {
                return;
            }

            this.id = id;
            var wrapper,
                prop;

            if (typeof container === "string") {
                container = doc.getElementById(container);
            }

            wrapper = this.parentContainer = createContainer(container);

            // Apply the fixed styles.
            for (prop in fixedStyle) {
                wrapper.style[prop] = fixedStyle[prop];
            }

            this.containerManager = new ContainerManager(wrapper, 10);

            this.showNoEllipses = !useEllipses;
            this.init = true;
            //create the blank style obj
            this.style = {};
            this.setStyle();
        }

        SmartLabelManager.prototype = {

            dispose: function () {
                var label = this,
                container = label.container,
                parentNode;

                if (!label.init) {
                    return;
                }

                if (container && (parentNode = container.parentNode)) {
                    parentNode.removeChild(container);
                    delete label.container;
                }

                delete label.id;
                delete label.style;
                delete label.parentContainer;
                delete label.showNoEllipses;
            },

            useEllipsesOnOverflow: function (useEllipses) {
                if (!this.init) {
                    return;
                }
                this.showNoEllipses = !useEllipses;
            },

            getSmartText : function (text, maxWidth, maxHeight, noWrap, containerParent) {
                if (!this.init) {
                    return false;
                }
                //fix for undefined or null string
                if (text === undefined || text === null) {
                    text = '';
                }

                //now smartify the string
                //create smart label object
                var sl = this,
                    smartLabel = {
                        text : text,
                        maxWidth : maxWidth,
                        maxHeight : maxHeight,
                        width : null,
                        height : null,
                        oriTextWidth : null,
                        oriTextHeight : null,
                        oriText : text,
                        isTruncated : false
                    },
                    hasHTMLTag = false,
                    len,
                    trimStr,
                    tempArr,
                    maxWidthWithEll,
                    toolText,
                    oriWidth,
                    oriHeight,
                    lastDash = -1,
                    lastSpace = -1,
                    lastIndexBroken = -1,
                    newCharIndex,
                    container = sl.container,
                    context = sl.context,
                    currStr,
                    strWidth = 0,
                    strHeight = 0,
                    nearestChar,
                    tempChar,
                    getWidth,
                    oriTextArr = [],
                    i = 0,
                    ellipsesStr = (sl.showNoEllipses ? "" : "..."),
                    lineHeight = sl.lineHeight;

                var fastTrim = function (str) {
                    str = str.replace(/^\s\s*/, '');
                    var ws = /\s/, i = str.length;

                    while (ws.test(str.charAt(i -= 1))) {};
                    return str.slice(0, i + 1);
                };

                getWidth = context ? function (str) {
                    return context.measureText(str).width;
                } : function (str) {
                    container.innerHTML = str;
                    return container.offsetWidth;
                };

                if (container) {
                    //To get text size set the text as innerhtml
                    container.innerHTML = text;

                    //add oriTextWidth & oriTextHeight
                    smartLabel.oriTextWidth = oriWidth = container.offsetWidth;
                    smartLabel.oriTextHeight = oriHeight = container.offsetHeight;

                    if (oriHeight <= maxHeight && oriWidth <= maxWidth) {
                        smartLabel.width = smartLabel.oriTextWidth = oriWidth;
                        smartLabel.height = smartLabel.oriTextHeight = oriHeight;
                        return smartLabel;
                    }

                    if (lineHeight > maxHeight) {
                        smartLabel.text = "";
                        smartLabel.width = smartLabel.oriTextWidth = 0;
                        smartLabel.height = smartLabel.oriTextHeight = 0;
                        return smartLabel;
                    }

                    text = fastTrim(text).replace(/(\s+)/g, " ");

                    hasHTMLTag = xmlTagRegEx.test(text);
                    //hasHTMLTag = false;
                    maxWidthWithEll = this.showNoEllipses ? maxWidth : (maxWidth - ellipsesWidth);

                    if (!hasHTMLTag) {

                        oriTextArr = text.split("");
                        len = oriTextArr.length;
                        trimStr = "", tempArr = [];
                        tempChar = oriTextArr[0];

                        if (sl.cache[tempChar]) {
                            minWidth = sl.cache[tempChar].width;
                        }
                        else {
                            minWidth = getWidth(tempChar);
                            sl.cache[tempChar] = {
                                width: minWidth
                            };
                        }

                        if (maxWidthWithEll > minWidth) {
                            tempArr = text.substr(0, getNearestChar(text, maxWidthWithEll, container, context)).split("");
                            i = tempArr.length;
                        }
                        else if (minWidth > maxWidth) {
                            smartLabel.text = "";
                            smartLabel.width = smartLabel.oriTextWidth = smartLabel.height = smartLabel.oriTextHeight = 0;
                            return smartLabel;
                        }
                        else if (ellipsesStr) {
                            maxWidthWithEll = maxWidth - (2 * dotWidth);
                            if (maxWidthWithEll > minWidth) {
                                ellipsesStr = "..";
                            } else {
                                maxWidthWithEll = maxWidth - dotWidth;
                                if (maxWidthWithEll > minWidth) {
                                    ellipsesStr = ".";
                                } else {
                                    maxWidthWithEll = 0;
                                    ellipsesStr = "";
                                }
                            }
                        }

                        strWidth = getWidth(tempArr.join(""));
                        strHeight = sl.lineHeight;

                        if (noWrap) {
                            for (; i < len; i += 1) {
                                tempChar = tempArr[i] = oriTextArr[i];
                                if (sl.cache[tempChar]) {
                                    minWidth = sl.cache[tempChar].width;
                                }
                                else {
                                    minWidth = getWidth(tempChar);
                                    sl.cache[tempChar] = {
                                        width: minWidth
                                    };
                                }
                                strWidth += minWidth;
                                currStr = tempArr.join("");
                                if (strWidth > maxWidthWithEll) {
                                    if (!trimStr) {
                                        trimStr = currStr.substr(0, currStr.length - 1);
                                    }
                                    if (strWidth > maxWidth) {
                                        container.innerHTML = smartLabel.text = fastTrim(trimStr) + ellipsesStr;
                                        smartLabel.tooltext = smartLabel.oriText;
                                        smartLabel.width = container.offsetWidth;
                                        smartLabel.height = container.offsetHeight;
                                        return smartLabel;
                                    }
                                }
                            }

                            smartLabel.text = container.innerHTML = currStr;
                            smartLabel.width = container.offsetWidth;
                            smartLabel.height = container.offsetHeight;
                            return smartLabel;

                        } else {

                            for (; i < len; i += 1) {

                                tempChar = tempArr[i] = oriTextArr[i];
                                if (tempChar === " " && !context) {
                                    tempChar = "&nbsp;";
                                }

                                if (sl.cache[tempChar]) {
                                    minWidth = sl.cache[tempChar].width;
                                }
                                else {
                                    minWidth = getWidth(tempChar);
                                    sl.cache[tempChar] = {
                                        width: minWidth
                                    };
                                }
                                strWidth += minWidth;
                                currStr = tempArr.join("");

                                if (strWidth > maxWidthWithEll) {
                                    if (!trimStr) {
                                        trimStr = currStr.substr(0, currStr.length - 1);
                                    }
                                    if (strWidth > maxWidth) {
                                        

                                        lastSpace = text.substr(0, tempArr.length).lastIndexOf(" ");
                                        lastDash = text.substr(0, tempArr.length).lastIndexOf("-");
                                        if (lastSpace > lastIndexBroken) {
                                            tempArr.splice(lastSpace, 1, "<br/>");
                                            lastIndexBroken = lastSpace;
                                            newCharIndex = lastSpace + 1;
                                        } else if (lastDash > lastIndexBroken) {
                                            if (lastDash === tempArr.length - 1) {
                                                tempArr.splice(lastDash, 1, "<br/>-");
                                            } else {
                                                tempArr.splice(lastDash, 1, "-<br/>");
                                            }
                                            lastIndexBroken = lastDash;
                                            newCharIndex = lastDash + 1;
                                        } else {
                                            tempArr.splice((tempArr.length - 1), 1, "<br/>" + oriTextArr[i]);
                                            newCharIndex = i;
                                        }
                                        container.innerHTML = currStr = tempArr.join("");
                                        strHeight += sl.lineHeight;
                                        if (strHeight > maxHeight) {
                                            smartLabel.text = container.innerHTML = fastTrim(trimStr) + ellipsesStr;
                                            smartLabel.tooltext = smartLabel.oriText;
                                            smartLabel.width = container.offsetWidth;
                                            smartLabel.height = container.offsetHeight;
                                            return smartLabel;
                                        } else {
                                            trimStr = null;
                                            nearestChar = getNearestChar(text.substr(newCharIndex), maxWidthWithEll, container, context);
                                            strWidth = getWidth(text.substr(newCharIndex, nearestChar || 1));
                                            if (tempArr.length < newCharIndex + nearestChar) {
                                                tempArr = tempArr.concat(text.substr(tempArr.length, newCharIndex + nearestChar - tempArr.length).split(""));
                                                i = tempArr.length - 1;
                                            }
                                        }
                                    }
                                }
                            }

                            smartLabel.text = container.innerHTML = currStr;
                            smartLabel.width = container.offsetWidth;
                            smartLabel.height = container.offsetHeight;
                            return smartLabel;
                        }
                    }
                    else {
                        toolText = text.replace(spanAdditionRegx, "$2");
                        text = text.replace(spanAdditionRegx, spanAdditionReplacer);
                        text = text.replace(/(\<br\s*\/*\>)/g,"<span class='" + [className, " ", className2].join("") + "'>$1</span>");

                        container.innerHTML = text;

                        var spanArr = container[ChildRetriverFN](ChildRetriverSTRING), x, y,
                        elem, chr, elemRightMostPoint, elemLowestPoint,
                        lastBR, removeFromIndex, removeFromIndexForEllipses,
                        characterArr = [], dashIndex = -1, spaceIndex = -1, elem, chr;

                        for (x = 0, y = spanArr.length; x < y; x += 1) {
                            elem = spanArr[x];
                            //chech whether this span is temporary inserted span from it's class
                            if (noClassTesting || classNameReg.test(elem.className)) {
                                chr = elem.innerHTML;
                                if (chr != "") {
                                    if (chr == " ") {
                                        spaceIndex = characterArr.length;
                                    } else if ( chr == "-") {
                                        dashIndex = characterArr.length;
                                    }

                                    characterArr.push({
                                        spaceIdx: spaceIndex,
                                        dashIdx: dashIndex,
                                        elem: elem
                                    });
                                    oriTextArr.push(chr);
                                }
                            }
                        }

                        delete spanArr;
                        i = 0;
                        len = characterArr.length;

                        minWidth = characterArr[0].elem.offsetWidth;

                        if (minWidth > maxWidth) {
                            smartLabel.text = "";
                            smartLabel.width = smartLabel.oriTextWidth = smartLabel.height = smartLabel.oriTextHeight = 0;
                            return smartLabel;
                        } else if (minWidth > maxWidthWithEll && !this.showNoEllipses) {

                            maxWidthWithEll = maxWidth - (2 * dotWidth);
                            if (maxWidthWithEll > minWidth) {
                                ellipsesStr = "..";
                            } else {
                                maxWidthWithEll = maxWidth - dotWidth;
                                if (maxWidthWithEll > minWidth) {
                                    ellipsesStr = ".";
                                } else {
                                    maxWidthWithEll = 0;
                                    ellipsesStr = "";
                                }
                            }
                        }

                        if (noWrap) {
                            for (; i < len; i += 1) {
                                elem = characterArr[i].elem;
                                elemRightMostPoint = elem.offsetLeft + elem.offsetWidth;

                                if (elemRightMostPoint > maxWidthWithEll) {
                                    if (!removeFromIndexForEllipses) {
                                        removeFromIndexForEllipses = i;
                                    }
                                    if (container.offsetWidth > maxWidth) {
                                        removeFromIndex = i;
                                        i = len;
                                    }
                                }
                            }
                        } else {
                            for (; i < len; i += 1) {
                                elem = characterArr[i].elem;
                                elemLowestPoint = elem.offsetHeight + elem.offsetTop;
                                elemRightMostPoint = elem.offsetLeft + elem.offsetWidth;

                                lastBR = null;

                                if (elemRightMostPoint > maxWidthWithEll) {
                                    if (!removeFromIndexForEllipses) {
                                        removeFromIndexForEllipses = i;
                                    }

                                    if (elemRightMostPoint > maxWidth) {
                                        lastSpace = characterArr[i].spaceIdx;
                                        lastDash = characterArr[i].dashIdx;
                                        if (lastSpace > lastIndexBroken) {
                                            characterArr[lastSpace].elem.innerHTML = "<br/>";
                                            lastIndexBroken = lastSpace;
                                        } else if (lastDash > lastIndexBroken) {
                                            if (lastDash === i) { // in case the overflowing character itself is the '-'
                                                characterArr[lastDash].elem.innerHTML = "<br/>-";
                                            } else {
                                                characterArr[lastDash].elem.innerHTML = "-<br/>";
                                            }
                                            lastIndexBroken = lastDash;
                                        } else {
                                            elem.parentNode.insertBefore(lastBR = document.createElement('br'), elem);
                                        }

                                        //check whether this break made current element outside the area height
                                        if ((elem.offsetHeight + elem.offsetTop) > maxHeight) {
                                            //remove the lastly inserted line break
                                            if (lastBR) {
                                                lastBR.parentNode.removeChild(lastBR);
                                            }
                                            else if (lastIndexBroken === lastDash) {
                                                characterArr[lastDash].elem.innerHTML = "-";
                                            } else {
                                                characterArr[lastSpace].elem.innerHTML = " ";
                                            }
                                            removeFromIndex = i;
                                            //break the looping condition
                                            i = len;
                                        } else {
                                            removeFromIndexForEllipses = null;
                                        }
                                    }

                                } else {
                                    //check whether this break made current element outside the area height
                                    if (elemLowestPoint > maxHeight) {
                                        removeFromIndex = i;
                                        i = len;
                                    }
                                }
                            }
                        }

                        if (removeFromIndex < len) {
                            //set the trancated property of the smartlabel
                            smartLabel.isTruncated = true;

                            

                            removeFromIndexForEllipses = removeFromIndexForEllipses ?
                            removeFromIndexForEllipses : removeFromIndex;

                            for (i = len - 1; i >= removeFromIndexForEllipses; i -= 1) {
                                elem = characterArr[i].elem;
                                //chech whether this span is temporary inserted span from it's class
                                elem.parentNode.removeChild(elem);
                            }

                            for (; i >= 0; i -= 1) {
                                elem = characterArr[i].elem;
                                if (classNameBrReg.test(elem.className)) {
                                    //chech whether this span is temporary inserted span from it's class
                                    elem.parentNode.removeChild(elem);
                                } else {
                                    i = 0;
                                }
                            }
                        }

                        //get the smart text
                        smartLabel.text = container.innerHTML.replace(spanRemovalRegx, '$1');
                        if (smartLabel.isTruncated) {
                            smartLabel.text += ellipsesStr;
                            smartLabel.tooltext = toolText;
                        }
                    }

                    smartLabel.height = container.offsetHeight;
                    smartLabel.width = container.offsetWidth;

                    return smartLabel;
                }
                else {
                    smartLabel.error = new Error('Body Tag Missing!');
                    return smartLabel;
                }
            },

            setStyle : function (style) {

                if (!this.init) {
                    return false;
                }
                var key,
                    sCont,
                    styleStr = '';

                if (style === this.style && !this.styleNotSet) {
                    return;
                }

                if (!style) {
                    style = this.style;
                }

                this.style = style;
                this.containerObj = sCont = this.containerManager.get(style);

                if (this.containerObj) {
                    this.container = sCont.node;
                    this.context = sCont.context;
                    this.cache = sCont.charCache;
                    this.lineHeight = sCont.lineHeight;
                    ellipsesWidth = sCont.ellipsesWidth;
                    dotWidth =  sCont.dotWidth;
                    avgCharWidth = sCont.dotWidth;
                    this.styleNotSet = false;
                } else {
                    this.styleNotSet = true;
                }
            },

            getTextSize : function (text, maxWidth, maxHeight, noWrap) {
                if (!this.init) {
                    return false;
                }
                var smartLabel = {
                        text : text,
                        width : null,
                        height : null,
                        oriTextWidth : null,
                        oriTextHeight : null,
                        isTruncated : false
                    },
                    container = this.container;

                if (container) {
                    //To get text size set the text as innerhtml
                    container.innerHTML = text;
                    //add oriTextWidth & oriTextHeight
                    smartLabel.oriTextWidth = container.offsetWidth;
                    smartLabel.oriTextHeight = container.offsetHeight;
                    smartLabel.width = Math.min(smartLabel.oriTextWidth, maxWidth);
                    smartLabel.height = Math.min(smartLabel.oriTextHeight, maxHeight);
                    if (smartLabel.width < smartLabel.oriTextWidth || smartLabel.height < smartLabel.oriTextHeight) {
                        smartLabel.isTruncated = true;
                    }
                }
                return smartLabel;
            },

            getOriSize: function(text) {
                if (!this.init) {
                    return false;
                }

                var smartLabel = {
                        text : text,
                        width : null,
                        height : null
                    },
                    container = this.container;

                if (container) {
                    //To get text size set the text as innerhtml
                    container.innerHTML = text;
                    //add oriTextWidth & oriTextHeight
                    smartLabel.width = container.offsetWidth;
                    smartLabel.height = container.offsetHeight;
                }
                return smartLabel;
            }
        };

        SmartLabelManager.prototype.constructor = SmartLabelManager;
        return SmartLabelManager;
    }());

    lib.SmartLabelManager = SmartLabelManager;

}]);/*jslint forin: true, regexp: true, todo: true, white: false, browser: true,
 sloppy: true, white: true, eqeq: false, newcap: true, nomen: true */
/*global window: true, FusionCharts, parseFloat:true, Math:true */

/**
 * FusionCharts JavaScript Library
 * Number formatter module
 */
FusionCharts(['private', 'modules.renderer.js-numberformatter', function () {
    var global = this,
        lib = global.hcLib,
        pluckNumber = lib.pluckNumber,
        extend2 = lib.extend2,
        getValidValue = lib.getValidValue,
        pluckNumber = lib.pluckNumber,
        pluck = lib.pluck,
        getFirstValue = lib.getFirstValue,
        mathAbs = Math.abs,
        mathPow = Math.pow,
        mathRound = Math.round,
        ONESTRING = '1',
        BLANK = '',
        ZEROSTRING = '0',
        DECIMALSTRING = ".",
        COMMASTRING = ',',
        MINUSSTR = "-",
        DECIMALSEPSTR = '\d{',
        CLOSEBRACESSTR = '}',

        regescape = function(text) {
            return text && text.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, "\\$&");
        };


//NumberFomatter
 lib.NumberFormatter = (function () {

        

        var TWOSTRING = "2",
        AUTOSTRING = 'auto',

        numberFormatDefaults = {
            formatnumber: ONESTRING,
            formatnumberscale: ONESTRING,
            defaultnumberscale: BLANK,
            numberscaleunit: ['K', 'M'],//'K,M',
            numberscalevalue: [1000, 1000], //'1000,1000',
            numberprefix: BLANK,
            numbersuffix: BLANK,
            // Decimals default value is different in different charts
            decimals: BLANK,
            forcedecimals: ZEROSTRING,
            yaxisvaluedecimals: TWOSTRING,
            decimalseparator: DECIMALSTRING,
            thousandseparator: COMMASTRING,
            // thousandSeparatorPosition new attribute added in numberFormatter
            // this defines the placement of thousandSeparator, defaultValue = 3
            // accepts comma separated value
            thousandseparatorposition: [3],
            indecimalseparator: BLANK,
            inthousandseparator: BLANK,
            sformatnumber: ONESTRING,
            sformatnumberscale: ZEROSTRING,
            sdefaultnumberscale: BLANK,
            snumberscaleunit: ['K','M'],
            snumberscalevalue: [1000, 1000],
            snumberprefix: BLANK,
            snumbersuffix: BLANK,
            sdecimals: TWOSTRING,
            sforcedecimals: ZEROSTRING,
            syaxisvaluedecimals: TWOSTRING,

            xFormatNumber : ZEROSTRING,
            xFormatNumberScale : ZEROSTRING,
            xDefaultNumberScale : BLANK,
            xNumberScaleUnit : ['K','M'],
            xNumberScaleValue : [1000, 1000],
            xNumberPrefix : BLANK,
            xNumberSuffix : BLANK
        },

        numberFormatOverrides = {
            mscombidy2d: {
                formatnumberscale: ONESTRING
            }
        },

        /*
         *  NumberFormatter function
         **/
        NumberFormatter = function (chartObj, chartAPI, isMultyAxis) {
            var numberscaleunit,
                snumberscaleunit, xnumberscaleunit, ticknumberscaleunit, ynumberscaleunit,
                numberscalevalue, xnumberscalevalue, ticknumberscalevalue, ynumberscalevalue,
                chartName = chartAPI.name,
                // chartSpecificConf
                csConf = extend2({}, numberFormatDefaults),//,
                thousandseparatorposition,
                thSepPosREGX = '$',
                snumberscalevalue,
                paramLabels,
                paramLabels2,
                param1,
                param2,
                baseConf,
                overrideConf = numberFormatOverrides[chartName];

            if (overrideConf) {
                csConf = extend2(csConf, overrideConf);
            }
            this.csConf = csConf;
            this.chartAPI = chartAPI;

            // Converting user given numberScaleUnit into array
            if (getValidValue(chartObj.numberscaleunit)) {
                numberscaleunit = chartObj.numberscaleunit.split(COMMASTRING);
            }
            if ((snumberscaleunit = getValidValue(chartObj.snumberscaleunit, chartObj.numberscaleunit))) {
                snumberscaleunit = snumberscaleunit.split(COMMASTRING);
            }
            if ((xnumberscaleunit = getValidValue(chartObj.xnumberscaleunit, chartObj.numberscaleunit))) {
                xnumberscaleunit = xnumberscaleunit.split(COMMASTRING);
            }
            if ((ticknumberscaleunit = getValidValue(chartObj.ticknumberscaleunit, chartObj.numberscaleunit))) {
                ticknumberscaleunit = ticknumberscaleunit.split(COMMASTRING);
            }
            if ((ynumberscaleunit = getValidValue(chartObj.ynumberscaleunit, chartObj.numberscaleunit))) {
                ynumberscaleunit = ynumberscaleunit.split(COMMASTRING);
            }

            // Converting user given numberScaleValue into array
            if (getValidValue(chartObj.numberscalevalue)) {
                numberscalevalue = chartObj.numberscalevalue.split(COMMASTRING);
            }
            if ((snumberscalevalue = getValidValue(chartObj.snumberscalevalue, chartObj.numberscalevalue))) {
                snumberscalevalue = snumberscalevalue.split(COMMASTRING);
            }
            if ((xnumberscalevalue = getValidValue(chartObj.xnumberscalevalue, chartObj.numberscalevalue))) {
                xnumberscalevalue = xnumberscalevalue.split(COMMASTRING);
            }
            if ((ticknumberscalevalue = getValidValue(chartObj.ticknumberscalevalue, chartObj.numberscalevalue))) {
                ticknumberscalevalue = ticknumberscalevalue.split(COMMASTRING);
            }
            if ((ynumberscalevalue = getValidValue(chartObj.ynumberscalevalue, chartObj.numberscalevalue))) {
                ynumberscalevalue = ynumberscalevalue.split(COMMASTRING);
            }
            // Converting user given numberScaleValue into array
            if(getValidValue(chartObj.thousandseparatorposition)) {
                thousandseparatorposition = chartObj.thousandseparatorposition.split(COMMASTRING);
                var length = thousandseparatorposition.length, value,
                lastValue = numberFormatDefaults.thousandseparatorposition[0];
                // Filtering the user given values
                while (length--) {
                    value = parseInt(thousandseparatorposition[length], 10);
                    if (!(value > 0)) {
                        value = lastValue;
                    }
                    lastValue = thousandseparatorposition[length] = value;
                    //thSepPosREGX = DECIMALSEPSTR + value + CLOSEBRACESSTR + thSepPosREGX;
                }
            }

            if (!chartAPI) {
                chartAPI = {};
            }

            var scaleRecursively = pluckNumber(chartObj.scalerecursively, 0),
            sScaleRecursively = pluckNumber(chartObj.sscalerecursively, scaleRecursively),
            xScaleRecursively = pluckNumber(chartObj.xscalerecursively, scaleRecursively),
            maxScaleRecursion = pluckNumber(chartObj.maxscalerecursion, -1),
            sMaxScaleRecursion = pluckNumber(chartObj.smaxscalerecursion, maxScaleRecursion),
            xMaxScaleRecursion = pluckNumber(chartObj.xmaxscalerecursion, maxScaleRecursion),
            scaleSeparator = getValidValue(chartObj.scaleseparator, ' '),
            sScaleSeparator = getValidValue(chartObj.sscaleseparator, scaleSeparator),
            xScaleSeparator = getValidValue(chartObj.xscaleseparator, scaleSeparator);
            if (!maxScaleRecursion) {
                maxScaleRecursion = -1;
            }

            //create base number formater
            this.baseConf = baseConf = {
                cacheStore: [],
                formatnumber        : pluck(chartObj.formatnumber, chartAPI.formatnumber, csConf.formatnumber),
                formatnumberscale   : pluck(chartObj.formatnumberscale, chartAPI.formatnumberscale, csConf.formatnumberscale),
                defaultnumberscale  : getFirstValue(chartObj.defaultnumberscale, chartAPI.defaultnumberscale, csConf.defaultnumberscale),
                numberscaleunit     : pluck(numberscaleunit, chartAPI.numberscaleunit, csConf.numberscaleunit).concat(),
                numberscalevalue    : pluck(numberscalevalue, chartAPI.numberscalevalue, csConf.numberscalevalue).concat(),
                numberprefix        : getFirstValue(chartObj.numberprefix, chartAPI.numberprefix, csConf.numberprefix),
                numbersuffix        : getFirstValue(chartObj.numbersuffix, chartAPI.numbersuffix, csConf.numbersuffix),
                decimalprecision    : parseInt(chartObj.decimals === AUTOSTRING ? csConf.decimalprecision :
                    pluck(chartObj.decimals, chartObj.decimalprecision, chartAPI.decimals, csConf.decimals, chartAPI.decimalprecision, csConf.decimalprecision), 10),
                forcedecimals       : pluck(chartObj.forcedecimals, chartAPI.forcedecimals, csConf.forcedecimals),
                decimalseparator    : pluck(chartObj.decimalseparator, chartAPI.decimalseparator, csConf.decimalseparator),
                thousandseparator   : pluck(chartObj.thousandseparator, chartAPI.thousandseparator, csConf.thousandseparator),
                thousandseparatorposition : pluck(thousandseparatorposition, chartAPI.thousandseparatorposition, csConf.thousandseparatorposition),
                indecimalseparator  : getFirstValue(chartObj.indecimalseparator, chartAPI.indecimalseparator, csConf.indecimalseparator),
                inthousandseparator : getFirstValue(chartObj.inthousandseparator, chartAPI.inthousandseparator, csConf.inthousandseparator),
                scalerecursively: scaleRecursively,
                maxscalerecursion: maxScaleRecursion,
                scaleseparator: scaleSeparator
            };

            //create the regex for inthousendseperator
            if (getValidValue(baseConf.inthousandseparator)) {
                this.baseConf._REGinthousandseparator = new RegExp(regescape(baseConf.inthousandseparator), 'g');
            }
            if (getValidValue(baseConf.indecimalseparator)) {
                this.baseConf._REGindecimalseparator = new RegExp(regescape(baseConf.indecimalseparator));
            }

            this.Y = [];

            if (isMultyAxis){
                //do all MultyAxis specific calculation
            }
            else {

                // Parameters passed with this function
                paramLabels = {
                    cacheStore: [],
                    formatnumber: baseConf.formatnumber,
                    formatnumberscale: baseConf.formatnumberscale,
                    //defaultnumberscale  : pluck(chartObj.defaultnumberscale, (numberFormatOverrides[chartName] && numberFormatOverrides[chartName].defaultnumberscale)) || numberFormatDefaults.defaultnumberscale,
                    defaultnumberscale: baseConf.defaultnumberscale,
                    numberscaleunit: baseConf.numberscaleunit.concat(),
                    numberscalevalue: baseConf.numberscalevalue.concat(),
                    numberprefix: baseConf.numberprefix,
                    numbersuffix: baseConf.numbersuffix,
                    decimalprecision: baseConf.decimalprecision,
                    forcedecimals: baseConf.forcedecimals,
                    decimalseparator: baseConf.decimalseparator,
                    thousandseparator: baseConf.thousandseparator,
                    thousandseparatorposition: baseConf.thousandseparatorposition,
                    indecimalseparator: baseConf.indecimalseparator,
                    inthousandseparator: baseConf.inthousandseparator,
                    scalerecursively: scaleRecursively,
                    maxscalerecursion: maxScaleRecursion,
                    scaleseparator: scaleSeparator
                };
                // scaleRecursively will use only by Widgets.
                if (!chartAPI.useScaleRecursively || ((paramLabels.numberscalevalue && paramLabels.numberscalevalue.length) !=
                        (paramLabels.numberscaleunit && paramLabels.numberscaleunit.length))) {
                    paramLabels.scalerecursively = scaleRecursively = 0;
                }

                param1 = {
                    cacheStore: [],
                    formatnumber: paramLabels.formatnumber,
                    formatnumberscale: paramLabels.formatnumberscale,
                    defaultnumberscale: paramLabels.defaultnumberscale,
                    numberscaleunit: paramLabels.numberscaleunit.concat(),
                    numberscalevalue: paramLabels.numberscalevalue.concat(),
                    numberprefix: paramLabels.numberprefix,
                    numbersuffix: paramLabels.numbersuffix,
                    decimalprecision: parseInt(pluck(chartObj.yaxisvaluedecimals, paramLabels.decimalprecision, 2)),
                    forcedecimals: pluck(chartObj.forceyaxisvaluedecimals, paramLabels.forcedecimals),
                    decimalseparator: paramLabels.decimalseparator,
                    thousandseparator: paramLabels.thousandseparator,
                    thousandseparatorposition: paramLabels.thousandseparatorposition.concat(),
                    indecimalseparator: paramLabels.indecimalseparator,
                    inthousandseparator: paramLabels.inthousandseparator,
                    scalerecursively: scaleRecursively,
                    maxscalerecursion: maxScaleRecursion,
                    scaleseparator: scaleSeparator
                };


                // Parameters for sScale (secondary axis)
                param2 = {
                    cacheStore: [],
                    formatnumber: pluck(chartObj.sformatnumber, chartAPI.sformatnumber, numberFormatDefaults.sformatnumber),
                    formatnumberscale: pluck(chartObj.sformatnumberscale, chartAPI.sformatnumberscale, numberFormatDefaults.sformatnumberscale),
                    defaultnumberscale: getFirstValue(chartObj.sdefaultnumberscale, chartAPI.sdefaultnumberscale, paramLabels.defaultnumberscale),
                    numberscaleunit: pluck(snumberscaleunit, chartAPI.snumberscaleunit, numberFormatDefaults.snumberscaleunit).concat(),
                    numberscalevalue: pluck(snumberscalevalue, chartAPI.snumberscalevalue, numberFormatDefaults.snumberscalevalue).concat(),
                    numberprefix: getFirstValue(chartObj.snumberprefix, chartAPI.snumberprefix, numberFormatDefaults.snumberprefix),
                    numbersuffix: getFirstValue(chartObj.snumbersuffix, chartAPI.snumbersuffix, numberFormatDefaults.snumbersuffix),
                    decimalprecision: parseInt(pluck(chartObj.syaxisvaluedecimals, chartObj.sdecimals, chartObj.decimals, chartAPI.sdecimals, numberFormatDefaults.sdecimals), 10),
                    forcedecimals: pluck(chartObj.forcesyaxisvaluedecimals, chartObj.sforcedecimals, chartObj.forcedecimals, chartAPI.sforcedecimals, numberFormatDefaults.sforcedecimals),
                    decimalseparator: pluck(chartObj.decimalseparator, chartAPI.decimalseparator, numberFormatDefaults.decimalseparator),
                    thousandseparator: pluck(chartObj.thousandseparator, chartAPI.thousandseparator, numberFormatDefaults.thousandseparator),
                    thousandseparatorposition: paramLabels.thousandseparatorposition.concat(),
                    indecimalseparator: pluck(chartObj.indecimalseparator, chartAPI.indecimalseparator, numberFormatDefaults.indecimalseparator),
                    inthousandseparator: pluck(chartObj.inthousandseparator, chartAPI.inthousandseparator, numberFormatDefaults.inthousandseparator),
                    scalerecursively: sScaleRecursively,
                    maxscalerecursion: sMaxScaleRecursion,
                    scaleseparator: sScaleSeparator
                };

                // MultiAxisLine chart secondary yAxis numberFormatter attribute mapping wrt primary yAxis
//                if (/^(multiaxisline)$/.test(chartName)) {
//                    param2.formatnumber = pluck(chartObj.sformatnumber, chartObj.formatnumber, chartAPI.sformatnumber, numberFormatDefaults.sformatnumber);
//                    param2.formatnumberscale = pluck(chartObj.sformatnumberscale, chartObj.formatnumberscale, chartAPI.sformatnumberscale, numberFormatDefaults.sformatnumberscale);
//                    param2.defaultnumberscale = getFirstValue(chartObj.sdefaultnumberscale, chartObj.defaultnumberscale, chartAPI.sdefaultnumberscale, paramLabels.defaultnumberscale);
//                    param2.numberprefix = getFirstValue(chartObj.snumberprefix, chartObj.numberprefix, chartAPI.snumberprefix, numberFormatDefaults.snumberprefix);
//                    param2.numbersuffix = getFirstValue(chartObj.snumbersuffix, chartObj.numbersuffix, chartAPI.snumbersuffix, numberFormatDefaults.snumbersuffix);
//                    param2.decimalprecision = parseInt(pluck(chartObj.syaxisvaluedecimals, chartObj.yaxisvaluedecimals, chartObj.sdecimals, chartObj.decimals, chartAPI.sdecimals, numberFormatDefaults.sdecimals), 10);
//                    param2.forcedecimals = pluck(chartObj.forcesyaxisvaluedecimals, chartObj.forceyaxisvaluedecimals, chartObj.sforcedecimals, chartObj.forcedecimals, chartAPI.sforcedecimals, numberFormatDefaults.sforcedecimals);
//                }
                // For secondary yAxis datalabels
                paramLabels2 = extend2({}, param2);
                paramLabels2.decimalprecision = parseInt(pluck(chartObj.sdecimals, chartObj.decimals, chartObj.syaxisvaluedecimals, chartAPI.sdecimals, numberFormatDefaults.sdecimals), 10);
                paramLabels2.forcedecimals = pluck(chartObj.sforcedecimals, chartObj.forcedecimals, chartObj.forcesyaxisvaluedecimals, chartAPI.sforcedecimals, numberFormatDefaults.sforcedecimals);
                //add new cache store
                paramLabels2.cacheStore = [];

                // scaleRecursively will use only by Widgets.
                if (!chartAPI.useScaleRecursively || ((param2.numberscalevalue && param2.numberscalevalue.length) !=
                        (param2.numberscaleunit && param2.numberscaleunit.length))) {
                    param2.scalerecursively = sScaleRecursively = 0;
                }



                

                if (/^(bubble|scatter|selectscatter)$/.test(chartName)) {
                    param1.formatnumber = pluck(chartObj.yformatnumber, param1.formatnumber);
                    param1.formatnumberscale = pluck(chartObj.yformatnumberscale, param1.formatnumberscale);
                    param1.defaultnumberscale = getFirstValue(chartObj.ydefaultnumberscale, param1.defaultnumberscale);
                    param1.numberscaleunit = pluck(ynumberscaleunit, param1.numberscaleunit);
                    param1.numberscalevalue = pluck(ynumberscalevalue, param1.numberscalevalue);
                    param1.numberprefix = pluck(chartObj.ynumberprefix, param1.numberprefix);
                    param1.numbersuffix = pluck(chartObj.ynumbersuffix, param1.numbersuffix);
                    //
                    paramLabels.formatnumber = pluck(chartObj.yformatnumber, paramLabels.formatnumber);
                    paramLabels.formatnumberscale = pluck(chartObj.yformatnumberscale, paramLabels.formatnumberscale);
                    paramLabels.defaultnumberscale = getFirstValue(chartObj.ydefaultnumberscale, paramLabels.defaultnumberscale);
                    paramLabels.numberscaleunit = pluck(chartObj.ynumberscaleunit, paramLabels.numberscaleunit.concat());
                    paramLabels.numberscalevalue = pluck(chartObj.ynumberscalevalue, paramLabels.numberscalevalue.concat());
                    paramLabels.numberprefix = pluck(chartObj.ynumberprefix, paramLabels.numberprefix);
                    paramLabels.numbersuffix = pluck(chartObj.ynumbersuffix, paramLabels.numbersuffix);
                }

                // Adding special attributes for secondary yAxis
                if (/^(mscombidy2d|mscombidy3d)$/.test(chartName)) {
                    param2.formatnumberscale = pluckNumber(chartObj.sformatnumberscale, ONESTRING);
                }

                // Fix for some chart decimals default value different
                if (/^(pie2d|pie3d|doughnut2d|doughnut3d|marimekko|pareto2d|pareto3d)$/.test(chartName)) {
                    paramLabels.decimalprecision = pluck(chartObj.decimals, TWOSTRING);
                }

                // Adjusting numberScaleValue and numberScaleUnit array to be use in
                // the calculation of scaleRecursively
                if (scaleRecursively) {
                    paramLabels.numberscalevalue.push(1);
                    paramLabels.numberscaleunit.unshift(paramLabels.defaultnumberscale);

                    param1.numberscalevalue.push(1);
                    param1.numberscaleunit.unshift(param1.defaultnumberscale);
                }
                if (sScaleRecursively) {
                    param2.numberscalevalue.push(1);
                    param2.numberscaleunit.unshift(param2.defaultnumberscale);

                    paramLabels2.numberscalevalue.push(1);
                    paramLabels2.numberscaleunit.unshift(paramLabels2.defaultnumberscale);
                }

               this.Y[0] = {
                   yAxisLabelConf: param1,
                   dataLabelConf: paramLabels
               };
               this.Y[1] = {
                   yAxisLabelConf: param2,
                   dataLabelConf: paramLabels2
               } ;
               //for backword compatibility issue
               

               this.paramLabels = paramLabels;
               this.param1 = param1;
               this.param2 = param2;
               this.paramLabels2 = paramLabels2;
            }

            


            //xAxis Label formatter for scatter type X-y plot charts
             // Parameters for xScale
            this.paramX = {
                cacheStore: [],
                formatnumber: pluck(chartObj.xformatnumber, baseConf.formatnumber),
                formatnumberscale: pluck(chartObj.xformatnumberscale, baseConf.formatnumberscale),
                defaultnumberscale: getFirstValue(chartObj.xdefaultnumberscale, baseConf.defaultnumberscale),
                numberscaleunit: pluck(xnumberscaleunit, baseConf.numberscaleunit.concat()),
                numberscalevalue: pluck(xnumberscalevalue, baseConf.numberscalevalue.concat()),
                numberprefix: pluck(chartObj.xnumberprefix, baseConf.numberprefix),
                numbersuffix: pluck(chartObj.xnumbersuffix, baseConf.numbersuffix),
                decimalprecision: parseInt(pluck(chartObj.xaxisvaluedecimals, chartObj.xaxisvaluesdecimals, baseConf.decimalprecision, 2), 10),
                forcedecimals: pluck(chartObj.forcexaxisvaluedecimals, 0),
                decimalseparator: baseConf.decimalseparator,
                thousandseparator: baseConf.thousandseparator,
                thousandseparatorposition: baseConf.thousandseparatorposition.concat(),
                indecimalseparator: baseConf.indecimalseparator,
                inthousandseparator: baseConf.inthousandseparator,
                scalerecursively: xScaleRecursively,
                maxscalerecursion: xMaxScaleRecursion,
                scaleseparator: xScaleSeparator
            };
            // scaleRecursively will use only by Widgets.
            if (!chartAPI.useScaleRecursively || ((this.paramX.numberscalevalue && this.paramX.numberscalevalue.length) !=
                    (this.paramX.numberscaleunit && this.paramX.numberscaleunit.length))) {
                this.paramX.scalerecursively = xScaleRecursively = 0;
            }

            if (xScaleRecursively) {
                this.paramX.numberscalevalue.push(1);
                this.paramX.numberscaleunit.unshift(this.paramX.defaultnumberscale);
            }

            this.paramScale = {
                cacheStore: [],
                formatnumber: pluck(chartObj.tickformatnumber, baseConf.formatnumber),
                formatnumberscale: pluck(chartObj.tickformatnumberscale, baseConf.formatnumberscale),
                defaultnumberscale: getFirstValue(chartObj.tickdefaultnumberscale, baseConf.defaultnumberscale),
                numberscaleunit: pluck(ticknumberscaleunit, baseConf.numberscaleunit.concat()),
                numberscalevalue: pluck(ticknumberscalevalue, baseConf.numberscalevalue.concat()),
                numberprefix: pluck(chartObj.ticknumberprefix, baseConf.numberprefix),
                numbersuffix: pluck(chartObj.ticknumbersuffix, baseConf.numbersuffix),
                decimalprecision: parseInt(pluck(chartObj.tickvaluedecimals, baseConf.decimalprecision, TWOSTRING)),
                forcedecimals: pluck(chartObj.forcetickvaluedecimals, baseConf.forcedecimals, 0),
                decimalseparator: baseConf.decimalseparator,
                thousandseparator: baseConf.thousandseparator,
                thousandseparatorposition: baseConf.thousandseparatorposition.concat(),
                indecimalseparator: baseConf.indecimalseparator,
                inthousandseparator: baseConf.inthousandseparator,
                scalerecursively: scaleRecursively,
                maxscalerecursion: maxScaleRecursion,
                scaleseparator: scaleSeparator
            };

            // Adjusting numberScaleValue and numberScaleUnit array to be use in
            // the calculation of scaleRecursively
            if (scaleRecursively) {
                this.paramScale.numberscalevalue.push(1);
                this.paramScale.numberscaleunit.unshift(this.paramScale.defaultnumberscale);
            }

            //dateTime parser conf
            this.timeConf = {
                inputDateFormat: pluck(chartObj.inputdateformat, chartObj.dateformat, 'mm/dd/yyyy'),
                outputDateFormat: pluck(chartObj.outputdateformat, chartObj.inputdateformat, chartObj.dateformat, 'mm/dd/yyyy'),
                days: ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'],
                months: ['January', 'February', 'March', 'April', 'May', 'June', 'July', 'August', 'September', 'October', 'November', 'December'],
                daySuffix: ['', 'st', 'nd', 'rd', 'th', 'th', 'th', 'th', 'th', 'th', 'th', 'th', 'th', 'th', 'th', 'th', 'th', 'th', 'th', 'th', 'th', 'st', 'nd', 'rd', 'th', 'th', 'th', 'th', 'th', 'th', 'th', 'st']
            };
        };

        NumberFormatter.prototype = {
            cleaneValueCacheStore: {},
            percentStrCacheStore: {},
            //delete all object ref and cache store
            dispose: function () {
                var Numberformatter = this,
                        l = (Numberformatter.Y && Numberformatter.Y.length) || 0,
                        i = 0;
                //delete y axis params
                if (Numberformatter.Y){
                   delete Numberformatter.Y;
                }
                //delete cleaneValueCacheStore
                if (Numberformatter.cleaneValueCacheStore){
                   delete Numberformatter.cleaneValueCacheStore;
                }
                //delete cleaneValueCacheStore
                if (Numberformatter.percentStrCacheStore){
                   delete Numberformatter.percentStrCacheStore;
                }
                //delete baseConf
                if (Numberformatter.paramLabels){
                   delete Numberformatter.paramLabels;
                }
                //delete baseConf
                if (Numberformatter.param1){
                   delete Numberformatter.param1;
                }
                //delete baseConf
                if (Numberformatter.param2){
                   delete Numberformatter.param2;
                }
                //delete baseConf
                if (Numberformatter.paramLabels2){
                   delete Numberformatter.paramLabels2;
                }
                //delete baseConf
                if (Numberformatter.csConf){
                   delete Numberformatter.csConf;
                }
                //delete baseConf
                if (Numberformatter.chartAPI){
                   delete Numberformatter.chartAPI;
                }
                //delete baseConf
                if (Numberformatter.baseConf){
                   delete Numberformatter.baseConf;
                }
                //delete timeConf
                if (Numberformatter.timeConf){
                   delete Numberformatter.timeConf;
                }
                //delete paramX
                if (Numberformatter.paramX){
                   delete Numberformatter.paramX;
                }
                //delete paramScale
                if (Numberformatter.paramScale){
                   delete Numberformatter.paramScale;
                }
            },
            parseMLAxisConf: function (axisObj, index){
                var baseConf = this.baseConf,
                    csConf = this.csConf,
                    chartAPI = this.chartAPI,
                    scaleRecursively = pluckNumber(axisObj.scalerecursively, baseConf.scalerecursively),
                    maxScaleRecursion = pluckNumber(axisObj.maxscalerecursion, baseConf.maxscalerecursion),
                    scaleSeparator = getValidValue(axisObj.scaleseparator, baseConf.scaleseparator),
                    paramLabels,
                    numberscaleunit,
                    numberscalevalue,
                    param,
                    thousandseparatorposition,
                    length,
                    value,
                    lastValue;

                index = pluckNumber(index, this.Y.length);

                 if (getValidValue(axisObj.numberscaleunit)) {
                    numberscaleunit = axisObj.numberscaleunit.split(COMMASTRING);
                }
                // Converting user given numberScaleValue into array
                if (getValidValue(axisObj.numberscalevalue)) {
                    numberscalevalue = axisObj.numberscalevalue.split(COMMASTRING);
                }
                if (!maxScaleRecursion) {
                    maxScaleRecursion = -1;
                }
                // Converting user given numberScaleValue into array
                if(getValidValue(axisObj.thousandseparatorposition)) {
                    thousandseparatorposition = axisObj.thousandseparatorposition.split(COMMASTRING);
                    length = thousandseparatorposition.length;
                    value;
                    lastValue = numberFormatDefaults.thousandseparatorposition[0];
                    // Filtering the user given values
                    while (length--) {
                        value = pluckNumber(mathAbs(thousandseparatorposition[length]));
                        if (!value) {
                            value = lastValue;
                        } else {
                            lastValue = value;
                        }
                        thousandseparatorposition[length] = value;
                    }
                }
                // Parameters passed with this function
                paramLabels = {
                    cacheStore: [],
                    formatnumber: pluck(axisObj.formatnumber, baseConf.formatnumber),
                    formatnumberscale: pluck(axisObj.formatnumberscale, baseConf.formatnumberscale),
                    //defaultnumberscale  : pluck(chartObj.defaultnumberscale, (numberFormatOverrides[chartName] && numberFormatOverrides[chartName].defaultnumberscale)) || numberFormatDefaults.defaultnumberscale,
                    defaultnumberscale: getFirstValue(axisObj.defaultnumberscale, baseConf.defaultnumberscale),
                    numberscaleunit: pluck(numberscaleunit, baseConf.numberscaleunit).concat(),
                    numberscalevalue: pluck(numberscalevalue, baseConf.numberscalevalue).concat(),
                    numberprefix: getFirstValue(axisObj.numberprefix, baseConf.numberprefix),
                    numbersuffix: getFirstValue(axisObj.numbersuffix, baseConf.numbersuffix),
                    forcedecimals: pluck(axisObj.forcedecimals, baseConf.forcedecimals),
                    decimalprecision:parseInt(axisObj.decimals === AUTOSTRING ? csConf.decimalprecision :
                                pluck(axisObj.decimals, baseConf.decimalprecision), 10),
                    decimalseparator: pluck(axisObj.decimalseparator, baseConf.decimalseparator),
                    thousandseparator: pluck(axisObj.thousandseparator, baseConf.thousandseparator),
                    thousandseparatorposition:  pluck(thousandseparatorposition, baseConf.thousandseparatorposition),
                    indecimalseparator: getFirstValue(axisObj.indecimalseparator, baseConf.indecimalseparator),
                    inthousandseparator: getFirstValue(axisObj.inthousandseparator, baseConf.inthousandseparator),
                    scalerecursively: scaleRecursively,
                    maxscalerecursion: maxScaleRecursion,
                    scaleseparator: scaleSeparator
                };
                // scaleRecursively will use only by Widgets.
                if (!chartAPI.useScaleRecursively || ((paramLabels.numberscalevalue && paramLabels.numberscalevalue.length) !=
                        (paramLabels.numberscaleunit && paramLabels.numberscaleunit.length))) {
                    paramLabels.scalerecursively = scaleRecursively = 0;
                }

                param = {
                    cacheStore: [],
                    formatnumber: paramLabels.formatnumber,
                    formatnumberscale: paramLabels.formatnumberscale,
                    defaultnumberscale: paramLabels.defaultnumberscale,
                    numberscaleunit: paramLabels.numberscaleunit.concat(),
                    numberscalevalue: paramLabels.numberscalevalue.concat(),
                    numberprefix: paramLabels.numberprefix,
                    numbersuffix: paramLabels.numbersuffix,
                    decimalprecision: parseInt(pluck(axisObj.yaxisvaluedecimals, paramLabels.decimalprecision, 2)),
                    forcedecimals: pluck(axisObj.forceyaxisvaluedecimals, paramLabels.forcedecimals),
                    decimalseparator: paramLabels.decimalseparator,
                    thousandseparator: paramLabels.thousandseparator,
                    thousandseparatorposition: paramLabels.thousandseparatorposition.concat(),
                    indecimalseparator: paramLabels.indecimalseparator,
                    inthousandseparator: paramLabels.inthousandseparator,
                    scalerecursively: scaleRecursively,
                    maxscalerecursion: maxScaleRecursion,
                    scaleseparator: scaleSeparator
                };

                // Adjusting numberScaleValue and numberScaleUnit array to be use in
                // the calculation of scaleRecursively
                if (scaleRecursively) {
                    paramLabels.numberscalevalue.push(1);
                    paramLabels.numberscaleunit.unshift(paramLabels.defaultnumberscale);

                    param.numberscalevalue.push(1);
                    param.numberscaleunit.unshift(param.defaultnumberscale);
                }

                this.Y[index] = {
                    dataLabelConf: paramLabels,
                    yAxisLabelConf: param
                };
            },
            percentValue : function (num) {//don't use 2'nd argument it may conflict with yAxis()'s 2'nd arg
                var rtn = this.percentStrCacheStore[num],
                        precision;
                if (rtn === undefined) {
                    precision = isNaN(this.paramLabels.decimalprecision) ? "2" : this.paramLabels.decimalprecision;
                    rtn = this.percentStrCacheStore[num] = formatCommas (formatDecimals(num, precision, this.paramLabels.forcedecimals),
                    this.paramLabels.decimalseparator,
                    this.paramLabels.thousandseparator, this.paramLabels.thousandseparatorposition) + '%';
                }
                return rtn;
            },
            // configuration of getCleanValue will be same across all dataset/axis
            getCleanValue: function (numStr, abs) {
                var rtn = this.cleaneValueCacheStore[numStr],
                        num;
                if (rtn === undefined){
                    num = convertNumberSeps(numStr, this.baseConf);
                    this.cleaneValueCacheStore[numStr] = rtn = isNaN(num) ? null : (abs ? mathAbs(num) : num);
                }
                return rtn;
            },
            dataLabels: function (num, axisIndex) {
                var formatterConf = this.Y[axisIndex] || (axisIndex ? this.Y[1] : this.Y[0]),
                        rtn;
                formatterConf = (formatterConf && formatterConf.dataLabelConf) || this.baseConf;
                rtn = formatterConf.cacheStore[num];
                if (rtn === undefined){
                    rtn = formatterConf.cacheStore[num] = formatNumber(num, formatterConf);
                }
                return rtn;
            },
            yAxis: function (num, axisIndex) {
                var formatterConf = this.Y[axisIndex] || (axisIndex ? this.Y[1] : this.Y[0]),
                        rtn;
                formatterConf = (formatterConf && formatterConf.yAxisLabelConf) || this.baseConf;
                rtn = formatterConf.cacheStore[num];
                if (rtn === undefined){
                    rtn = formatterConf.cacheStore[num] = formatNumber(num, formatterConf);
                }
                return rtn;
            },
            xAxis: function (num) {//don't use 2'nd argument it may conflict with y axis 2'nd arg
                var rtn = this.paramX.cacheStore[num];
                if (rtn === undefined){
                    rtn = this.paramX.cacheStore[num] = formatNumber(num, this.paramX);
                }
                return rtn;
            },
            sYAxis: function (num) {
                var formatterConf = this.Y[1],
                        rtn;
                formatterConf = (formatterConf && formatterConf.yAxisLabelConf) || this.baseConf;
                rtn = formatterConf.cacheStore[num];
                if (rtn === undefined){
                    rtn = formatterConf.cacheStore[num] = formatNumber(num, formatterConf);
                }
                return rtn;
            },
            scale: function (num) {
                var rtn = this.paramScale.cacheStore[num];
                if (rtn === undefined){
                    rtn = this.paramScale.cacheStore[num] = formatNumber(num, this.paramScale);
                }
                return rtn;
            },
            //for time type date
            getCleanTime: function(date){
                var dateObj;
                if (this.timeConf.inputDateFormat && Date.parseExact) {
                    dateObj = Date.parseExact(date, this.timeConf.inputDateFormat);
                }
                //store all dateobj and converted values as index for further fast access

                return dateObj && dateObj.getTime();
            },



            getDateValue: function(date) {
                var DATE, H, M, S, ms;

                date = /^dd/.test(this.timeConf.inputDateFormat) && date &&
                    date.replace(/(\d{1,2})\/(\d{1,2})\/(\d{2,4})/, '$2/$1/$3')
                    || date;

                DATE = new Date(date);
                ms = DATE.getTime();
                // If date as time
                if (!ms && date && /\:/.test(date)) {
                    date = date.split(':');
                    H = pluckNumber(date[0], 0);
                    M = pluckNumber(date[1], 0);
                    S = pluckNumber(date[2], 0);

                    H = (H > 23) ? ((H === 24 && M === 0 && S === 0) ? H : 23) : H;
                    M = (M > 59) ? 59 : M;
                    S = (S > 59) ? 59 : S;
                    DATE = new Date();
                    DATE.setHours(H);
                    DATE.setMinutes(M);
                    DATE.setSeconds(S);
                    ms = DATE.getTime();
                }
                


                return {
                    ms: ms,
                    date: DATE
                }
            },

            getFormatedDate: function (date, format) {
                var D = typeof date === 'object' && date || new Date(date),
                    timeConf = this.timeConf,
                    output = pluck(format, timeConf.outputDateFormat),
                    year = D.getFullYear(),
                    month = D.getMonth(),
                    day = D.getDate(),
                    nday = D.getDay(),
                    min = D.getMinutes(),
                    sec = D.getSeconds(),
                    hours = D.getHours();

                min = min > 9 ? BLANK + min : ZEROSTRING + min;
                sec = sec > 9 ? BLANK + sec : ZEROSTRING + sec;
                hours = hours > 9 ? BLANK + hours : ZEROSTRING + hours;

                output.match(/dnl/) && (output = output.replace(/dnl/ig, timeConf.days[nday]));
                output.match(/dns/) && (output = output.replace(/dns/ig,
                    timeConf.days[nday] && timeConf.days[nday].substr(0, 3)));
                output.match(/dd/) && (output = output.replace(/dd/ig, day));

                output.match(/mnl/) && (output = output.replace(/mnl/ig, timeConf.months[month]));
                output.match(/mns/) && (output = output.replace(/mns/ig,
                    timeConf.months[month] && timeConf.months[month].substr(0, 3)));
                output.match(/mm/) && (output = output.replace(/mm/ig, month + 1));

                output.match(/yyyy/) && (output = output.replace(/yyyy/ig, year));
                output.match(/yy/) && (output = output.replace(/yy/ig, ((year % 1000 % 100) + '').replace(/^(\d)$/, '0$1')));

                output.match(/hh12/) && (output = output.replace(/hh12/ig, hours % 12 || 12));
                output.match(/hh/) && (output = output.replace(/hh/ig, hours));

                output.match(/mn/) && (output = output.replace(/mn/ig, min));
                output.match(/ss/) && (output = output.replace(/ss/ig, sec));
                output.match(/ampm/) && (output = output.replace(/ampm/ig, hours < 12 ? 'AM' : 'PM'));
                output.match(/ds/) && (output = output.replace(/ds/ig, timeConf.daySuffix[day]));

                return output;
            }

        };

        NumberFormatter.prototype.constructor = NumberFormatter;

        var formatNumber = function (num, attributes) {
            // We convert the number to a valid number
            // If inDecimalsSeparator and in thousandSeparator is given
            // we replace the thousandSeparator and decimalSeparator with
            // proper valid number format
            //num = convertNumberSeps(num, attributes.indecimalseparator, attributes.inthousandseparator);

            // Change for JS Charts:
            // After initial return from getCleanValue, we get either null or a
            // number. So, we validate presence of null only.
            if (num === null) {
                return; //throw TypeError("Not a Valid number");
            }

            // Failsafe conversion of value to proper type.
            num = Number(num);

            //First, if number is to be scaled, scale it
            //Number in String format
            var strNum = num + BLANK;

            //Number Scale
            var strScale;
            if (attributes.formatnumberscale == 1) {
                strScale = attributes.defaultnumberscale;
            }
            else {
                strScale = BLANK;
            }

            // Fix to show the decimal place
            // if there is more than 2 decimal place in data
            // Finding the decimal place in value
            var valueArr, decimalPlaceLen;
            valueArr = strNum.split(DECIMALSTRING)[1];
            decimalPlaceLen = valueArr ? valueArr.length : attributes.forcedecimals ? TWOSTRING : BLANK;


            // Whether to add K (thousands) and M (millions) to a number
            if (attributes.formatnumberscale == 1) {
                //Get the formatted scale and number
                var objNum = formatNumberScale (num, attributes.defaultnumberscale, attributes.numberscalevalue, attributes.numberscaleunit, attributes.scalerecursively);
                //Store from return in local primitive variables

                strNum = objNum.value;
                num = objNum.value;
                strScale = objNum.scale;
            }

            if (attributes.scalerecursively && attributes.formatnumberscale != 0) {
                //Store the list of numbers and scales.
                var numList = objNum.value;
                var scaleList = objNum.scale;

                //Based on max scale recursion, we decide the upper index to which we've to iterate
                var upperIndex = ((attributes.maxscalerecursion == -1) ? numList.length : Math.min(numList.length, attributes.maxscalerecursion));
                //Now, based on whether we've to format decimals and commas.
                if (attributes.formatnumber == 1) {
                    //If recursive scaling was applied and format number is true, we need to :
                    //- format comma of all values
                    //- format decimals of just the last value (last based on max recursion or actual).
                    strNum = "";
                    var tempNum , tempStr;
                    for (var i = 0; i < upperIndex; i++) {
                        //Convert all but first number to absolute values.
                        tempNum = (i == 0) ? numList[i] : Math.abs(numList[i]);
                        tempStr = tempNum + BLANK;
                        //If it's the last value, format decimals
                        if (i == upperIndex-1) {
                            tempStr = formatDecimals(tempNum, pluck(attributes.decimalprecision, decimalPlaceLen), attributes.forcedecimals);
                        }
                        //Append to strNum after formatting commas
                        //We separate the scales using scale separator. The last token doesn't append
                        //the scale separator, as we append number suffix after that.
                        strNum = strNum +
                        formatCommas(tempStr, attributes.decimalseparator, attributes.thousandseparator, attributes.thousandseparatorposition) +
                        scaleList[i] + (i<upperIndex-1 ? attributes.scaleseparator : "");
                    }
                } else {
                    strNum = "";
                    for (i = 0; i < upperIndex; i++) {
                        //Convert all but first number to absolute values and append to strNum.
                        //We separate the scales using scale separator. The last token doesn't append
                        //the scale separator, as we append number suffix after that.
                        strNum = strNum+((i == 0) ? numList[i] : Math.abs(numList[i]) + BLANK)+scaleList[i]+(i<upperIndex-1 ? attributes.scaleseparator : "");
                    }
                }
                //Now, add scale, number prefix and suffix
                //strNum = numberPrefix + strNum + strScale + numberSuffix;
                strNum = (attributes.numberprefix || BLANK) + strNum + (attributes.numbersuffix || BLANK);
                //Clear up
                delete numList;
                delete scaleList;
            } else {
                //Now, if we've to format the decimals and commas
                if (attributes.formatnumber == 1) {
                    //Format decimals
                    strNum = formatDecimals (num, pluck(attributes.decimalprecision, decimalPlaceLen), attributes.forcedecimals);
                    //Format commas now
                    strNum = formatCommas (strNum, attributes.decimalseparator, attributes.thousandseparator, attributes.thousandseparatorposition);
                }

                //Now, add scale, number prefix and suffix
                //strNum = numberPrefix + strNum + strScale + numberSuffix;
                strNum = (attributes.numberprefix || BLANK) + strNum + strScale + (attributes.numbersuffix || BLANK);
            }
            return strNum;
        };

        /**
         * formatNumberScale formats the number as per given scale.
         * For example, if number Scale Values are 1000,1000 and
         * number Scale Units are K,M, this method will divide any
         * value over 1000000 using M and any value over 1000 (less than 1M) using K
         * so as to give abbreviated figures.
         * Number scaling lets you define your own scales for numbers.
         * To clarify further, let's consider an example. Say you're plotting
         * a chart which indicates the time taken by a list of automated
         * processes. Each process in the list can take time ranging from a
         * few seconds to few days. And you've the data for each process in
         * seconds itself. Now, if you were to show all the data on the chart
         * in seconds only, it won't appear too legible. What you can do is
         * build a scale of yours and then specify it to the chart. A scale,
         * in human terms, would look something as under:
         * 60 seconds = 1 minute
         * 60 minute = 1 hr
         * 24 hrs = 1 day
         * 7 days = 1 week
         * First you would need to define the unit of the data which you're providing.
         * Like, in this example, you're providing all data in seconds. So, default
         * number scale would be represented in seconds. You can represent it as under:
         * <graph defaultNumberScale='s' ...>
         * Next, the scale for the chart is defined as under:
         * <graph numberScaleValue='60,60,24,7' numberScaleUnit='min,hr,day,wk' >
         * If you carefully see this and match it with our range, whatever numeric
         * figure was present on the left hand side of the range is put in
         * numberScaleValue and whatever unit was present on the right side of
         * the scale has been put under numberScaleUnit - all separated by commas.
         * @param intNum The number to be scaled.
         * @param defaultNumberScale Scale of the number provided.
         * @param numScaleValues Incremental list of values (divisors) on
         * which the number will be scaled.
         * @param
         */
        function formatNumberScale (intNum, defaultNumberScale, numScaleValues, numScaleUnits, scaleRecursively) {
            //Create an object, which will be returned
            var objRtn = {},
            //Scale Unit to be stored (assume default)
            strScale = defaultNumberScale,
            i = 0,
            numScaleValue,
            THOUSAND = 1000;
            //Array of values & scales to be returned.
            var arrValues = [];
            var arrScales = [];
            if (scaleRecursively) {
                for (i = 0; i < numScaleValues.length; i++) {
                    // Garbage handling, if comma  separated value of
                    // numberScaleValues is not a number or 0, we use 1000 as the value
                    numScaleValue = pluckNumber(numScaleValues[i]) || THOUSAND;
                    if (Math.abs(Number(intNum)) >= numScaleValue &&  i < numScaleValues.length - 1) {
                        //Carry over from division
                        var carry = intNum % numScaleValue;
                        //Deduct carry over and then divide.
                        intNum = (intNum-carry) / numScaleValue;
                        //Push to return array if carry is non 0
                        if (carry != 0) {
                            arrValues.push(carry);
                            arrScales.push(numScaleUnits[i]);
                        }
                    } else {
                        //This loop executes for first token value (l to r) during recusrive scaling
                        //Or, if original number < first number scale value.
                        arrValues.push(intNum);
                        arrScales.push(numScaleUnits[i]);
                        break;
                    }
                }
                //Reverse the arrays - So that lead value stays at 0 index.
                arrValues.reverse();
                arrScales.reverse();
                objRtn.value = arrValues;
                objRtn.scale = arrScales;
            } else {
                //If the scale unit or values have something fed in them
                //we manipulate the scales.
                if (numScaleValues.length === numScaleUnits.length) {
                    for (i = 0; i < numScaleValues.length; i ++) {
                        // Garbage handling, if comma  separated value of
                        // numberScaleValues is not a number or 0, we use 1000 as the value
                        numScaleValue = pluckNumber(numScaleValues[i]) || THOUSAND;
                        if (numScaleValue && Math.abs (Number (intNum)) >= numScaleValue) {
                            strScale = numScaleUnits[i] || BLANK;
                            intNum = Number (intNum) / numScaleValue;
                        }
                        else {
                            break;
                        }
                    }
                }
                //Set the values as properties of objRtn
                objRtn.value = intNum;
                objRtn.scale = strScale;
            }
            return objRtn;
        }
        /**
        * parseNumberScale method checks whether we've been provided
        * with number scales. If yes, we parse them and store them in
        * local containers.
        *	@return	Nothing.

        function parseNumberScale(numberScaleValues, numberScaleUnits) {
            var bNumberScaleDefined, scaleRecursively;
            //Check if either has been defined
            if (numberScaleValues.length == 0 || numberScaleUnits.length == 0) {
                //Set flag to false
                bNumberScaleDefined = false;
                scaleRecursively = false;
            } else {
                //Set flag to true
                bNumberScaleDefined = true;
                //Split the data into arrays
                attributes.numberscalevalues = new Array();
                attributes.numberscaleunits = new Array();
                //Parse the number scale value
                attributes.numberscalevalues = numberScaleValues.split(",");
                //Convert all number scale values to numbers as they're
                //currently in string format.
                var i;
                for (i=0; i<attributes.numberscalevalues.length; i++) {
                    attributes.numberscalevalues[i] = Number(attributes.numberscalevalues[i]);
                    //If any of numbers are NaN, set defined to false
                    if (isNaN(attributes.numberscalevalues[i])) {
                        bNumberScaleDefined = false;
                        scaleRecursively = false;
                    }
                }
                //Parse the number scale unit
                attributes.numberscaleunits = numberScaleUnits.split(",");
                //If the length of two arrays do not match, set defined to false.
                if (attributes.numberscaleunits.length != attributes.numberscalevalues.length) {
                    bNumberScaleDefined = false;
                    scaleRecursively = false;
                }
                //Push the default scales at start - Value as 1 (universal divisor)
                attributes.numberscalevalues.push(1);
                attributes.numberscaleunits.unshift(this.defaultNumberScale);
                //If number scale is not defined, clear up
                if (!bNumberScaleDefined) {
                    delete attributes.numberscaleunits;
                    delete attributes.numberscalevalues;
                }
            }
        }*/

        /**
         * formatDecimals method formats the decimal places of a number.
         * Requires the following to be defined:
         * params.decimalSeparator
         * params.thousandSeparator
         * @param intNum Number on which we've to work.
         * @param decimalPrecision Number of decimal places to which we've
         * to format the number to.
         * @param forceDecimals Boolean value indicating whether to add decimal
         * padding to numbers which are falling as whole
         * numbers?
         * @return A number with the required number of decimal places
         * in String format. If we return as Number, Flash will remove
         * our decimal padding or un-wanted decimals.
         */
        function formatDecimals (intNum, decimalPrecision, forceDecimals) {
            var tenToPower, strRounded;

            // if negative decimal precision is sent, we set it to 0, as per
            // FusionCharts Policy
            if(decimalPrecision <= 0) {
                return mathRound (intNum) + BLANK;
            //decimalPrecision = 0;
            }
            //If no decimal places are needed, just round the number and return
            if (isNaN(decimalPrecision)) {
                intNum = intNum + BLANK;
                if (intNum.length > 12 && intNum.indexOf(DECIMALSTRING) != -1) {
                    decimalPrecision = 12 - intNum.split(DECIMALSTRING)[0].length;
                    tenToPower = mathPow (10, decimalPrecision);
                    strRounded = mathRound (intNum * tenToPower) / tenToPower + BLANK;
                    intNum = strRounded;
                }
                return intNum;
            //return mathRound (intNum) + BLANKSTRING;
            }
            //Round the number to specified decimal places
            //e.g. 12.3456 to 3 digits (12.346)
            //Step 1: Multiply by 10^decimalPrecision - 12345.6
            //Step 2: Round it - i.e., 12346
            //Step 3: Divide by 10^decimalPrecision - 12.346
            tenToPower = mathPow (10, decimalPrecision);
            strRounded = (mathRound (intNum * tenToPower) / tenToPower) + BLANK;

            //Now, strRounded might have a whole number or a number with required
            //decimal places. Our next job is to check if we've to force Decimals.
            //If yes, we add decimal padding by adding 0s at the end.
            if (forceDecimals == 1) {
                //Add a decimal point if missing
                //At least one decimal place is required (as we split later on .)
                //10 -> 10.0
                if (strRounded.indexOf (DECIMALSTRING) == - 1) {
                    strRounded += ".0";
                }
                //Finally, we start add padding of 0s.
                //Split the number into two parts - pre & post decimal
                var parts = strRounded.split (DECIMALSTRING);
                //Get the numbers falling right of the decimal
                //Compare digits in right half of string to digits wanted
                var paddingNeeded = decimalPrecision - parts [1].length;
                //Number of zeros to add
                for (var i = 1; i <= paddingNeeded; i ++) {
                    //Add them
                    strRounded += ZEROSTRING;
                }
            }
            return (strRounded);
        }

        /**
         * formatCommas method adds proper commas to a number in blocks of 3
         * i.e., 123456 would be formatted as 123,456
         * @param strNum The number to be formatted (as string).
         * Why are numbers taken in string format?
         * Here, we are asking for numbers in string format
         * to preserve the leading and padding 0s of decimals
         * Like as in -20.00, if number is just passed as number,
         * Flash automatically reduces it to -20. But, we've to
         * make sure that we do not disturb the original number.
         * @return Formatted number with commas.
         */
        function formatCommas (strNum, decimalseparator, thousandseparator, thSepPos) {

            //intNum would represent the number in number format
            var intNum = Number (strNum);

            //If the number is invalid, return an empty value
            if (isNaN (intNum)){
                return BLANK;
            }
            var strDecimalPart = BLANK;
            var boolIsNegative = false;
            var strNumberFloor = BLANK;
            var formattedNumber = BLANK;
            var startPos = 0;
            var endPos = 0;
            //Define startPos and endPos
            startPos = 0;
            endPos = strNum.length;

            //Extract the decimal part
            if (strNum.indexOf (DECIMALSTRING) != - 1) {
                strDecimalPart = strNum.substring (strNum.indexOf (DECIMALSTRING) + 1, strNum.length);
                endPos = strNum.indexOf (DECIMALSTRING);
            }
            //Now, if the number is negative, get the value into the flag
            if (intNum < 0) {
                boolIsNegative = true;
                startPos = 1;
            }
            //Now, extract the floor of the number
            strNumberFloor = strNum.substring (startPos, endPos);

            var strNumberLen = strNumberFloor.length,
            sepPosLen = thSepPos.length - 1,
            sepDigit = thSepPos[sepPosLen];
            if (strNumberLen < sepDigit) {
                formattedNumber = strNumberFloor;
            } else {
                while (strNumberLen >= sepDigit) {
                    formattedNumber = (strNumberLen-sepDigit ?  thousandseparator : BLANK) +
                    strNumberFloor.substr( strNumberLen-sepDigit, sepDigit) + formattedNumber;
                    strNumberLen -= sepDigit;
                    sepDigit = (sepPosLen-=1) <= 0 ? thSepPos[0] : thSepPos[sepPosLen];
                    if (strNumberLen < sepDigit) {
                        formattedNumber =  strNumberFloor.substring(strNumberLen, 0) + formattedNumber;
                    }
                }
            }

            // Now, append the decimal part back
            if (strDecimalPart != BLANK) {
                formattedNumber = formattedNumber + decimalseparator + strDecimalPart;
            }
            //Now, if neg num
            if (boolIsNegative == true) {
                formattedNumber = MINUSSTR + formattedNumber;
            }

            //Return
            return formattedNumber;
        }

        /**
         * convertNumberSeps method helps us convert the separator (thousands and decimal)
         * character from the user specified input separator characters to normal numeric
         * values that Flash can handle. In some european countries, commas are used as
         * decimal separators and dots as thousand separators. In XML, if the user specifies
         * such values, it will give a error while converting to number. So, we accept the
         * input decimal and thousand separator from user, so thatwe can covert it accordingly
         * into the required format.
         * If the number is still not a valid number after converting the characters, we log
         * the error and return 0.
         * @param num Number in string format containing user defined separator characters.
         * @return Number in numeric format.
         */
        // convertNumberSeps function modified on [12-04-2011] to fix the issue [FCXTCOMMON-37]
        

        function convertNumberSeps (num, conf) {
            // convert the given number to string
            num = num + BLANK;
            if (conf._REGinthousandseparator) {
                num = num.replace(conf._REGinthousandseparator, BLANK);
            }
            // Replace the indecimalseparator value with decimal to perform numeric operations
            if (conf._REGindecimalseparator) {
                num = num.replace(conf._REGindecimalseparator, DECIMALSTRING);
            }
            num = parseFloat(num);
            // parseFloat is used here instead of Number so that parseFloat()'s
            // returning of NaN on blank string can be utilized.
            return isFinite(num) ? num : NaN;
        }
        /*
        function convertNumberSeps (num, indecimalseparator, inthousandseparator) {
            // Replace the indecimalseparator value with decimal to perform numeric operations
            num = indecimalseparator !== BLANKSTRING ?
            num.toString().replace(indecimalseparator, DECIMALSTRING) : num;

            if (inthousandseparator && inthousandseparator.toString) {
                inthousandseparator = inthousandseparator.toString().replace(/(\W)/ig, '\\$1')
            }

            // Replace the inthousandseparator value with decimal to perform numeric operations
            var re = new RegExp(inthousandseparator, "g");
            num = inthousandseparator !== BLANKSTRING ?
            num.toString().replace(re, BLANKSTRING) : num;

            // old code: intNum = !strNum && strNum !== false && strNum !== 0 ?
            //NaN : Number(strNum);

            return !isNaN(num = parseFloat(num)) && isFinite(num) ? num : NaN;
        }
         */
        return NumberFormatter;

    })();

}]);/*jslint forin: true, regexp: true, todo: true, white: false, browser: true,
 sloppy: true, white: true, eqeq: false, newcap: true, nomen: true */
/*global window: true, FusionCharts */

/**
 * Raphael 2.1.0 - JavaScript Vector Library
 * Modified and rechristened as "Red Raphael" by FusionCharts Technologies.
 *
 * Copyright (c) 2008-2012 Dmitry Baranovskiy (http://raphaeljs.com)
 * Copyright (c) 2008-2012 Sencha Labs (http://sencha.com)
 * Licensed under the MIT (http://raphaeljs.com/license.html) license.
 *
 * Eve 0.3.4 - JavaScript Events Library
 * Copyright (c) 2008-2011 Dmitry Baranovskiy (http://dmitry.baranovskiy.com/)
 * Licensed under the MIT (http://www.opensource.org/licenses/mit-license.php) license.
 */

FusionCharts(['private', 'modules.renderer.js-raphael', function () {
    var global = this,
    lib = global.hcLib,
    eve,
    someRaphael = window.Raphael,
    RedRaphael;

    (function(glob) {
        var version = "0.3.4",
        has = "hasOwnProperty",
        separator = /[\.\/]/,
        wildcard = "*",
        fun = function() {
        },
        numsort = function(a, b) {
            return a - b;
        },
        current_event,
        stop,
        events = {
            n: {}
        },
        eve = lib.eve = function(name, scope) {
            var e = events,
            oldstop = stop,
            args = Array.prototype.slice.call(arguments, 2),
            listeners = eve.listeners(name),
            z = 0,
            f = false,
            l,
            indexed = [],
            queue = {},
            out = [],
            ce = current_event,
            errors = [];
            current_event = name;
            stop = 0;
            for (var i = 0, ii = listeners.length; i < ii; i++)
                if ("zIndex" in listeners[i]) {
                    indexed.push(listeners[i].zIndex);
                    if (listeners[i].zIndex < 0) {
                        queue[listeners[i].zIndex] = listeners[i];
                    }
                }
            indexed.sort(numsort);
            while (indexed[z] < 0) {
                l = queue[indexed[z++]];
                out.push(l.apply(scope, args));
                if (stop) {
                    stop = oldstop;
                    return out;
                }
            }
            for (i = 0; i < ii; i++) {
                l = listeners[i];
                if ("zIndex" in l) {
                    if (l.zIndex == indexed[z]) {
                        out.push(l.apply(scope, args));
                        if (stop) {
                            break;
                        }
                        do {
                            z++;
                            l = queue[indexed[z]];
                            l && out.push(l.apply(scope, args));
                            if (stop) {
                                break;
                            }
                        } while (l)
                    } else {
                        queue[l.zIndex] = l;
                    }
                } else {
                    out.push(l.apply(scope, args));
                    if (stop) {
                        break;
                    }
                }
            }
            stop = oldstop;
            current_event = ce;
            return out.length ? out : null;
        };

        eve.listeners = function(name) {
            var names = name.split(separator),
            e = events,
            item,
            items,
            k,
            i,
            ii,
            j,
            jj,
            nes,
            es = [e],
            out = [];
            for (i = 0, ii = names.length; i < ii; i++) {
                nes = [];
                for (j = 0, jj = es.length; j < jj; j++) {
                    e = es[j].n;
                    items = [e[names[i]], e[wildcard]];
                    k = 2;
                    while (k--) {
                        item = items[k];
                        if (item) {
                            nes.push(item);
                            out = out.concat(item.f || []);
                        }
                    }
                }
                es = nes;
            }
            return out;
        };


        eve.on = function(name, f) {
            var names = name.split(separator),
            e = events;
            for (var i = 0, ii = names.length; i < ii; i++) {
                e = e.n;
                !e[names[i]] && (e[names[i]] = {
                    n: {}
                });
                e = e[names[i]];
            }
            e.f = e.f || [];
            for (i = 0, ii = e.f.length; i < ii; i++)
                if (e.f[i] == f) {
                    return fun;
                }
            e.f.push(f);
            return function(zIndex) {
                if (+zIndex == +zIndex) {
                    f.zIndex = +zIndex;
                }
            };
        };

        eve.stop = function() {
            stop = 1;
        };

        eve.nt = function(subname) {
            if (subname) {
                return new RegExp("(?:\\.|\\/|^)" + subname + "(?:\\.|\\/|$)").test(current_event);
            }
            return current_event;
        };


        eve.off = eve.unbind = function(name, f) {
            var names = name.split(separator),
            e,
            key,
            splice,
            i, ii, j, jj,
            cur = [events];
            for (i = 0, ii = names.length; i < ii; i++) {
                for (j = 0; j < cur.length; j += splice.length - 2) {
                    splice = [j, 1];
                    e = cur[j].n;
                    if (names[i] != wildcard) {
                        if (e[names[i]]) {
                            splice.push(e[names[i]]);
                        }
                    } else {
                        for (key in e)
                            if (e[has](key)) {
                                splice.push(e[key]);
                            }
                    }
                    cur.splice.apply(cur, splice);
                }
            }
            for (i = 0, ii = cur.length; i < ii; i++) {
                e = cur[i];
                while (e.n) {
                    if (f) {
                        if (e.f) {
                            for (j = 0, jj = e.f.length; j < jj; j++)
                                if (e.f[j] == f) {
                                    e.f.splice(j, 1);
                                    break;
                                }
                            !e.f.length && delete e.f;
                        }
                        for (key in e.n)
                            if (e.n[has](key) && e.n[key].f) {
                                var funcs = e.n[key].f;
                                for (j = 0, jj = funcs.length; j < jj; j++)
                                    if (funcs[j] == f) {
                                        funcs.splice(j, 1);
                                        break;
                                    }
                                !funcs.length && delete e.n[key].f;
                            }
                    } else {
                        delete e.f;
                        for (key in e.n)
                            if (e.n[has](key) && e.n[key].f) {
                                delete e.n[key].f;
                            }
                    }
                    e = e.n;
                }
            }
        };

        eve.once = function(name, f) {
            var f2 = function() {
                var res = f.apply(this, arguments);
                eve.unbind(name, f2);
                return res;
            };
            return eve.on(name, f2);
        };

        eve.version = version;
        eve.toString = function() {
            return "You are running Eve " + version;
        };
        (typeof module != "undefined" && module.exports) ? (module.exports = eve) : (typeof define != "undefined" ? (define("eve", [], function() {
            return eve;
        })) : (glob.eve = eve));
    })(lib);

    // Move eve to the current scope
    eve = lib.eve;

    /**
     * Raphael 2.1.0 - JavaScript Vector Library
     *
     * Copyright (c) 2008-2011 Dmitry Baranovskiy (http://raphaeljs.com)
     * Copyright (c) 2008-2011 Sencha Labs (http://sencha.com)
     *
     * Licensed under the MIT (http://raphaeljs.com/license.html) license.
     */
    (function() {

        function R(first) {
            if (R.is(first, "function")) {
                return loaded ? first() : eve.on("raphael.DOMload", first);
            } else if (R.is(first, array)) {
                return R._engine.create[apply](R, first.splice(0, 3 + R.is(first[0], nu))).add(first);
            } else {
                var args = Array.prototype.slice.call(arguments, 0);
                if (R.is(args[args.length - 1], "function")) {
                    var f = args.pop();
                    return loaded ? f.call(R._engine.create[apply](R, args)) : eve.on("raphael.DOMload", function() {
                        f.call(R._engine.create[apply](R, args));
                    });
                } else {
                    return R._engine.create[apply](R, arguments);
                }
            }
        }
        RedRaphael = R;
        R.version = "2.1.0";
        R.eve = eve;
        var loaded,
        separator = /[, ]+/,
        elements = {
            circle: 1,
            rect: 1,
            path: 1,
            ellipse: 1,
            text: 1,
            image: 1,
            group: 1
        },
        formatrg = /\{(\d+)\}/g,
        proto = "prototype",
        has = "hasOwnProperty",
        g = {
            doc: document,
            win: window
        },
        CustomAttributes = function () {
        },
        caproto = R.ca = CustomAttributes.prototype,
        oldRaphael = {
            was: Object.prototype[has].call(g.win, "Raphael"),
            is: g.win.Raphael
        },
        Paper = function() {
            this.ca = this.customAttributes = new CustomAttributes();
            this._CustomAttributes = function () {};
            this._CustomAttributes.prototype = this.ca;
        },
        paperproto,
        appendChild = "appendChild",
        apply = "apply",
        concat = "concat",
        supportsTouch = R._supportsTouch = "createTouch" in g.doc,
        E = "",
        S = " ",
        Str = String,
        split = "split",
        events = "click dblclick mousedown mousemove mouseout mouseover mouseup touchstart touchmove touchend touchcancel"[split](S),
        touchMap = R._touchMap = {
            mousedown: "touchstart",
            mousemove: "touchmove",
            mouseup: "touchend"
        },
        lowerCase = Str.prototype.toLowerCase,
        math = Math,
        mmax = math.max,
        mmin = math.min,
        abs = math.abs,
        pow = math.pow,
        mathCos = math.cos,
        mathSin = math.sin,
        mathSqrt = math.sqrt,
        PI = math.PI,
        deg2rad = PI / 180,
        nu = "number",
        string = "string",
        array = "array",
        toString = "toString",
        fillString = "fill",
        objectToString = Object.prototype.toString,
        paper = {},
        push = "push",
        ISURL = R._ISURL = /^url\(['"]?([^\)]+?)['"]?\)$/i,
        colourRegExp = /^\s*((#[a-f\d]{6})|(#[a-f\d]{3})|rgba?\(\s*([\d\.]+%?\s*,\s*[\d\.]+%?\s*,\s*[\d\.]+%?(?:\s*,\s*[\d\.]+%?)?)\s*\)|hsba?\(\s*([\d\.]+(?:deg|\xb0|%)?\s*,\s*[\d\.]+%?\s*,\s*[\d\.]+(?:%?\s*,\s*[\d\.]+)?)%?\s*\)|hsla?\(\s*([\d\.]+(?:deg|\xb0|%)?\s*,\s*[\d\.]+%?\s*,\s*[\d\.]+(?:%?\s*,\s*[\d\.]+)?)%?\s*\))\s*$/i,
        isnan = {
            "NaN": 1,
            "Infinity": 1,
            "-Infinity": 1
        },
        bezierrg = /^(?:cubic-)?bezier\(([^,]+),([^,]+),([^,]+),([^\)]+)\)/,
        round = math.round,
        setAttribute = "setAttribute",
        toFloat = parseFloat,
        toInt = parseInt,
        upperCase = Str.prototype.toUpperCase,
        availableAttrs = R._availableAttrs = {
            "arrow-end": "none",
            "arrow-start": "none",
            blur: 0,
            "clip-rect": "0 0 1e9 1e9",
            "clip-path": "",
            cursor: "default",
            cx: 0,
            cy: 0,
            fill: "#fff",
            "fill-opacity": 1,
            font: '10px "Arial"',
            "font-family": '"Arial"',
            "font-size": "10",
            "font-style": "normal",
            "font-weight": 400,
            gradient: 0,
            height: 0,
            href: "about:blank",
            "letter-spacing": 0,
            "line-height": 12,
            "vertical-align": "middle",
            opacity: 1,
            path: "M0,0",
            r: 0,
            rx: 0,
            ry: 0,
            src: "",
            stroke: "#000",
            "stroke-dasharray": "",
            "stroke-linecap": "butt",
            "stroke-linejoin": "butt",
            "stroke-miterlimit": 0,
            "stroke-opacity": 1,
            "stroke-width": 1,
            "shape-rendering": "default",
            target: "_blank",
            "text-anchor": "middle",
            "visibility": "",
            title: "",
            transform: "",
            rotation: 0,
            width: 0,
            x: 0,
            y: 0
        },
        availableAnimAttrs = R._availableAnimAttrs = {
            blur: nu,
            "clip-rect": "csv",
            "clip-path": "path",
            cx: nu,
            cy: nu,
            fill: "colour",
            "fill-opacity": nu,
            "font-size": nu,
            height: nu,
            opacity: nu,
            path: "path",
            r: nu,
            rx: nu,
            ry: nu,
            stroke: "colour",
            "stroke-opacity": nu,
            "stroke-width": nu,
            transform: "transform",
            width: nu,
            x: nu,
            y: nu
        },
        whitespace = /[\x09\x0a\x0b\x0c\x0d\x20\xa0\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000\u2028\u2029]/g,
        commaSpaces = /[\x09\x0a\x0b\x0c\x0d\x20\xa0\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000\u2028\u2029]*,[\x09\x0a\x0b\x0c\x0d\x20\xa0\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000\u2028\u2029]*/,
        hsrg = {
            hs: 1,
            rg: 1
        },
        p2s = /,?([achlmqrstvxz]),?/gi,
        pathCommand = /([achlmrqstvz])[\x09\x0a\x0b\x0c\x0d\x20\xa0\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000\u2028\u2029,]*((-?\d*\.?\d*(?:e[\-+]?\d+)?[\x09\x0a\x0b\x0c\x0d\x20\xa0\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000\u2028\u2029]*,?[\x09\x0a\x0b\x0c\x0d\x20\xa0\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000\u2028\u2029]*)+)/ig,
        tCommand = /([rstm])[\x09\x0a\x0b\x0c\x0d\x20\xa0\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000\u2028\u2029,]*((-?\d*\.?\d*(?:e[\-+]?\d+)?[\x09\x0a\x0b\x0c\x0d\x20\xa0\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000\u2028\u2029]*,?[\x09\x0a\x0b\x0c\x0d\x20\xa0\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000\u2028\u2029]*)+)/ig,
        pathValues = /(-?\d*\.?\d*(?:e[\-+]?\d+)?)[\x09\x0a\x0b\x0c\x0d\x20\xa0\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000\u2028\u2029]*,?[\x09\x0a\x0b\x0c\x0d\x20\xa0\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000\u2028\u2029]*/ig,
        radial_gradient = R._radial_gradient = /^x?r(?:\(([^\)]*?)\))?/,
        eldata = {},
        sortByKey = function(a, b) {
            return a.key - b.key;
        },
        sortByNumber = function(a, b) {
            return toFloat(a) - toFloat(b);
        },
        fun = function() {
        },
        pipe = function(x) {
            return x;
        },
        rectPath = R._rectPath = function(x, y, w, h, r) {
            if (r) {
                return [["M", x + r, y], ["l", w - r * 2, 0], ["a", r, r, 0, 0, 1, r, r], ["l", 0, h - r * 2], ["a", r, r, 0, 0, 1, -r, r], ["l", r * 2 - w, 0], ["a", r, r, 0, 0, 1, -r, -r], ["l", 0, r * 2 - h], ["a", r, r, 0, 0, 1, r, -r], ["z"]];
            }
            return [["M", x, y], ["l", w, 0], ["l", 0, h], ["l", -w, 0], ["z"]];
        },
        ellipsePath = function(x, y, rx, ry) {
            if (ry == null) {
                ry = rx;
            }
            return [["M", x, y], ["m", 0, -ry], ["a", rx, ry, 0, 1, 1, 0, 2 * ry], ["a", rx, ry, 0, 1, 1, 0, -2 * ry], ["z"]];
        },
        getPath = R._getPath = {
            group: function() {
                return false;
            },
            path: function(el) {
                return el.attr("path");
            },
            circle: function(el) {
                var a = el.attrs;
                return ellipsePath(a.cx, a.cy, a.r);
            },
            ellipse: function(el) {
                var a = el.attrs;
                return ellipsePath(a.cx, a.cy, a.rx, a.ry);
            },
            rect: function(el) {
                var a = el.attrs;
                return rectPath(a.x, a.y, a.width, a.height, a.r);
            },
            image: function(el) {
                var a = el.attrs;
                return rectPath(a.x, a.y, a.width, a.height);
            },
            text: function(el) {
                var bbox = el._getBBox();
                return rectPath(bbox.x, bbox.y, bbox.width, bbox.height);
            }
        },
        mapPath = R.mapPath = function(path, matrix) {
            if (!matrix) {
                return path;
            }
            var x, y, i, j, ii, jj, pathi;
            path = path2curve(path);
            for (i = 0, ii = path.length; i < ii; i++) {
                pathi = path[i];
                for (j = 1, jj = pathi.length; j < jj; j += 2) {
                    x = matrix.x(pathi[j], pathi[j + 1]);
                    y = matrix.y(pathi[j], pathi[j + 1]);
                    pathi[j] = x;
                    pathi[j + 1] = y;
                }
            }
            return path;
        },
        pick = R.pick = function() {
            var arg, i, l;
            for (i = 0, l = arguments.length; i < l; i += 1) {
                arg = arguments[i];
                if (!arg && arg !== false && arg !== 0) {
                    continue;
                }
                return arg;
            }
            return undefined;
        };

        R._g = g;

        R.type = (g.win.ENABLE_RED_CANVAS && (g.win.CanvasRenderingContext2D || g.doc.createElement('canvas').getContext)) ? "CANVAS" :
                (g.win.SVGAngle || g.doc.implementation.hasFeature("http://www.w3.org/TR/SVG11/feature#BasicStructure", "1.1") ? "SVG" : "VML");

        if (R.type == "VML") {
            var d = g.doc.createElement("div"),
            b;
            d.innerHTML = '<v:shape adj="1"/>';
            b = d.firstChild;
            b.style.behavior = "url(#default#VML)";
            if (!(b && typeof b.adj == "object")) {
                return (R.type = E);
            }
            d = null;
        }

        R.svg = !((R.vml = R.type == "VML") || (R.canvas = R.type == "CANVAS"));
        R._Paper = Paper;

        R.fn = paperproto = Paper.prototype = R.prototype;
        R._id = 0;
        R._oid = 0;

        R.is = function(o, type) {
            type = lowerCase.call(type);
            if (type == "finite") {
                return !isnan[has](+o);
            }
            if (type == "array") {
                return o instanceof Array;
            }
            if (type === 'object' && (o === undefined || o === null)) {
                return false;
            }
            return  (type == "null" && o === null) ||
            (type == typeof o && o !== null) ||
            (type == "object" && o === Object(o)) ||
            (type == "array" && Array.isArray && Array.isArray(o)) ||
            objectToString.call(o).slice(8, -1).toLowerCase() == type;
        };

        function clone(obj) {
            if (Object(obj) !== obj) {
                return obj;
            }
            var res = new obj.constructor;
            for (var key in obj)
                if (obj[has](key)) {
                    res[key] = clone(obj[key]);
                }
            return res;
        }


        R.angle = function(x1, y1, x2, y2, x3, y3) {
            if (x3 == null) {
                var x = x1 - x2,
                y = y1 - y2;
                if (!x && !y) {
                    return 0;
                }
                return (180 + math.atan2(-y, -x) * 180 / PI + 360) % 360;
            } else {
                return R.angle(x1, y1, x3, y3) - R.angle(x2, y2, x3, y3);
            }
        };

        R.rad = function(deg) {
            return deg % 360 * deg2rad;
        };

        R.deg = function(rad) {
            return rad * 180 / PI % 360;
        };

        R.snapTo = function(values, value, tolerance) {
            tolerance = R.is(tolerance, "finite") ? tolerance : 10;
            if (R.is(values, array)) {
                var i = values.length;
                while (i--)
                    if (abs(values[i] - value) <= tolerance) {
                        return values[i];
                    }
            } else {
                values = +values;
                var rem = value % values;
                if (rem < tolerance) {
                    return value - rem;
                }
                if (rem > values - tolerance) {
                    return value - rem + values;
                }
            }
            return value;
        };


        var createUUID = R.createUUID = (function(uuidRegEx, uuidReplacer) {
            return function() {
                return "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(uuidRegEx, uuidReplacer).toUpperCase();
            };
        })(/[xy]/g, function(c) {
            var r = math.random() * 16 | 0,
            v = c == "x" ? r : (r & 3 | 8);
            return v.toString(16);
        });


        R.setWindow = function(newwin) {
            eve("raphael.setWindow", R, g.win, newwin);
            g.win = newwin;
            g.doc = g.win.document;
            if (R._engine.initWin) {
                R._engine.initWin(g.win);
            }
        };
        var toHex = function(color) {
            if (R.vml) {
                // http://dean.edwards.name/weblog/2009/10/convert-any-colour-value-to-hex-in-msie/
                var trim = /^\s+|\s+$/g;
                var bod;
                try {
                    var docum = new ActiveXObject("htmlfile");
                    docum.write("<body>");
                    docum.close();
                    bod = docum.body;
                } catch (e) {
                    bod = createPopup().document.body;
                }
                var range = bod.createTextRange();
                toHex = cacher(function(color) {
                    try {
                        bod.style.color = Str(color).replace(trim, E);
                        var value = range.queryCommandValue("ForeColor");
                        value = ((value & 255) << 16) | (value & 65280) | ((value & 16711680) >>> 16);
                        return "#" + ("000000" + value.toString(16)).slice(-6);
                    } catch (e) {
                        return "none";
                    }
                });
            } else {
                var i = g.doc.createElement("i");
                i.title = "Rapha\xebl Colour Picker";
                i.style.display = "none";
                g.doc.body.appendChild(i);
                toHex = cacher(function(color) {
                    i.style.color = color;
                    return g.doc.defaultView.getComputedStyle(i, E).getPropertyValue("color");
                });
            }
            return toHex(color);
        },
        hsbtoString = function() {
            return "hsb(" + [this.h, this.s, this.b] + ")";
        },
        hsltoString = function() {
            return "hsl(" + [this.h, this.s, this.l] + ")";
        },
        rgbtoString = function() {
            return this.hex;
        },
        prepareRGB = function(r, g, b) {
            if (g == null && R.is(r, "object") && "r" in r && "g" in r && "b" in r) {
                b = r.b;
                g = r.g;
                r = r.r;
            }
            if (g == null && R.is(r, string)) {
                var clr = R.getRGB(r);
                r = clr.r;
                g = clr.g;
                b = clr.b;
            }
            if (r > 1 || g > 1 || b > 1) {
                r /= 255;
                g /= 255;
                b /= 255;
            }

            return [r, g, b];
        },
        packageRGB = function(r, g, b, o) {
            r *= 255;
            g *= 255;
            b *= 255;
            var rgb = {
                r: r,
                g: g,
                b: b,
                hex: R.rgb(r, g, b),
                toString: rgbtoString
            };
            R.is(o, "finite") && (rgb.opacity = o);
            return rgb;
        };


        R.color = function(clr) {
            var rgb;
            if (R.is(clr, "object") && "h" in clr && "s" in clr && "b" in clr) {
                rgb = R.hsb2rgb(clr);
                clr.r = rgb.r;
                clr.g = rgb.g;
                clr.b = rgb.b;
                clr.hex = rgb.hex;
            } else if (R.is(clr, "object") && "h" in clr && "s" in clr && "l" in clr) {
                rgb = R.hsl2rgb(clr);
                clr.r = rgb.r;
                clr.g = rgb.g;
                clr.b = rgb.b;
                clr.hex = rgb.hex;
            } else {
                if (R.is(clr, "string")) {
                    clr = R.getRGB(clr);
                }
                if (R.is(clr, "object") && "r" in clr && "g" in clr && "b" in clr) {
                    rgb = R.rgb2hsl(clr);
                    clr.h = rgb.h;
                    clr.s = rgb.s;
                    clr.l = rgb.l;
                    rgb = R.rgb2hsb(clr);
                    clr.v = rgb.b;
                } else {
                    clr = {
                        hex: "none"
                    };
                    clr.r = clr.g = clr.b = clr.h = clr.s = clr.v = clr.l = -1;
                }
            }
            clr.toString = rgbtoString;
            return clr;
        };

        R.hsb2rgb = function(h, s, v, o) {
            if (this.is(h, "object") && "h" in h && "s" in h && "b" in h) {
                v = h.b;
                s = h.s;
                h = h.h;
                o = h.o;
            }
            h *= 360;
            var R, G, B, X, C;
            h = (h % 360) / 60;
            C = v * s;
            X = C * (1 - abs(h % 2 - 1));
            R = G = B = v - C;

            h = ~~h;
            R += [C, X, 0, 0, X, C][h];
            G += [X, C, C, X, 0, 0][h];
            B += [0, 0, X, C, C, X][h];
            return packageRGB(R, G, B, o);
        };

        R.hsl2rgb = function(h, s, l, o) {
            if (this.is(h, "object") && "h" in h && "s" in h && "l" in h) {
                l = h.l;
                s = h.s;
                h = h.h;
            }
            if (h > 1 || s > 1 || l > 1) {
                h /= 360;
                s /= 100;
                l /= 100;
            }
            h *= 360;
            var R, G, B, X, C;
            h = (h % 360) / 60;
            C = 2 * s * (l < .5 ? l : 1 - l);
            X = C * (1 - abs(h % 2 - 1));
            R = G = B = l - C / 2;

            h = ~~h;
            R += [C, X, 0, 0, X, C][h];
            G += [X, C, C, X, 0, 0][h];
            B += [0, 0, X, C, C, X][h];
            return packageRGB(R, G, B, o);
        };

        R.rgb2hsb = function(r, g, b) {
            b = prepareRGB(r, g, b);
            r = b[0];
            g = b[1];
            b = b[2];

            var H, S, V, C;
            V = mmax(r, g, b);
            C = V - mmin(r, g, b);
            H = (C == 0 ? null :
                V == r ? (g - b) / C :
                V == g ? (b - r) / C + 2 :
                (r - g) / C + 4
                );
            H = ((H + 360) % 6) * 60 / 360;
            S = C == 0 ? 0 : C / V;
            return {
                h: H,
                s: S,
                b: V,
                toString: hsbtoString
            };
        };

        R.rgb2hsl = function(r, g, b) {
            b = prepareRGB(r, g, b);
            r = b[0];
            g = b[1];
            b = b[2];

            var H, S, L, M, m, C;
            M = mmax(r, g, b);
            m = mmin(r, g, b);
            C = M - m;
            H = (C == 0 ? null :
                M == r ? (g - b) / C :
                M == g ? (b - r) / C + 2 :
                (r - g) / C + 4);
            H = ((H + 360) % 6) * 60 / 360;
            L = (M + m) / 2;
            S = (C == 0 ? 0 :
                L < .5 ? C / (2 * L) :
                C / (2 - 2 * L));
            return {
                h: H,
                s: S,
                l: L,
                toString: hsltoString
            };
        };
        R._path2string = function() {
            return this.join(",").replace(p2s, "$1");
        };
        function repush(array, item) {
            for (var i = 0, ii = array.length; i < ii; i++)
                if (array[i] === item) {
                    return array.push(array.splice(i, 1)[0]);
                }
        }
        var cacher = R._cacher = function (f, scope, postprocessor) {
            function cachedfunction() {
                var arg = Array.prototype.slice.call(arguments, 0),
                args = arg.join("\u2400"),
                cache = cachedfunction.cache = cachedfunction.cache || {},
                count = cachedfunction.count = cachedfunction.count || [];
                if (cache[has](args)) {
                    repush(count, args);
                    return postprocessor ? postprocessor(cache[args]) : cache[args];
                }
                count.length >= 1e3 && delete cache[count.shift()];
                count.push(args);
                cache[args] = f[apply](scope, arg);
                return postprocessor ? postprocessor(cache[args]) : cache[args];
            }
            return cachedfunction;
        }

        var preload = R._preload = function(src, f) {
            var img = g.doc.createElement("img");
            img.style.cssText = "position:absolute;left:-9999em;top:-9999em";
            img.onload = function() {
                f.call(this);
                this.onload = null;
                g.doc.body.removeChild(this);
            };
            img.onerror = function() {
                g.doc.body.removeChild(this);
            };
            g.doc.body.appendChild(img);
            img.src = src;
        };

        function clrToString() {
            return this.hex;
        }


        R.getRGB = cacher(function(colour) {
            var opacity;
                colour && R.is(colour, 'object') && "opacity" in colour &&
                    (opacity = colour.opacity);
            if (!colour || !!((colour = Str(colour)).indexOf("-") + 1)) {
                return {
                    r: -1,
                    g: -1,
                    b: -1,
                    hex: "none",
                    error: 1,
                    toString: clrToString
                };
            }
            if (colour == "none") {
                return {
                    r: -1,
                    g: -1,
                    b: -1,
                    hex: "none",
                    toString: clrToString
                };
            }
            !(hsrg[has](colour.toLowerCase().substring(0, 2)) || colour.charAt() == "#") && (colour = toHex(colour));
            var res,
            red,
            green,
            blue,
            t,
            values,
            rgb = colour.match(colourRegExp);
            if (rgb) {
                if (rgb[2]) {
                    blue = toInt(rgb[2].substring(5), 16);
                    green = toInt(rgb[2].substring(3, 5), 16);
                    red = toInt(rgb[2].substring(1, 3), 16);
                }
                if (rgb[3]) {
                    blue = toInt((t = rgb[3].charAt(3)) + t, 16);
                    green = toInt((t = rgb[3].charAt(2)) + t, 16);
                    red = toInt((t = rgb[3].charAt(1)) + t, 16);
                }
                if (rgb[4]) {
                    values = rgb[4][split](commaSpaces);
                    red = toFloat(values[0]);
                    values[0].slice(-1) == "%" && (red *= 2.55);
                    green = toFloat(values[1]);
                    values[1].slice(-1) == "%" && (green *= 2.55);
                    blue = toFloat(values[2]);
                    values[2].slice(-1) == "%" && (blue *= 2.55);
                    rgb[1].toLowerCase().slice(0, 4) == "rgba" && (opacity = toFloat(values[3]));
                    values[3] && values[3].slice(-1) == "%" && (opacity /= 100);
                }
                if (rgb[5]) {
                    values = rgb[5][split](commaSpaces);
                    red = toFloat(values[0]);
                    values[0].slice(-1) == "%" && (red *= 2.55);
                    green = toFloat(values[1]);
                    values[1].slice(-1) == "%" && (green *= 2.55);
                    blue = toFloat(values[2]);
                    values[2].slice(-1) == "%" && (blue *= 2.55);
                    (values[0].slice(-3) == "deg" || values[0].slice(-1) == "\xb0") && (red /= 360);
                    rgb[1].toLowerCase().slice(0, 4) == "hsba" && (opacity = toFloat(values[3]));
                    values[3] && values[3].slice(-1) == "%" && (opacity /= 100);
                    return R.hsb2rgb(red, green, blue, opacity);
                }
                if (rgb[6]) {
                    values = rgb[6][split](commaSpaces);
                    red = toFloat(values[0]);
                    values[0].slice(-1) == "%" && (red *= 2.55);
                    green = toFloat(values[1]);
                    values[1].slice(-1) == "%" && (green *= 2.55);
                    blue = toFloat(values[2]);
                    values[2].slice(-1) == "%" && (blue *= 2.55);
                    (values[0].slice(-3) == "deg" || values[0].slice(-1) == "\xb0") && (red /= 360);
                    rgb[1].toLowerCase().slice(0, 4) == "hsla" && (opacity = toFloat(values[3]));
                    values[3] && values[3].slice(-1) == "%" && (opacity /= 100);
                    return R.hsl2rgb(red, green, blue, opacity);
                }
                rgb = {
                    r: red,
                    g: green,
                    b: blue,
                    toString: clrToString
                };
                rgb.hex = "#" + (16777216 | blue | (green << 8) | (red << 16)).toString(16).slice(1);
                R.is(opacity, "finite") && (rgb.opacity = opacity);
                return rgb;
            }
            return {
                r: -1,
                g: -1,
                b: -1,
                hex: "none",
                error: 1,
                toString: clrToString
            };
        }, R);

        R.tintshade = cacher(function(colour, percent) {
            var rgb = R.getRGB(colour),
                tint,
                offset = 255;

            (percent < 0) && (percent *= -1, offset = 0);
            (percent > 1) && (percent = 1);

            tint = percent === 0 ? rgb : {
                r: offset - (offset - rgb.r) * percent,
                g: offset - (offset - rgb.g) * percent,
                b: offset - (offset - rgb.b) * percent,
                toString: clrToString
            };
            tint.hex = R.rgb(tint.r, tint.g, tint.b);
            rgb.error && (tint.error = rgb.error);

            if ("opacity" in rgb) {
                tint.rgba = 'rgba(' + [tint.r, tint.g, tint.b, rgb.opacity].join(',') + ')';
                tint.opacity = rgb.opacity;
            }
            else {
                tint.rgba = 'rgb(' + [tint.r, tint.g, tint.b].join(',') + ')';
            }
            return tint;
        }, R);

        R.hsb = cacher(function(h, s, b) {
            return R.hsb2rgb(h, s, b).hex;
        });

        R.hsl = cacher(function(h, s, l) {
            return R.hsl2rgb(h, s, l).hex;
        });

        R.rgb = cacher(function(r, g, b) {
            return "#" + (16777216 | b | (g << 8) | (r << 16)).toString(16).slice(1);
        });

        R.getColor = function(value) {
            var start = this.getColor.start = this.getColor.start || {
                h: 0,
                s: 1,
                b: value || .75
            },
            rgb = this.hsb2rgb(start.h, start.s, start.b);
            start.h += .075;
            if (start.h > 1) {
                start.h = 0;
                start.s -= .2;
                start.s <= 0 && (this.getColor.start = {
                    h: 0,
                    s: 1,
                    b: start.b
                });
            }
            return rgb.hex;
        };

        R.getColor.reset = function() {
            delete this.start;
        };

        // http://schepers.cc/getting-to-the-point
        function catmullRom2bezier(crp, z) {
            var d = [];
            for (var i = 0, iLen = crp.length; iLen - 2 * !z > i; i += 2) {
                var p = [
                {
                    x: +crp[i - 2],
                    y: +crp[i - 1]
                },
                {
                    x: +crp[i],
                    y: +crp[i + 1]
                },
                {
                    x: +crp[i + 2],
                    y: +crp[i + 3]
                },
                {
                    x: +crp[i + 4],
                    y: +crp[i + 5]
                }
                ];
                if (z) {
                    if (!i) {
                        p[0] = {
                            x: +crp[iLen - 2],
                            y: +crp[iLen - 1]
                        };
                    } else if (iLen - 4 == i) {
                        p[3] = {
                            x: +crp[0],
                            y: +crp[1]
                        };
                    } else if (iLen - 2 == i) {
                        p[2] = {
                            x: +crp[0],
                            y: +crp[1]
                        };
                        p[3] = {
                            x: +crp[2],
                            y: +crp[3]
                        };
                    }
                } else {
                    if (iLen - 4 == i) {
                        p[3] = p[2];
                    } else if (!i) {
                        p[0] = {
                            x: +crp[i],
                            y: +crp[i + 1]
                        };
                    }
                }
                d.push(["C",
                    (-p[0].x + 6 * p[1].x + p[2].x) / 6,
                    (-p[0].y + 6 * p[1].y + p[2].y) / 6,
                    (p[1].x + 6 * p[2].x - p[3].x) / 6,
                    (p[1].y + 6 * p[2].y - p[3].y) / 6,
                    p[2].x,
                    p[2].y
                    ]);
            }

            return d;
        }

        R.parsePathString = function(pathString) {
            if (!pathString) {
                return null;
            }
            var pth = paths(pathString);
            if (pth.arr) {
                return pathClone(pth.arr);
            }

            var paramCounts = {
                a: 7,
                c: 6,
                h: 1,
                l: 2,
                m: 2,
                r: 4,
                q: 4,
                s: 4,
                t: 2,
                v: 1,
                z: 0
            },
            data = [];
            if (R.is(pathString, array) && R.is(pathString[0], array)) { // rough assumption
                data = pathClone(pathString);
            }
            if (!data.length) {
                Str(pathString).replace(pathCommand, function(a, b, c) {
                    var params = [],
                    name = b.toLowerCase();
                    c.replace(pathValues, function(a, b) {
                        b && params.push(+b);
                    });
                    if (name == "m" && params.length > 2) {
                        data.push([b][concat](params.splice(0, 2)));
                        name = "l";
                        b = b == "m" ? "l" : "L";
                    }
                    if (name == "r") {
                        data.push([b][concat](params));
                    } else
                        while (params.length >= paramCounts[name]) {
                            data.push([b][concat](params.splice(0, paramCounts[name])));
                            if (!paramCounts[name]) {
                                break;
                            }
                        }
                });
            }
            data.toString = R._path2string;
            pth.arr = pathClone(data);
            return data;
        };

        R.parseTransformString = cacher(function(TString) {
            if (!TString) {
                return null;
            }
            var paramCounts = {
                r: 3,
                s: 4,
                t: 2,
                m: 6
            },
            data = [];
            if (R.is(TString, array) && R.is(TString[0], array)) { // rough assumption
                data = pathClone(TString);
            }
            if (!data.length) {
                Str(TString).replace(tCommand, function(a, b, c) {
                    var params = [],
                    name = lowerCase.call(b);
                    c.replace(pathValues, function(a, b) {
                        b && params.push(+b);
                    });
                    data.push([b][concat](params));
                });
            }
            data.toString = R._path2string;
            return data;
        });
        // PATHS
        var paths = function(ps) {
            var p = paths.ps = paths.ps || {};
            if (p[ps]) {
                p[ps].sleep = 100;
            } else {
                p[ps] = {
                    sleep: 100
                };
            }
            setTimeout(function() {
                for (var key in p)
                    if (p[has](key) && key != ps) {
                        p[key].sleep--;
                        !p[key].sleep && delete p[key];
                    }
            });
            return p[ps];
        };

        R.findDotsAtSegment = function(p1x, p1y, c1x, c1y, c2x, c2y, p2x, p2y, t) {
            var t1 = 1 - t,
            t13 = pow(t1, 3),
            t12 = pow(t1, 2),
            t2 = t * t,
            t3 = t2 * t,
            x = t13 * p1x + t12 * 3 * t * c1x + t1 * 3 * t * t * c2x + t3 * p2x,
            y = t13 * p1y + t12 * 3 * t * c1y + t1 * 3 * t * t * c2y + t3 * p2y,
            mx = p1x + 2 * t * (c1x - p1x) + t2 * (c2x - 2 * c1x + p1x),
            my = p1y + 2 * t * (c1y - p1y) + t2 * (c2y - 2 * c1y + p1y),
            nx = c1x + 2 * t * (c2x - c1x) + t2 * (p2x - 2 * c2x + c1x),
            ny = c1y + 2 * t * (c2y - c1y) + t2 * (p2y - 2 * c2y + c1y),
            ax = t1 * p1x + t * c1x,
            ay = t1 * p1y + t * c1y,
            cx = t1 * c2x + t * p2x,
            cy = t1 * c2y + t * p2y,
            alpha = (90 - math.atan2(mx - nx, my - ny) * 180 / PI);
            (mx > nx || my < ny) && (alpha += 180);
            return {
                x: x,
                y: y,
                m: {
                    x: mx,
                    y: my
                },
                n: {
                    x: nx,
                    y: ny
                },
                start: {
                    x: ax,
                    y: ay
                },
                end: {
                    x: cx,
                    y: cy
                },
                alpha: alpha
            };
        };

        R.bezierBBox = function(p1x, p1y, c1x, c1y, c2x, c2y, p2x, p2y) {
            if (!R.is(p1x, "array")) {
                p1x = [p1x, p1y, c1x, c1y, c2x, c2y, p2x, p2y];
            }
            var bbox = curveDim.apply(null, p1x);
            return {
                x: bbox.min.x,
                y: bbox.min.y,
                x2: bbox.max.x,
                y2: bbox.max.y,
                width: bbox.max.x - bbox.min.x,
                height: bbox.max.y - bbox.min.y
            };
        };

        R.isPointInsideBBox = function(bbox, x, y) {
            return x >= bbox.x && x <= bbox.x2 && y >= bbox.y && y <= bbox.y2;
        };

        R.isBBoxIntersect = function(bbox1, bbox2) {
            var i = R.isPointInsideBBox;
            return i(bbox2, bbox1.x, bbox1.y)
            || i(bbox2, bbox1.x2, bbox1.y)
            || i(bbox2, bbox1.x, bbox1.y2)
            || i(bbox2, bbox1.x2, bbox1.y2)
            || i(bbox1, bbox2.x, bbox2.y)
            || i(bbox1, bbox2.x2, bbox2.y)
            || i(bbox1, bbox2.x, bbox2.y2)
            || i(bbox1, bbox2.x2, bbox2.y2)
            || (bbox1.x < bbox2.x2 && bbox1.x > bbox2.x || bbox2.x < bbox1.x2 && bbox2.x > bbox1.x)
            && (bbox1.y < bbox2.y2 && bbox1.y > bbox2.y || bbox2.y < bbox1.y2 && bbox2.y > bbox1.y);
        };
        function base3(t, p1, p2, p3, p4) {
            var t1 = -3 * p1 + 9 * p2 - 9 * p3 + 3 * p4,
            t2 = t * t1 + 6 * p1 - 12 * p2 + 6 * p3;
            return t * t2 - 3 * p1 + 3 * p2;
        }
        function bezlen(x1, y1, x2, y2, x3, y3, x4, y4, z) {
            if (z == null) {
                z = 1;
            }
            z = z > 1 ? 1 : z < 0 ? 0 : z;
            var z2 = z / 2,
            n = 12,
            Tvalues = [-0.1252, 0.1252, -0.3678, 0.3678, -0.5873, 0.5873, -0.7699, 0.7699, -0.9041, 0.9041, -0.9816, 0.9816],
            Cvalues = [0.2491, 0.2491, 0.2335, 0.2335, 0.2032, 0.2032, 0.1601, 0.1601, 0.1069, 0.1069, 0.0472, 0.0472],
            sum = 0;
            for (var i = 0; i < n; i++) {
                var ct = z2 * Tvalues[i] + z2,
                xbase = base3(ct, x1, x2, x3, x4),
                ybase = base3(ct, y1, y2, y3, y4),
                comb = xbase * xbase + ybase * ybase;
                sum += Cvalues[i] * mathSqrt(comb);
            }
            return z2 * sum;
        }
        function getTatLen(x1, y1, x2, y2, x3, y3, x4, y4, ll) {
            if (ll < 0 || bezlen(x1, y1, x2, y2, x3, y3, x4, y4) < ll) {
                return;
            }
            var t = 1,
            step = t / 2,
            t2 = t - step,
            l,
            e = .01;
            l = bezlen(x1, y1, x2, y2, x3, y3, x4, y4, t2);
            while (abs(l - ll) > e) {
                step /= 2;
                t2 += (l < ll ? 1 : -1) * step;
                l = bezlen(x1, y1, x2, y2, x3, y3, x4, y4, t2);
            }
            return t2;
        }
        function intersect(x1, y1, x2, y2, x3, y3, x4, y4) {
            if (
                mmax(x1, x2) < mmin(x3, x4) ||
                mmin(x1, x2) > mmax(x3, x4) ||
                mmax(y1, y2) < mmin(y3, y4) ||
                mmin(y1, y2) > mmax(y3, y4)
                ) {
                return;
            }
            var nx = (x1 * y2 - y1 * x2) * (x3 - x4) - (x1 - x2) * (x3 * y4 - y3 * x4),
            ny = (x1 * y2 - y1 * x2) * (y3 - y4) - (y1 - y2) * (x3 * y4 - y3 * x4),
            denominator = (x1 - x2) * (y3 - y4) - (y1 - y2) * (x3 - x4);

            if (!denominator) {
                return;
            }
            var px = nx / denominator,
            py = ny / denominator,
            px2 = +px.toFixed(2),
            py2 = + py.toFixed(2);
            if (
                px2 < +mmin(x1, x2).toFixed(2) ||
                px2 > +mmax(x1, x2).toFixed(2) ||
                px2 < +mmin(x3, x4).toFixed(2) ||
                px2 > +mmax(x3, x4).toFixed(2) ||
                py2 < +mmin(y1, y2).toFixed(2) ||
                py2 > +mmax(y1, y2).toFixed(2) ||
                py2 < +mmin(y3, y4).toFixed(2) ||
                py2 > +mmax(y3, y4).toFixed(2)
                ) {
                return;
            }
            return {
                x: px,
                y: py
            };
        }
        function inter(bez1, bez2) {
            return interHelper(bez1, bez2);
        }
        function interCount(bez1, bez2) {
            return interHelper(bez1, bez2, 1);
        }
        function interHelper(bez1, bez2, justCount) {
            var bbox1 = R.bezierBBox(bez1),
            bbox2 = R.bezierBBox(bez2);
            if (!R.isBBoxIntersect(bbox1, bbox2)) {
                return justCount ? 0 : [];
            }
            var l1 = bezlen.apply(0, bez1),
            l2 = bezlen.apply(0, bez2),
            n1 = ~~(l1 / 5),
            n2 = ~~(l2 / 5),
            dots1 = [],
            dots2 = [],
            xy = {},
            res = justCount ? 0 : [];
            for (var i = 0; i < n1 + 1; i++) {
                var p = R.findDotsAtSegment.apply(R, bez1.concat(i / n1));
                dots1.push({
                    x: p.x,
                    y: p.y,
                    t: i / n1
                });
            }
            for (i = 0; i < n2 + 1; i++) {
                p = R.findDotsAtSegment.apply(R, bez2.concat(i / n2));
                dots2.push({
                    x: p.x,
                    y: p.y,
                    t: i / n2
                });
            }
            for (i = 0; i < n1; i++) {
                for (var j = 0; j < n2; j++) {
                    var di = dots1[i],
                    di1 = dots1[i + 1],
                    dj = dots2[j],
                    dj1 = dots2[j + 1],
                    ci = abs(di1.x - di.x) < .001 ? "y" : "x",
                    cj = abs(dj1.x - dj.x) < .001 ? "y" : "x",
                    is = intersect(di.x, di.y, di1.x, di1.y, dj.x, dj.y, dj1.x, dj1.y);
                    if (is) {
                        if (xy[is.x.toFixed(4)] == is.y.toFixed(4)) {
                            continue;
                        }
                        xy[is.x.toFixed(4)] = is.y.toFixed(4);
                        var t1 = di.t + abs((is[ci] - di[ci]) / (di1[ci] - di[ci])) * (di1.t - di.t),
                        t2 = dj.t + abs((is[cj] - dj[cj]) / (dj1[cj] - dj[cj])) * (dj1.t - dj.t);
                        if (t1 >= 0 && t1 <= 1 && t2 >= 0 && t2 <= 1) {
                            if (justCount) {
                                res++;
                            } else {
                                res.push({
                                    x: is.x,
                                    y: is.y,
                                    t1: t1,
                                    t2: t2
                                });
                            }
                        }
                    }
                }
            }
            return res;
        }

        R.pathIntersection = function(path1, path2) {
            return interPathHelper(path1, path2);
        };
        R.pathIntersectionNumber = function(path1, path2) {
            return interPathHelper(path1, path2, 1);
        };
        function interPathHelper(path1, path2, justCount) {
            path1 = R._path2curve(path1);
            path2 = R._path2curve(path2);
            var x1, y1, x2, y2, x1m, y1m, x2m, y2m, bez1, bez2,
            res = justCount ? 0 : [];
            for (var i = 0, ii = path1.length; i < ii; i++) {
                var pi = path1[i];
                if (pi[0] == "M") {
                    x1 = x1m = pi[1];
                    y1 = y1m = pi[2];
                } else {
                    if (pi[0] == "C") {
                        bez1 = [x1, y1].concat(pi.slice(1));
                        x1 = bez1[6];
                        y1 = bez1[7];
                    } else {
                        bez1 = [x1, y1, x1, y1, x1m, y1m, x1m, y1m];
                        x1 = x1m;
                        y1 = y1m;
                    }
                    for (var j = 0, jj = path2.length; j < jj; j++) {
                        var pj = path2[j];
                        if (pj[0] == "M") {
                            x2 = x2m = pj[1];
                            y2 = y2m = pj[2];
                        } else {
                            if (pj[0] == "C") {
                                bez2 = [x2, y2].concat(pj.slice(1));
                                x2 = bez2[6];
                                y2 = bez2[7];
                            } else {
                                bez2 = [x2, y2, x2, y2, x2m, y2m, x2m, y2m];
                                x2 = x2m;
                                y2 = y2m;
                            }
                            var intr = interHelper(bez1, bez2, justCount);
                            if (justCount) {
                                res += intr;
                            } else {
                                for (var k = 0, kk = intr.length; k < kk; k++) {
                                    intr[k].segment1 = i;
                                    intr[k].segment2 = j;
                                    intr[k].bez1 = bez1;
                                    intr[k].bez2 = bez2;
                                }
                                res = res.concat(intr);
                            }
                        }
                    }
                }
            }
            return res;
        }

        R.isPointInsidePath = function(path, x, y) {
            var bbox = R.pathBBox(path);
            return R.isPointInsideBBox(bbox, x, y) &&
            interPathHelper(path, [["M", x, y], ["H", bbox.x2 + 10]], 1) % 2 == 1;
        };
        R._removedFactory = function(methodname) {
            return function() {
                eve("raphael.log", null, "Rapha\xebl: you are calling to method \u201c" + methodname + "\u201d of removed object", methodname);
            };
        };

        var pathDimensions = R.pathBBox = function(path) {
            var pth = paths(path);
            if (pth.bbox) {
                return pth.bbox;
            }
            if (!path) {
                return {
                    x: 0,
                    y: 0,
                    width: 0,
                    height: 0,
                    x2: 0,
                    y2: 0
                };
            }
            path = path2curve(path);
            var x = 0,
            y = 0,
            X = [],
            Y = [],
            p;
            for (var i = 0, ii = path.length; i < ii; i++) {
                p = path[i];
                if (p[0] == "M") {
                    x = p[1];
                    y = p[2];
                    X.push(x);
                    Y.push(y);
                } else {
                    var dim = curveDim(x, y, p[1], p[2], p[3], p[4], p[5], p[6]);
                    X = X[concat](dim.min.x, dim.max.x);
                    Y = Y[concat](dim.min.y, dim.max.y);
                    x = p[5];
                    y = p[6];
                }
            }
            var xmin = mmin[apply](0, X),
            ymin = mmin[apply](0, Y),
            xmax = mmax[apply](0, X),
            ymax = mmax[apply](0, Y),
            bb = {
                x: xmin,
                y: ymin,
                x2: xmax,
                y2: ymax,
                width: xmax - xmin,
                height: ymax - ymin
            };
            pth.bbox = clone(bb);
            return bb;
        },
        pathClone = function(pathArray) {
            var res = clone(pathArray);
            res.toString = R._path2string;
            return res;
        },
        pathToRelative = R._pathToRelative = function(pathArray) {
            var pth = paths(pathArray);
            if (pth.rel) {
                return pathClone(pth.rel);
            }
            if (!R.is(pathArray, array) || !R.is(pathArray && pathArray[0], array)) { // rough assumption
                pathArray = R.parsePathString(pathArray);
            }
            var res = [],
            x = 0,
            y = 0,
            mx = 0,
            my = 0,
            start = 0;
            if (pathArray[0][0] == "M") {
                x = pathArray[0][1];
                y = pathArray[0][2];
                mx = x;
                my = y;
                start++;
                res.push(["M", x, y]);
            }
            for (var i = start, ii = pathArray.length; i < ii; i++) {
                var r = res[i] = [],
                pa = pathArray[i];
                if (pa[0] != lowerCase.call(pa[0])) {
                    r[0] = lowerCase.call(pa[0]);
                    switch (r[0]) {
                        case "a":
                            r[1] = pa[1];
                            r[2] = pa[2];
                            r[3] = pa[3];
                            r[4] = pa[4];
                            r[5] = pa[5];
                            r[6] = +(pa[6] - x).toFixed(3);
                            r[7] = +(pa[7] - y).toFixed(3);
                            break;
                        case "v":
                            r[1] = +(pa[1] - y).toFixed(3);
                            break;
                        case "m":
                            mx = pa[1];
                            my = pa[2];
                        default:
                            for (var j = 1, jj = pa.length; j < jj; j++) {
                                r[j] = +(pa[j] - ((j % 2) ? x : y)).toFixed(3);
                            }
                    }
                } else {
                    r = res[i] = [];
                    if (pa[0] == "m") {
                        mx = pa[1] + x;
                        my = pa[2] + y;
                    }
                    for (var k = 0, kk = pa.length; k < kk; k++) {
                        res[i][k] = pa[k];
                    }
                }
                var len = res[i].length;
                switch (res[i][0]) {
                    case "z":
                        x = mx;
                        y = my;
                        break;
                    case "h":
                        x += +res[i][len - 1];
                        break;
                    case "v":
                        y += +res[i][len - 1];
                        break;
                    default:
                        x += +res[i][len - 2];
                        y += +res[i][len - 1];
                }
            }
            res.toString = R._path2string;
            pth.rel = pathClone(res);
            return res;
        },
        pathToAbsolute = R._pathToAbsolute = function(pathArray) {
            var pth = paths(pathArray), res;
            if (pth.abs) {
                return pathClone(pth.abs);
            }
            if (!R.is(pathArray, array) || !R.is(pathArray && pathArray[0], array)) { // rough assumption
                pathArray = R.parsePathString(pathArray);
            }
            if (!pathArray || !pathArray.length) {
                res = ["M", 0, 0];
                res.toString = R._path2string;
                return res;
            }
            var x = 0,
                y = 0,
                mx = 0,
                my = 0,
                start = 0;
            res = [];
            if (pathArray[0][0] == "M") {
                x = +pathArray[0][1];
                y = +pathArray[0][2];
                mx = x;
                my = y;
                start++;
                res[0] = ["M", x, y];
            }
            var crz = pathArray.length == 3 && pathArray[0][0] == "M" && pathArray[1][0].toUpperCase() == "R" && pathArray[2][0].toUpperCase() == "Z";
            for (var r, pa, i = start, ii = pathArray.length; i < ii; i++) {
                res.push(r = []);
                pa = pathArray[i];
                if (pa[0] != upperCase.call(pa[0])) {
                    r[0] = upperCase.call(pa[0]);
                    switch (r[0]) {
                        case "A":
                            r[1] = pa[1];
                            r[2] = pa[2];
                            r[3] = pa[3];
                            r[4] = pa[4];
                            r[5] = pa[5];
                            r[6] = +(pa[6] + x);
                            r[7] = +(pa[7] + y);
                            break;
                        case "V":
                            r[1] = +pa[1] + y;
                            break;
                        case "H":
                            r[1] = +pa[1] + x;
                            break;
                        case "R":
                            var dots = [x, y][concat](pa.slice(1));
                            for (var j = 2, jj = dots.length; j < jj; j++) {
                                dots[j] = +dots[j] + x;
                                dots[++j] = +dots[j] + y;
                            }
                            res.pop();
                            res = res[concat](catmullRom2bezier(dots, crz));
                            break;
                        case "M":
                            mx = +pa[1] + x;
                            my = +pa[2] + y;
                        default:
                            for (j = 1, jj = pa.length; j < jj; j++) {
                                r[j] = +pa[j] + ((j % 2) ? x : y);
                            }
                    }
                } else if (pa[0] == "R") {
                    dots = [x, y][concat](pa.slice(1));
                    res.pop();
                    res = res[concat](catmullRom2bezier(dots, crz));
                    r = ["R"][concat](pa.slice(-2));
                } else {
                    for (var k = 0, kk = pa.length; k < kk; k++) {
                        r[k] = pa[k];
                    }
                }
                switch (r[0]) {
                    case "Z":
                        x = mx;
                        y = my;
                        break;
                    case "H":
                        x = r[1];
                        break;
                    case "V":
                        y = r[1];
                        break;
                    case "M":
                        mx = r[r.length - 2];
                        my = r[r.length - 1];
                    default:
                        x = r[r.length - 2];
                        y = r[r.length - 1];
                }
            }
            res.toString = R._path2string;
            pth.abs = pathClone(res);
            return res;
        },
        l2c = function(x1, y1, x2, y2) {
            return [x1, y1, x2, y2, x2, y2];
        },
        q2c = function(x1, y1, ax, ay, x2, y2) {
            var _13 = 1 / 3,
            _23 = 2 / 3;
            return [
            _13 * x1 + _23 * ax,
            _13 * y1 + _23 * ay,
            _13 * x2 + _23 * ax,
            _13 * y2 + _23 * ay,
            x2,
            y2
            ];
        },
        a2c = function(x1, y1, rx, ry, angle, large_arc_flag, sweep_flag, x2, y2, recursive) {
            // for more information of where this math came from visit:
            // http://www.w3.org/TR/SVG11/implnote.html#ArcImplementationNotes
            var _120 = PI * 120 / 180,
            rad = deg2rad * (+angle || 0),
            res = [],
            xy,
            rotate = cacher(function(x, y, rad) {
                var X = x * mathCos(rad) - y * mathSin(rad),
                Y = x * mathSin(rad) + y * mathCos(rad);
                return {
                    x: X,
                    y: Y
                };
            });
            if (!recursive) {
                xy = rotate(x1, y1, -rad);
                x1 = xy.x;
                y1 = xy.y;
                xy = rotate(x2, y2, -rad);
                x2 = xy.x;
                y2 = xy.y;
                var cos = mathCos(deg2rad * angle),
                sin = mathSin(deg2rad * angle),
                x = (x1 - x2) / 2,
                y = (y1 - y2) / 2;
                var h = (x * x) / (rx * rx) + (y * y) / (ry * ry);
                if (h > 1) {
                    h = mathSqrt(h);
                    rx = h * rx;
                    ry = h * ry;
                }
                var rx2 = rx * rx,
                ry2 = ry * ry,
                k = (large_arc_flag == sweep_flag ? -1 : 1) *
                mathSqrt(abs((rx2 * ry2 - rx2 * y * y - ry2 * x * x) / (rx2 * y * y + ry2 * x * x))),
                cx = k * rx * y / ry + (x1 + x2) / 2,
                cy = k * -ry * x / rx + (y1 + y2) / 2,
                f1 = math.asin(((y1 - cy) / ry).toFixed(9)),
                f2 = math.asin(((y2 - cy) / ry).toFixed(9));

                f1 = x1 < cx ? PI - f1 : f1;
                f2 = x2 < cx ? PI - f2 : f2;
                f1 < 0 && (f1 = PI * 2 + f1);
                f2 < 0 && (f2 = PI * 2 + f2);
                if (sweep_flag && f1 > f2) {
                    f1 = f1 - PI * 2;
                }
                if (!sweep_flag && f2 > f1) {
                    f2 = f2 - PI * 2;
                }
            } else {
                f1 = recursive[0];
                f2 = recursive[1];
                cx = recursive[2];
                cy = recursive[3];
            }
            var df = f2 - f1;
            if (abs(df) > _120) {
                var f2old = f2,
                x2old = x2,
                y2old = y2;
                f2 = f1 + _120 * (sweep_flag && f2 > f1 ? 1 : -1);
                x2 = cx + rx * mathCos(f2);
                y2 = cy + ry * mathSin(f2);
                res = a2c(x2, y2, rx, ry, angle, 0, sweep_flag, x2old, y2old, [f2, f2old, cx, cy]);
            }
            df = f2 - f1;
            var c1 = mathCos(f1),
            s1 = mathSin(f1),
            c2 = mathCos(f2),
            s2 = mathSin(f2),
            t = math.tan(df / 4),
            hx = 4 / 3 * rx * t,
            hy = 4 / 3 * ry * t,
            m1 = [x1, y1],
            m2 = [x1 + hx * s1, y1 - hy * c1],
            m3 = [x2 + hx * s2, y2 - hy * c2],
            m4 = [x2, y2];
            m2[0] = 2 * m1[0] - m2[0];
            m2[1] = 2 * m1[1] - m2[1];
            if (recursive) {
                return [m2, m3, m4][concat](res);
            } else {
                res = [m2, m3, m4][concat](res).join()[split](",");
                var newres = [];
                for (var i = 0, ii = res.length; i < ii; i++) {
                    newres[i] = i % 2 ? rotate(res[i - 1], res[i], rad).y : rotate(res[i], res[i + 1], rad).x;
                }
                return newres;
            }
        },
        findDotAtSegment = function(p1x, p1y, c1x, c1y, c2x, c2y, p2x, p2y, t) {
            var t1 = 1 - t;
            return {
                x: pow(t1, 3) * p1x + pow(t1, 2) * 3 * t * c1x + t1 * 3 * t * t * c2x + pow(t, 3) * p2x,
                y: pow(t1, 3) * p1y + pow(t1, 2) * 3 * t * c1y + t1 * 3 * t * t * c2y + pow(t, 3) * p2y
            };
        },
        curveDim = cacher(function(p1x, p1y, c1x, c1y, c2x, c2y, p2x, p2y) {
            var a = (c2x - 2 * c1x + p1x) - (p2x - 2 * c2x + c1x),
            b = 2 * (c1x - p1x) - 2 * (c2x - c1x),
            c = p1x - c1x,
            t1 = (-b + mathSqrt(b * b - 4 * a * c)) / 2 / a,
            t2 = (-b - mathSqrt(b * b - 4 * a * c)) / 2 / a,
            y = [p1y, p2y],
            x = [p1x, p2x],
            dot;
            abs(t1) > "1e12" && (t1 = .5);
            abs(t2) > "1e12" && (t2 = .5);
            if (t1 > 0 && t1 < 1) {
                dot = findDotAtSegment(p1x, p1y, c1x, c1y, c2x, c2y, p2x, p2y, t1);
                x.push(dot.x);
                y.push(dot.y);
            }
            if (t2 > 0 && t2 < 1) {
                dot = findDotAtSegment(p1x, p1y, c1x, c1y, c2x, c2y, p2x, p2y, t2);
                x.push(dot.x);
                y.push(dot.y);
            }
            a = (c2y - 2 * c1y + p1y) - (p2y - 2 * c2y + c1y);
            b = 2 * (c1y - p1y) - 2 * (c2y - c1y);
            c = p1y - c1y;
            t1 = (-b + mathSqrt(b * b - 4 * a * c)) / 2 / a;
            t2 = (-b - mathSqrt(b * b - 4 * a * c)) / 2 / a;
            abs(t1) > "1e12" && (t1 = .5);
            abs(t2) > "1e12" && (t2 = .5);
            if (t1 > 0 && t1 < 1) {
                dot = findDotAtSegment(p1x, p1y, c1x, c1y, c2x, c2y, p2x, p2y, t1);
                x.push(dot.x);
                y.push(dot.y);
            }
            if (t2 > 0 && t2 < 1) {
                dot = findDotAtSegment(p1x, p1y, c1x, c1y, c2x, c2y, p2x, p2y, t2);
                x.push(dot.x);
                y.push(dot.y);
            }
            return {
                min: {
                    x: mmin[apply](0, x),
                    y: mmin[apply](0, y)
                },
                max: {
                    x: mmax[apply](0, x),
                    y: mmax[apply](0, y)
                }
            };
        }),
        path2curve = R._path2curve = cacher(function(path, path2) {
            var pth = !path2 && paths(path);
            if (!path2 && pth.curve) {
                return pathClone(pth.curve);
            }
            var p = pathToAbsolute(path),
            p2 = path2 && pathToAbsolute(path2),
            attrs = {
                x: 0,
                y: 0,
                bx: 0,
                by: 0,
                X: 0,
                Y: 0,
                qx: null,
                qy: null
            },
            attrs2 = {
                x: 0,
                y: 0,
                bx: 0,
                by: 0,
                X: 0,
                Y: 0,
                qx: null,
                qy: null
            },
            processPath = function(path, d) {
                var nx, ny;
                if (!path) {
                    return ["C", d.x, d.y, d.x, d.y, d.x, d.y];
                }
                !(path[0] in {
                    T: 1,
                    Q: 1
                }) && (d.qx = d.qy = null);
                switch (path[0]) {
                    case "M":
                        d.X = path[1];
                        d.Y = path[2];
                        break;
                    case "A":
                        path = ["C"][concat](a2c[apply](0, [d.x, d.y][concat](path.slice(1))));
                        break;
                    case "S":
                        nx = d.x + (d.x - (d.bx || d.x));
                        ny = d.y + (d.y - (d.by || d.y));
                        path = ["C", nx, ny][concat](path.slice(1));
                        break;
                    case "T":
                        d.qx = d.x + (d.x - (d.qx || d.x));
                        d.qy = d.y + (d.y - (d.qy || d.y));
                        path = ["C"][concat](q2c(d.x, d.y, d.qx, d.qy, path[1], path[2]));
                        break;
                    case "Q":
                        d.qx = path[1];
                        d.qy = path[2];
                        path = ["C"][concat](q2c(d.x, d.y, path[1], path[2], path[3], path[4]));
                        break;
                    case "L":
                        path = ["C"][concat](l2c(d.x, d.y, path[1], path[2]));
                        break;
                    case "H":
                        path = ["C"][concat](l2c(d.x, d.y, path[1], d.y));
                        break;
                    case "V":
                        path = ["C"][concat](l2c(d.x, d.y, d.x, path[1]));
                        break;
                    case "Z":
                        path = ["C"][concat](l2c(d.x, d.y, d.X, d.Y));
                        break;
                }
                return path;
            },
            fixArc = function(pp, i) {
                if (pp[i].length > 7) {
                    pp[i].shift();
                    var pi = pp[i];
                    while (pi.length) {
                        pp.splice(i++, 0, ["C"][concat](pi.splice(0, 6)));
                    }
                    pp.splice(i, 1);
                    ii = mmax(p.length, p2 && p2.length || 0);
                }
            },
            fixM = function(path1, path2, a1, a2, i) {
                if (path1 && path2 && path1[i][0] == "M" && path2[i][0] != "M") {
                    path2.splice(i, 0, ["M", a2.x, a2.y]);
                    a1.bx = 0;
                    a1.by = 0;
                    a1.x = path1[i][1];
                    a1.y = path1[i][2];
                    ii = mmax(p.length, p2 && p2.length || 0);
                }
            };
            for (var i = 0, ii = mmax(p.length, p2 && p2.length || 0); i < ii; i++) {
                p[i] = processPath(p[i], attrs);
                fixArc(p, i);
                p2 && (p2[i] = processPath(p2[i], attrs2));
                p2 && fixArc(p2, i);
                fixM(p, p2, attrs, attrs2, i);
                fixM(p2, p, attrs2, attrs, i);
                var seg = p[i],
                seg2 = p2 && p2[i],
                seglen = seg.length,
                seg2len = p2 && seg2.length;
                attrs.x = seg[seglen - 2];
                attrs.y = seg[seglen - 1];
                attrs.bx = toFloat(seg[seglen - 4]) || attrs.x;
                attrs.by = toFloat(seg[seglen - 3]) || attrs.y;
                attrs2.bx = p2 && (toFloat(seg2[seg2len - 4]) || attrs2.x);
                attrs2.by = p2 && (toFloat(seg2[seg2len - 3]) || attrs2.y);
                attrs2.x = p2 && seg2[seg2len - 2];
                attrs2.y = p2 && seg2[seg2len - 1];
            }
            if (!p2) {
                pth.curve = pathClone(p);
            }
            return p2 ? [p, p2] : p;
        }, null, pathClone),
        parseDots = R._parseDots = cacher(function(gradient) {
            var dots = [];
            for (var i = 0, ii = gradient.length; i < ii; i++) {
                var dot = {},
                par = gradient[i].match(/^([^:]*):?([\d\.]*)/);
                dot.color = R.getRGB(par[1]);
                if (dot.color.error) {
                    return null;
                }
                //store opacity information
                dot.opacity = dot.color.opacity;
                dot.color = dot.color.hex;
                par[2] && (dot.offset = par[2] + "%");
                dots.push(dot);
            }
            for (i = 1, ii = dots.length - 1; i < ii; i++) {
                if (!dots[i].offset) {
                    var start = toFloat(dots[i - 1].offset || 0),
                    end = 0;
                    for (var j = i + 1; j < ii; j++) {
                        if (dots[j].offset) {
                            end = dots[j].offset;
                            break;
                        }
                    }
                    if (!end) {
                        end = 100;
                        j = ii;
                    }
                    end = toFloat(end);
                    var d = (end - start) / (j - i + 1);
                    for (; i < j; i++) {
                        start += d;
                        dots[i].offset = start + "%";
                    }
                }
            }
            return dots;
        }),
        tear = R._tear = function(el, paper) {
            el == paper.top && (paper.top = el.prev);
            el == paper.bottom && (paper.bottom = el.next);
            el.next && (el.next.prev = el.prev);
            el.prev && (el.prev.next = el.next);
        },
        tofront = R._tofront = function(el, paper) {
            if (paper.top === el) {
                return false;
            }
            tear(el, paper);
            el.next = null;
            el.prev = paper.top;
            paper.top.next = el;
            paper.top = el;
            return true;
        },
        toback = R._toback = function(el, paper) {
            if (paper.bottom === el) {
                return false;
            }
            tear(el, paper);
            el.next = paper.bottom;
            el.prev = null;
            paper.bottom.prev = el;
            paper.bottom = el;
            return true;
        },
        insertafter = R._insertafter = function(el, el2, paper, paper2) {
            tear(el, paper);
            el.parent = paper2;
            el2 === paper2.top && (paper2.top = el);
            el2.next && (el2.next.prev = el);
            el.next = el2.next;
            el.prev = el2;
            el2.next = el;
        },
        insertbefore = R._insertbefore = function(el, el2, paper, paper2) {
            tear(el, paper);
            el.parent = paper2;
            el2 === paper2.bottom && (paper2.bottom = el);
            el2.prev && (el2.prev.next = el);
            el.prev = el2.prev;
            el2.prev = el;
            el.next = el2;
        },
        toMatrix = R.toMatrix = function(path, transform) {
            var bb = pathDimensions(path),
            el = {
                _: {
                    transform: E
                },
                getBBox: function() {
                    return bb;
                }
            };
            extractTransform(el, transform);
            return el.matrix;
        },
        transformPath = R.transformPath = function(path, transform) {
            return mapPath(path, toMatrix(path, transform));
        },
        extractTransform = R._extractTransform = function(el, tstr) {
            if (tstr == null) {
                return el._.transform;
            }
            tstr = Str(tstr).replace(/\.{3}|\u2026/g, el._.transform || E);
            var tdata = R.parseTransformString(tstr),
            deg = 0,
            dx = 0,
            dy = 0,
            sx = 1,
            sy = 1,
            _ = el._,
            m = new Matrix;
            _.transform = tdata || [];
            if (tdata) {
                for (var i = 0, ii = tdata.length; i < ii; i++) {
                    var t = tdata[i],
                    tlen = t.length,
                    command = Str(t[0]).toLowerCase(),
                    absolute = t[0] != command,
                    inver = absolute ? m.invert() : 0,
                    x1,
                    y1,
                    x2,
                    y2,
                    bb;
                    if (command == "t" && tlen == 3) {
                        if (absolute) {
                            x1 = inver.x(0, 0);
                            y1 = inver.y(0, 0);
                            x2 = inver.x(t[1], t[2]);
                            y2 = inver.y(t[1], t[2]);
                            m.translate(x2 - x1, y2 - y1);
                        } else {
                            m.translate(t[1], t[2]);
                        }
                    } else if (command == "r") {
                        if (tlen == 2) {
                            bb = bb || el.getBBox(1);
                            m.rotate(t[1], bb.x + bb.width / 2, bb.y + bb.height / 2);
                            deg += t[1];
                        } else if (tlen == 4) {
                            if (absolute) {
                                x2 = inver.x(t[2], t[3]);
                                y2 = inver.y(t[2], t[3]);
                                m.rotate(t[1], x2, y2);
                            } else {
                                m.rotate(t[1], t[2], t[3]);
                            }
                            deg += t[1];
                        }
                    } else if (command == "s") {
                        if (tlen == 2 || tlen == 3) {
                            bb = bb || el.getBBox(1);
                            m.scale(t[1], t[tlen - 1], bb.x + bb.width / 2, bb.y + bb.height / 2);
                            sx *= t[1];
                            sy *= t[tlen - 1];
                        } else if (tlen == 5) {
                            if (absolute) {
                                x2 = inver.x(t[3], t[4]);
                                y2 = inver.y(t[3], t[4]);
                                m.scale(t[1], t[2], x2, y2);
                            } else {
                                m.scale(t[1], t[2], t[3], t[4]);
                            }
                            sx *= t[1];
                            sy *= t[2];
                        }
                    } else if (command == "m" && tlen == 7) {
                        m.add(t[1], t[2], t[3], t[4], t[5], t[6]);
                    }
                    _.dirtyT = 1;
                    el.matrix = m;
                }
            }


            el.matrix = m;

            _.sx = sx;
            _.sy = sy;
            _.deg = deg;
            _.dx = dx = m.e;
            _.dy = dy = m.f;

            if (sx == 1 && sy == 1 && !deg && _.bbox) {
                _.bbox.x += +dx;
                _.bbox.y += +dy;
            } else {
                _.dirtyT = 1;
            }
        },
        getEmpty = function(item) {
            var l = item[0];
            switch (l.toLowerCase()) {
                case "t":
                    return [l, 0, 0];
                case "m":
                    return [l, 1, 0, 0, 1, 0, 0];
                case "r":
                    if (item.length == 4) {
                        return [l, 0, item[2], item[3]];
                    } else {
                        return [l, 0];
                    }
                case "s":
                    if (item.length == 5) {
                        return [l, 1, 1, item[3], item[4]];
                    } else if (item.length == 3) {
                        return [l, 1, 1];
                    } else {
                        return [l, 1];
                    }
            }
        },
        equaliseTransform = R._equaliseTransform = function(t1, t2) {
            t2 = Str(t2).replace(/\.{3}|\u2026/g, t1);
            t1 = R.parseTransformString(t1) || [];
            t2 = R.parseTransformString(t2) || [];
            var maxlength = mmax(t1.length, t2.length),
            from = [],
            to = [],
            i = 0, j, jj,
            tt1, tt2;
            for (; i < maxlength; i++) {
                tt1 = t1[i] || getEmpty(t2[i]);
                tt2 = t2[i] || getEmpty(tt1);
                if ((tt1[0] != tt2[0]) ||
                    (tt1[0].toLowerCase() == "r" && (tt1[2] != tt2[2] || tt1[3] != tt2[3])) ||
                    (tt1[0].toLowerCase() == "s" && (tt1[3] != tt2[3] || tt1[4] != tt2[4]))
                    ) {
                    return;
                }
                from[i] = [];
                to[i] = [];
                for (j = 0, jj = mmax(tt1.length, tt2.length); j < jj; j++) {
                    j in tt1 && (from[i][j] = tt1[j]);
                    j in tt2 && (to[i][j] = tt2[j]);
                }
            }
            return {
                from: from,
                to: to
            };
        };
        R._getContainer = function(x, y, w, h) {
            var container;
            container = h == null && !R.is(x, "object") ? g.doc.getElementById(x) : x;
            if (container == null) {
                return;
            }
            if (container.tagName) {
                if (y == null) {
                    return {
                        container: container,
                        width: container.style.pixelWidth || container.offsetWidth,
                        height: container.style.pixelHeight || container.offsetHeight
                    };
                } else {
                    return {
                        container: container,
                        width: y,
                        height: w
                    };
                }
            }
            return {
                container: 1,
                x: x,
                y: y,
                width: w,
                height: h
            };
        };

        R.pathToRelative = pathToRelative;
        R._engine = {};

        R.path2curve = path2curve;

        R.matrix = function(a, b, c, d, e, f) {
            return new Matrix(a, b, c, d, e, f);
        };
        function Matrix(a, b, c, d, e, f) {
            if (a != null) {
                this.a = +a;
                this.b = +b;
                this.c = +c;
                this.d = +d;
                this.e = +e;
                this.f = +f;
            } else {
                this.a = 1;
                this.b = 0;
                this.c = 0;
                this.d = 1;
                this.e = 0;
                this.f = 0;
            }
        }
        (function(matrixproto) {

            matrixproto.add = function(a, b, c, d, e, f) {
                var out = [[], [], []],
                m = [[this.a, this.c, this.e], [this.b, this.d, this.f], [0, 0, 1]],
                matrix = [[a, c, e], [b, d, f], [0, 0, 1]],
                x, y, z, res;

                if (a && a instanceof Matrix) {
                    matrix = [[a.a, a.c, a.e], [a.b, a.d, a.f], [0, 0, 1]];
                }

                for (x = 0; x < 3; x++) {
                    for (y = 0; y < 3; y++) {
                        res = 0;
                        for (z = 0; z < 3; z++) {
                            res += m[x][z] * matrix[z][y];
                        }
                        out[x][y] = res;
                    }
                }
                this.a = out[0][0];
                this.b = out[1][0];
                this.c = out[0][1];
                this.d = out[1][1];
                this.e = out[0][2];
                this.f = out[1][2];
            };

            matrixproto.invert = function() {
                var me = this,
                x = me.a * me.d - me.b * me.c;
                return new Matrix(me.d / x, -me.b / x, -me.c / x, me.a / x, (me.c * me.f - me.d * me.e) / x, (me.b * me.e - me.a * me.f) / x);
            };

            matrixproto.clone = function() {
                return new Matrix(this.a, this.b, this.c, this.d, this.e, this.f);
            };

            matrixproto.translate = function(x, y) {
                this.add(1, 0, 0, 1, x, y);
            };

            matrixproto.scale = function(x, y, cx, cy) {
                y == null && (y = x);
                (cx || cy) && this.add(1, 0, 0, 1, cx, cy);
                this.add(x, 0, 0, y, 0, 0);
                (cx || cy) && this.add(1, 0, 0, 1, -cx, -cy);
            };

            matrixproto.rotate = function(a, x, y) {
                a = R.rad(a);
                x = x || 0;
                y = y || 0;
                var cos = +mathCos(a).toFixed(9),
                sin = + mathSin(a).toFixed(9);
                this.add(cos, sin, -sin, cos, x, y);
                this.add(1, 0, 0, 1, -x, -y);
            };

            matrixproto.x = function(x, y) {
                return x * this.a + y * this.c + this.e;
            };

            matrixproto.y = function(x, y) {
                return x * this.b + y * this.d + this.f;
            };
            matrixproto.get = function(i) {
                return +this[Str.fromCharCode(97 + i)].toFixed(4);
            };
            matrixproto.toString = function() {
                return R.svg ?
                "matrix(" + [this.get(0), this.get(1), this.get(2), this.get(3), this.get(4), this.get(5)].join() + ")" :
                [this.get(0), this.get(2), this.get(1), this.get(3), 0, 0].join();
            };
            matrixproto.toMatrixString = function() {
                return "matrix(" + [this.get(0), this.get(1), this.get(2), this.get(3), this.get(4), this.get(5)].join() + ")";
            };
            matrixproto.toFilter = function() {
                return "progid:DXImageTransform.Microsoft.Matrix(M11=" + this.get(0) +
                ", M12=" + this.get(2) + ", M21=" + this.get(1) + ", M22=" + this.get(3) +
                ", Dx=" + this.get(4) + ", Dy=" + this.get(5) + ", sizingmethod='auto expand')";
            };
            matrixproto.offset = function() {
                return [this.e.toFixed(4), this.f.toFixed(4)];
            };
            function norm(a) {
                return a[0] * a[0] + a[1] * a[1];
            }
            function normalize(a) {
                var mag = mathSqrt(norm(a));
                a[0] && (a[0] /= mag);
                a[1] && (a[1] /= mag);
            }

            matrixproto.split = function() {
                var out = {};
                // translation
                out.dx = this.e;
                out.dy = this.f;

                // scale and shear
                var row = [[this.a, this.c], [this.b, this.d]];
                out.scalex = mathSqrt(norm(row[0]));
                normalize(row[0]);

                out.shear = row[0][0] * row[1][0] + row[0][1] * row[1][1];
                row[1] = [row[1][0] - row[0][0] * out.shear, row[1][1] - row[0][1] * out.shear];

                out.scaley = mathSqrt(norm(row[1]));
                normalize(row[1]);
                out.shear /= out.scaley;

                // rotation
                var sin = -row[0][1],
                cos = row[1][1];
                if (cos < 0) {
                    out.rotate = R.deg(math.acos(cos));
                    if (sin < 0) {
                        out.rotate = 360 - out.rotate;
                    }
                } else {
                    out.rotate = R.deg(math.asin(sin));
                }

                out.isSimple = !+out.shear.toFixed(9) && (out.scalex.toFixed(9) == out.scaley.toFixed(9) || !out.rotate);
                out.isSuperSimple = !+out.shear.toFixed(9) && out.scalex.toFixed(9) == out.scaley.toFixed(9) && !out.rotate;
                out.noRotation = !+out.shear.toFixed(9) && !out.rotate;
                return out;
            };

            matrixproto.toTransformString = function(shorter) {
                var s = shorter || this[split]();
                if (s.isSimple) {
                    s.scalex = +s.scalex.toFixed(4);
                    s.scaley = +s.scaley.toFixed(4);
                    s.rotate = +s.rotate.toFixed(4);
                    return  (s.dx || s.dy ? "t" + [s.dx, s.dy] : E) +
                    (s.scalex != 1 || s.scaley != 1 ? "s" + [s.scalex, s.scaley, 0, 0] : E) +
                    (s.rotate ? "r" + [s.rotate, 0, 0] : E);
                } else {
                    return "m" + [this.get(0), this.get(1), this.get(2), this.get(3), this.get(4), this.get(5)];
                }
            };
        })(Matrix.prototype);

        // WebKit rendering bug workaround method
        var version = navigator.userAgent.match(/Version\/(.*?)\s/) || navigator.userAgent.match(/Chrome\/(\d+)/);
        if ((navigator.vendor == "Apple Computer, Inc.") && (version && version[1] < 4 || navigator.platform.slice(0, 2) == "iP") ||
            (navigator.vendor == "Google Inc." && version && version[1] < 8)) {

            paperproto.safari = function() {
                var rect = this.rect(-99, -99, this.width + 99, this.height + 99).attr({
                    stroke: "none"
                });
                setTimeout(function() {
                    rect.remove();
                });
                return true;
            };
        } else {
            paperproto.safari = fun;
        }

        var preventDefault = function() {
            this.returnValue = false;
        },
        preventTouch = function() {
            return this.originalEvent.preventDefault();
        },
        stopPropagation = function() {
            this.cancelBubble = true;
        },
        stopTouch = function() {
            return this.originalEvent.stopPropagation();
        },
        addEvent = R.addEvent = (function() {
            if (g.doc.addEventListener) {
                return function(obj, type, fn, element) {
                    var realName = supportsTouch && touchMap[type] ? touchMap[type] : type,
                    f = function(e) {
                        var scrollY = g.doc.documentElement.scrollTop || g.doc.body.scrollTop,
                            scrollX = g.doc.documentElement.scrollLeft || g.doc.body.scrollLeft;
                        if (supportsTouch && touchMap[has](type)) {
                            for (var i = 0, ii = e.targetTouches && e.targetTouches.length; i < ii; i++) {
                                if (e.targetTouches[i].target == obj) {
                                    var olde = e;
                                    e = e.targetTouches[i];
                                    e.originalEvent = olde;
                                    e.preventDefault = preventTouch;
                                    e.stopPropagation = stopTouch;
                                    break;
                                }
                            }
                        }
                        return fn.call(element, e, e.clientX + scrollX, e.clientY + scrollY);
                    };
                    obj.addEventListener(realName, f, false);
                    return function() {
                        obj.removeEventListener(realName, f, false);
                        return true;
                    };
                };
            } else if (g.doc.attachEvent) {
                return function(obj, type, fn, element) {
                    var f = function(e) {
                        e = e || g.win.event;
                        var scrollY = g.doc.documentElement.scrollTop || g.doc.body.scrollTop,
                        scrollX = g.doc.documentElement.scrollLeft || g.doc.body.scrollLeft,
                        x = e.clientX + scrollX,
                        y = e.clientY + scrollY;
                        e.preventDefault = e.preventDefault || preventDefault;
                        e.stopPropagation = e.stopPropagation || stopPropagation;
                        return fn.call(element, e, x, y);
                    };
                    obj.attachEvent("on" + type, f);
                    var detacher = function() {
                        obj.detachEvent("on" + type, f);
                        return true;
                    };
                    return detacher;
                };
            }
        })(),
        drag = [],
        dragMove = function(e) {
            var x = e.clientX,
            y = e.clientY,
            scrollY = g.doc.documentElement.scrollTop || g.doc.body.scrollTop,
            scrollX = g.doc.documentElement.scrollLeft || g.doc.body.scrollLeft,
            dragi,
            j = drag.length;
            while (j--) {
                dragi = drag[j];
                if (supportsTouch) {
                    var i = e.touches.length,
                    touch;
                    while (i--) {
                        touch = e.touches[i];
                        if (touch.identifier == dragi.el._drag.id) {
                            x = touch.clientX;
                            y = touch.clientY;
                            (e.originalEvent ? e.originalEvent : e).preventDefault();
                            break;
                        }
                    }
                } else {
                    e.preventDefault();
                }
                var node = dragi.el.node,
                o,
                next = node.nextSibling,
                parent = node.parentNode,
                display = node.style.display;
                g.win.opera && parent.removeChild(node);
                node.style.display = "none";
                o = dragi.el.paper.getElementByPoint(x, y);
                node.style.display = display;
                g.win.opera && (next ? parent.insertBefore(node, next) : parent.appendChild(node));
                o && eve("raphael.drag.over." + dragi.el.id, dragi.el, o);
                x += scrollX;
                y += scrollY;
                eve("raphael.drag.move." + dragi.el.id, dragi.move_scope || dragi.el, x - dragi.el._drag.x, y - dragi.el._drag.y, x, y, e);
            }
        },
        dragUp = function(e) {
            R.unmousemove(dragMove).unmouseup(dragUp);
            var i = drag.length,
            dragi;
            while (i--) {
                dragi = drag[i];
                dragi.el._drag = {};
                eve("raphael.drag.end." + dragi.el.id, dragi.end_scope || dragi.start_scope || dragi.move_scope || dragi.el, e);
            }
            drag = [];
        },
        elproto = R.el = {};

        for (var i = events.length; i--; ) {
            (function(eventName) {
                R[eventName] = elproto[eventName] = function(fn, scope) {
                    if (R.is(fn, "function")) {
                        this.events = this.events || [];
                        this.events.push({
                            name: eventName,
                            f: fn,
                            unbind: addEvent(this.shape || this.node || g.doc, eventName, fn, scope || this)
                        });
                    }
                    return this;
                };
                R["un" + eventName] = elproto["un" + eventName] = function(fn) {
                    var events = this.events || [],
                    l = events.length;
                    while (l--)
                        if (events[l].name == eventName && events[l].f == fn) {
                            events[l].unbind();
                            events.splice(l, 1);
                            !events.length && delete this.events;
                            return this;
                        }
                    return this;
                };
            })(events[i]);
        }


        elproto.data = function(key, value) {
            var data = eldata[this.id] = eldata[this.id] || {};
            if (arguments.length == 1) {
                if (R.is(key, "object")) {
                    for (var i in key)
                        if (key[has](i)) {
                            this.data(i, key[i]);
                        }
                    return this;
                }
                eve("raphael.data.get." + this.id, this, data[key], key);
                return data[key];
            }
            data[key] = value;
            eve("raphael.data.set." + this.id, this, value, key);
            return this;
        };

        elproto.removeData = function(key) {
            if (key == null) {
                eldata[this.id] = {};
            } else {
                eldata[this.id] && delete eldata[this.id][key];
            }
            return this;
        };

        var downables = [],
            mouseDown = function () {
                this.untrack = addEvent(g.doc, 'mouseup', mouseUp, this);
            },
            mouseUp = function () {
                this.untrack();
                this.untrack = null;
                return this.fn && this.fn.apply(this.scope || this.el, arguments);

            };
        elproto.mouseup = function (fn, scope, track) {
            if (!track) {
                return R.mouseup.apply(this, arguments);
            }
            downables.push(track = {
                el: this,
                fn: fn,
                scope: scope
            });
            track.unbind = addEvent(this.shape || this.node || g.doc,
                'mousedown', mouseDown, track);

            return this;
        };

        elproto.unmouseup = function (fn) {
            var i = downables.length,
                undowned;
            while (i--) {
                if (downables[i].el === this && downables[i].fn === fn) {
                    undowned = downables[i];
                    undowned.unbind();
                    undowned.untrack && undowned.untrack();
                    downables.splice(i, 1);
                }
            }
            return undowned ? this : R.unmouseup.apply(this, arguments);
        };

        elproto.hover = function(f_in, f_out, scope_in, scope_out) {
            return this.mouseover(f_in, scope_in).mouseout(f_out, scope_out || scope_in);
        };

        elproto.unhover = function(f_in, f_out) {
            return this.unmouseover(f_in).unmouseout(f_out);
        };
        var draggable = [];

        elproto.drag = function(onmove, onstart, onend, move_scope, start_scope, end_scope) {
            function start(e) {
                (e.originalEvent || e).preventDefault();
                var scrollY = g.doc.documentElement.scrollTop || g.doc.body.scrollTop,
                scrollX = g.doc.documentElement.scrollLeft || g.doc.body.scrollLeft;
                this._drag.x = e.clientX + scrollX;
                this._drag.y = e.clientY + scrollY;
                this._drag.id = e.identifier;
                !drag.length && R.mousemove(dragMove).mouseup(dragUp);
                drag.push({
                    el: this,
                    move_scope: move_scope,
                    start_scope: start_scope,
                    end_scope: end_scope
                });
                onstart && eve.on("raphael.drag.start." + this.id, onstart);
                onmove && eve.on("raphael.drag.move." + this.id, onmove);
                onend && eve.on("raphael.drag.end." + this.id, onend);
                eve("raphael.drag.start." + this.id, start_scope || move_scope || this, e.clientX + scrollX, e.clientY + scrollY, e);
            }
            this._drag = {};
            draggable.push({
                el: this,
                start: start
            });
            this.mousedown(start);
            return this;
        };

        elproto.onDragOver = function(f) {
            f ? eve.on("raphael.drag.over." + this.id, f) : eve.unbind("raphael.drag.over." + this.id);
        };

        elproto.undrag = function() {
            var i = draggable.length;
            while (i--)
                if (draggable[i].el == this) {
                    this.unmousedown(draggable[i].start);
                    draggable.splice(i, 1);
                    eve.unbind("raphael.drag.*." + this.id);
                }
            !draggable.length && R.unmousemove(dragMove).unmouseup(dragUp);
        };

        elproto.follow = function(el, callback, stalk) {
            if (el.removed || el.constructor !== R.el.constructor) {
                return this;
            }
            el.followers.push({
                el: this,
                stalk: (stalk = {before: 'insertBefore', after: 'insertAfter'}[stalk]),
                cb: callback
            });

            stalk && this[stalk](el);
            return this;
        };

        elproto.unfollow = function(el) {
            if (el.removed || el.constructor !== R.el.constructor) {
                return this;
            }
            for (var i = 0, ii = el.followers.length; i < ii; i++) {
                if (el.followers[i].el === this) {
                    el.followers.splice(i, 1);
                    break;
                }
            }
            return this;
        };

        var arraySplice = Array.prototype.splice;

        paperproto.group = function() { // id
            var out,
                args = arguments,
                lastArgIndex = args.length - 1,
                group = args[lastArgIndex];

            if (group && group.constructor === R.el.constructor) {
                args[lastArgIndex] = undefined;
                arraySplice.call(args, lastArgIndex, 1);
            }
            else {
                group = undefined;
            }

            out = R._engine.group(this, args[0], group);

            this.__set__ && this.__set__.push(out);
            return out;
        };

        paperproto.circle = function() { // x, y, r
            var out,
            args = arguments,
            lastArgIndex = args.length - 1,
            group = args[lastArgIndex];

            if (group && group.constructor === R.el.constructor) {
                args[lastArgIndex] = undefined;
                arraySplice.call(args, lastArgIndex, 1);
            }
            else {
                group = undefined;
            }

            out = R._engine.circle(this, args[0] || 0, args[1] || 0,
                args[2] || 0, group);

            this.__set__ && this.__set__.push(out);
            return out;
        };

        // x, y, w, h, r
        paperproto.rect = function() {
            var out,
            args = arguments,
            lastArgIndex = args.length - 1,
            group = args[lastArgIndex];

            if (group && group.constructor === R.el.constructor) {
                args[lastArgIndex] = undefined;
                arraySplice.call(args, lastArgIndex, 1);
            }
            else {
                group = undefined;
            }

            out = R._engine.rect(this, args[0] || 0, args[1] || 0, args[2] || 0,
                args[3] || 0, args[4] || 0, group);

            this.__set__ && this.__set__.push(out);
            return out;
        };

        // x, y, rx, ry
        paperproto.ellipse = function() {
            var out,
            args = arguments,
            lastArgIndex = args.length - 1,
            group = args[lastArgIndex];

            if (group && group.constructor === R.el.constructor) {
                args[lastArgIndex] = undefined;
                arraySplice.call(args, lastArgIndex, 1);
            }
            else {
                group = undefined;
            }

            out = R._engine.ellipse(this, args[0] || 0, args[1] || 0,
                args[2] || 0, args[3] || 0, group);

            this.__set__ && this.__set__.push(out);
            return out;
        };

        // pathString
        paperproto.path = function() {
            var out,
            args = arguments,
            lastArgIndex = args.length - 1,
            group = args[lastArgIndex],
            pathString;

            if (group && group.constructor === R.el.constructor) {
                args[lastArgIndex] = undefined;
                arraySplice.call(args, lastArgIndex, 1);
            }
            else {
                group = undefined;
            }

            pathString = args[0];
            pathString && !R.is(pathString, string) &&
                !R.is(pathString[0], array) && (pathString += E);

            out = R._engine.path(R.format[apply](R, arguments), this, group);

            this.__set__ && this.__set__.push(out);
            return out;
        };

        // src, x, y, w, h
        paperproto.image = function() {
            var out,
            args = arguments,
            lastArgIndex = args.length - 1,
            group = args[lastArgIndex];

            if (group && group.constructor === R.el.constructor) {
                args[lastArgIndex] = undefined;
                arraySplice.call(args, lastArgIndex, 1);
            }
            else {
                group = undefined;
            }

            out = R._engine.image(this, args[0] || "about:blank", args[1] || 0,
                args[2] || 0, args[3] || 0, args[4] || 0, group);

            this.__set__ && this.__set__.push(out);
            return out;
        };

        // x, y, text
        paperproto.text = function() {
            var out,
            args = arguments,
            lastArgIndex = args.length - 1,
            group = args[lastArgIndex];

            if (group && group.constructor === R.el.constructor) {
                args[lastArgIndex] = undefined;
                arraySplice.call(args, lastArgIndex, 1);
            }
            else {
                group = undefined;
            }

            out = R._engine.text(this, args[0] || 0, args[1] || 0, Str(args[2] || E),
                group);
            this.__set__ && this.__set__.push(out);
            return out;
        };
        /* @diffend */

        paperproto.set = function(itemsArray) {
            !R.is(itemsArray, "array") && (itemsArray = Array.prototype.splice.call(arguments, 0, arguments.length));
            var out = new Set(itemsArray);
            this.__set__ && this.__set__.push(out);
            return out;
        };

        paperproto.setStart = function(set) {
            this.__set__ = set || this.set();
        };

        paperproto.setFinish = function(set) {
            var out = this.__set__;
            delete this.__set__;
            return out;
        };

        paperproto.setSize = function(width, height) {
            return R._engine.setSize.call(this, width, height);
        };

        paperproto.setViewBox = function(x, y, w, h, fit) {
            return R._engine.setViewBox.call(this, x, y, w, h, fit);
        };


        paperproto.top = paperproto.bottom = null;

        paperproto.raphael = R;
        var getOffset = function(elem) {
            var box = elem.getBoundingClientRect(),
            doc = elem.ownerDocument,
            body = doc.body,
            docElem = doc.documentElement,
            clientTop = docElem.clientTop || body.clientTop || 0, clientLeft = docElem.clientLeft || body.clientLeft || 0,
            top = box.top + (g.win.pageYOffset || docElem.scrollTop || body.scrollTop) - clientTop,
            left = box.left + (g.win.pageXOffset || docElem.scrollLeft || body.scrollLeft) - clientLeft;
            return {
                y: top,
                x: left
            };
        };

        paperproto.getElementByPoint = function(x, y) {
            var paper = this,
            svg = paper.canvas,
            target = g.doc.elementFromPoint(x, y);
            if (g.win.opera && target.tagName == "svg") {
                var so = getOffset(svg),
                sr = svg.createSVGRect();
                sr.x = x - so.x;
                sr.y = y - so.y;
                sr.width = sr.height = 1;
                var hits = svg.getIntersectionList(sr, null);
                if (hits.length) {
                    target = hits[hits.length - 1];
                }
            }
            if (!target) {
                return null;
            }
            while (target.parentNode && target != svg.parentNode && !target.raphael) {
                target = target.parentNode;
            }
            target == paper.canvas.parentNode && (target = svg);
            target = target && target.raphael ? paper.getById(target.raphaelid) : null;
            return target;
        };

        paperproto.getById = function(id) {
            var bot = this.bottom;
            while (bot) {
                if (bot.id == id) {
                    return bot;
                }
                bot = bot.next;
            }
            return null;
        };

        paperproto.forEach = function(callback, thisArg) {
            var bot = this.bottom;
            while (bot) {
                if (callback.call(thisArg, bot) === false) {
                    return this;
                }
                bot = bot.next;
            }
            return this;
        };

        paperproto.getElementsByPoint = function(x, y) {
            var set = this.set();
            this.forEach(function(el) {
                if (el.isPointInside(x, y)) {
                    set.push(el);
                }
            });
            return set;
        };
        function x_y() {
            return this.x + S + this.y;
        }
        function x_y_w_h() {
            return this.x + S + this.y + S + this.width + " \xd7 " + this.height;
        }

        elproto.isPointInside = function(x, y) {
            var rp = this.realPath = this.realPath || getPath[this.type](this);
            return R.isPointInsidePath(rp, x, y);
        };

        elproto.getBBox = function(isWithoutTransform) {
            if (this.removed) {
                return {};
            }
            var _ = this._;
            if (isWithoutTransform) {
                if (_.dirty || !_.bboxwt) {
                    this.realPath = getPath[this.type](this);
                    _.bboxwt = pathDimensions(this.realPath);
                    _.bboxwt.toString = x_y_w_h;
                    _.dirty = 0;
                }
                return _.bboxwt;
            }
            if (_.dirty || _.dirtyT || !_.bbox) {
                if (_.dirty || !this.realPath) {
                    _.bboxwt = 0;
                    this.realPath = getPath[this.type](this);
                }
                _.bbox = pathDimensions(mapPath(this.realPath, this.matrix));
                _.bbox.toString = x_y_w_h;
                _.dirty = _.dirtyT = 0;
            }
            return _.bbox;
        };

        elproto.clone = function() {
            if (this.removed) {
                return null;
            }
            var o = this,
                out = o.paper[o.type]().attr(o.attr());
            o.__set__ && o.__set__.push(out);
            return out;
        };

        elproto.glow = function(glow) {
            if (this.type == "text") {
                return null;
            }
            glow = glow || {};
            var s = {
                width: (glow.width || 10) + (+this.attr("stroke-width") || 1),
                fill: glow.fill || false,
                opacity: glow.opacity || .5,
                offsetx: glow.offsetx || 0,
                offsety: glow.offsety || 0,
                color: glow.color || "#000"
            },
            c = s.width / 2,
            r = this.paper,
            out = r.set(),
            path = this.realPath || getPath[this.type](this);
            path = this.matrix ? mapPath(path, this.matrix) : path;
            for (var i = 1; i < c + 1; i++) {
                out.push(r.path(path).attr({
                    stroke: s.color,
                    fill: s.fill ? s.color : "none",
                    "stroke-linejoin": "round",
                    "stroke-linecap": "round",
                    "stroke-width": +(s.width / c * i).toFixed(3),
                    opacity: +(s.opacity / c).toFixed(3)
                }));
            }
            return out.insertBefore(this).translate(s.offsetx, s.offsety);
        };
        var curveslengths = {},
        getPointAtSegmentLength = function(p1x, p1y, c1x, c1y, c2x, c2y, p2x, p2y, length) {
            if (length == null) {
                return bezlen(p1x, p1y, c1x, c1y, c2x, c2y, p2x, p2y);
            } else {
                return R.findDotsAtSegment(p1x, p1y, c1x, c1y, c2x, c2y, p2x, p2y, getTatLen(p1x, p1y, c1x, c1y, c2x, c2y, p2x, p2y, length));
            }
        },
        getLengthFactory = function(istotal, subpath) {
            return function(path, length, onlystart) {
                path = path2curve(path);
                var x, y, p, l, sp = "", subpaths = {}, point,
                len = 0;
                for (var i = 0, ii = path.length; i < ii; i++) {
                    p = path[i];
                    if (p[0] == "M") {
                        x = +p[1];
                        y = +p[2];
                    } else {
                        l = getPointAtSegmentLength(x, y, p[1], p[2], p[3], p[4], p[5], p[6]);
                        if (len + l > length) {
                            if (subpath && !subpaths.start) {
                                point = getPointAtSegmentLength(x, y, p[1], p[2], p[3], p[4], p[5], p[6], length - len);
                                sp += ["C" + point.start.x, point.start.y, point.m.x, point.m.y, point.x, point.y];
                                if (onlystart) {
                                    return sp;
                                }
                                subpaths.start = sp;
                                sp = ["M" + point.x, point.y + "C" + point.n.x, point.n.y, point.end.x, point.end.y, p[5], p[6]].join();
                                len += l;
                                x = +p[5];
                                y = +p[6];
                                continue;
                            }
                            if (!istotal && !subpath) {
                                point = getPointAtSegmentLength(x, y, p[1], p[2], p[3], p[4], p[5], p[6], length - len);
                                return {
                                    x: point.x,
                                    y: point.y,
                                    alpha: point.alpha
                                };
                            }
                        }
                        len += l;
                        x = +p[5];
                        y = +p[6];
                    }
                    sp += p.shift() + p;
                }
                subpaths.end = sp;
                point = istotal ? len : subpath ? subpaths : R.findDotsAtSegment(x, y, p[0], p[1], p[2], p[3], p[4], p[5], 1);
                point.alpha && (point = {
                    x: point.x,
                    y: point.y,
                    alpha: point.alpha
                });
                return point;
            };
        };
        var getTotalLength = getLengthFactory(1),
        getPointAtLength = getLengthFactory(),
        getSubpathsAtLength = getLengthFactory(0, 1);

        R.getTotalLength = getTotalLength;

        R.getPointAtLength = getPointAtLength;

        R.getSubpath = function(path, from, to) {
            if (this.getTotalLength(path) - to < 1e-6) {
                return getSubpathsAtLength(path, from).end;
            }
            var a = getSubpathsAtLength(path, to, 1);
            return from ? getSubpathsAtLength(a, from).end : a;
        };

        elproto.getTotalLength = function() {
            if (this.type != "path") {
                return;
            }
            if (this.node.getTotalLength) {
                return this.node.getTotalLength();
            }
            return getTotalLength(this.attrs.path);
        };

        elproto.getPointAtLength = function(length) {
            if (this.type != "path") {
                return;
            }
            return getPointAtLength(this.attrs.path, length);
        };

        elproto.getSubpath = function(from, to) {
            if (this.type != "path") {
                return;
            }
            return R.getSubpath(this.attrs.path, from, to);
        };

        var ef = R.easing_formulas = {
            linear: function(n) {
                return n;
            },
            "<": function(n) {
                return pow(n, 1.7);
            },
            ">": function(n) {
                return pow(n, .48);
            },
            "<>": function(n) {
                var q = .48 - n / 1.04,
                Q = mathSqrt(.1734 + q * q),
                x = Q - q,
                X = pow(abs(x), 1 / 3) * (x < 0 ? -1 : 1),
                y = -Q - q,
                Y = pow(abs(y), 1 / 3) * (y < 0 ? -1 : 1),
                t = X + Y + .5;
                return (1 - t) * 3 * t * t + t * t * t;
            },
            backIn: function(n) {
                var s = 1.70158;
                return n * n * ((s + 1) * n - s);
            },
            backOut: function(n) {
                n = n - 1;
                var s = 1.70158;
                return n * n * ((s + 1) * n + s) + 1;
            },
            elastic: function(n) {
                if (n == !!n) {
                    return n;
                }
                return pow(2, -10 * n) * mathSin((n - .075) * (2 * PI) / .3) + 1;
            },
            bounce: function(n) {
                var s = 7.5625,
                p = 2.75,
                l;
                if (n < (1 / p)) {
                    l = s * n * n;
                } else {
                    if (n < (2 / p)) {
                        n -= (1.5 / p);
                        l = s * n * n + .75;
                    } else {
                        if (n < (2.5 / p)) {
                            n -= (2.25 / p);
                            l = s * n * n + .9375;
                        } else {
                            n -= (2.625 / p);
                            l = s * n * n + .984375;
                        }
                    }
                }
                return l;
            }
        };
        ef.easeIn = ef["ease-in"] = ef["<"];
        ef.easeOut = ef["ease-out"] = ef[">"];
        ef.easeInOut = ef["ease-in-out"] = ef["<>"];
        ef["back-in"] = ef.backIn;
        ef["back-out"] = ef.backOut;

        var animationElements = [],
        requestAnimFrame = window.requestAnimationFrame ||
        window.webkitRequestAnimationFrame ||
        window.mozRequestAnimationFrame ||
        window.oRequestAnimationFrame ||
        window.msRequestAnimationFrame ||
        function(callback) {
            setTimeout(callback, 16);
        },
        animation = function() {
            var Now = +new Date,
            l = 0;
            for (; l < animationElements.length; l++) {
                var e = animationElements[l];
                if (e.el.removed || e.paused) {
                    continue;
                }
                var time = Now - e.start,
                ms = e.ms,
                easing = e.easing,
                from = e.from,
                diff = e.diff,
                to = e.to,
                t = e.t,
                that = e.el,
                set = {},
                now,
                init = {},
                key;
                if (e.initstatus) {
                    time = (e.initstatus * e.anim.top - e.prev) / (e.percent - e.prev) * ms;
                    e.status = e.initstatus;
                    delete e.initstatus;
                    e.stop && animationElements.splice(l--, 1);
                } else {
                    e.status = (e.prev + (e.percent - e.prev) * (time / ms)) / e.anim.top;
                }
                if (time < 0) {
                    continue;
                }
                if (time < ms) {
                    var pos = easing(time / ms);
                    for (var attr in from)
                        if (from[has](attr)) {
                            switch (availableAnimAttrs[attr]) {
                                case nu:
                                    now = +from[attr] + pos * ms * diff[attr];
                                    break;
                                case "colour":
                                    now = "rgb(" + [
                                    upto255(round(from[attr].r + pos * ms * diff[attr].r)),
                                    upto255(round(from[attr].g + pos * ms * diff[attr].g)),
                                    upto255(round(from[attr].b + pos * ms * diff[attr].b))
                                    ].join(",") + ")";
                                    break;
                                case "path":
                                    now = [];
                                    for (var i = 0, ii = from[attr].length; i < ii; i++) {
                                        now[i] = [from[attr][i][0]];
                                        for (var j = 1, jj = from[attr][i].length; j < jj; j++) {
                                            now[i][j] = (+from[attr][i][j] + pos * ms * diff[attr][i][j]).toFixed(4);
                                        }
                                        now[i] = now[i].join(S);
                                    }
                                    now = now.join(S);
                                    break;
                                case "transform":
                                    if (diff[attr].real) {
                                        now = [];
                                        for (i = 0, ii = from[attr].length; i < ii; i++) {
                                            now[i] = [from[attr][i][0]];
                                            for (j = 1, jj = from[attr][i].length; j < jj; j++) {
                                                now[i][j] = from[attr][i][j] + pos * ms * diff[attr][i][j];
                                            }
                                        }
                                    } else {
                                        var get = function(i) {
                                            return +from[attr][i] + pos * ms * diff[attr][i];
                                        };
                                        // now = [["r", get(2), 0, 0], ["t", get(3), get(4)], ["s", get(0), get(1), 0, 0]];
                                        now = [["m", get(0), get(1), get(2), get(3), get(4), get(5)]];
                                    }
                                    break;
                                case "csv":
                                    if (attr == "clip-rect") {
                                        now = [];
                                        i = 4;
                                        while (i--) {
                                            now[i] = +from[attr][i] + pos * ms * diff[attr][i];
                                        }
                                    }
                                    break;
                                default:
                                    var from2 = [][concat](from[attr]);
                                    now = [];
                                    i = that.ca[attr].length;
                                    while (i--) {
                                        now[i] = +from2[i] + pos * ms * diff[attr][i];
                                    }
                                    break;
                            }
                            set[attr] = now;
                        }
                    that.attr(set);
                    (function(id, that, anim) {
                        setTimeout(function() {
                            eve("raphael.anim.frame." + id, that, anim);
                        });
                    })(that.id, that, e.anim);
                } else {
                    (function(f, el, a) {
                        setTimeout(function() {
                            eve("raphael.anim.frame." + el.id, el, a);
                            eve("raphael.anim.finish." + el.id, el, a);
                            R.is(f, "function") && f.call(el);
                        });
                    })(e.callback, that, e.anim);
                    that.attr(to);
                    animationElements.splice(l--, 1);
                    if (e.repeat > 1 && !e.next) {
                        for (key in to)
                            if (to[has](key)) {
                                init[key] = e.totalOrigin[key];
                            }
                        e.el.attr(init);
                        runAnimation(e.anim, e.el, e.anim.percents[0], null, e.totalOrigin, e.repeat - 1);
                    }
                    if (e.next && !e.stop) {
                        runAnimation(e.anim, e.el, e.next, null, e.totalOrigin, e.repeat);
                    }
                }
            }
            R.svg && that && that.paper && that.paper.safari();
            animationElements.length && requestAnimFrame(animation);
        },
        upto255 = function(color) {
            return color > 255 ? 255 : color < 0 ? 0 : color;
        };

        elproto.animateWith = function(el, anim, params, ms, easing, callback) {
            var element = this;
            if (element.removed) {
                callback && callback.call(element);
                return element;
            }
            var a = params instanceof Animation ? params : R.animation(params, ms, easing, callback),
            x, y;
            runAnimation(a, element, a.percents[0], null, element.attr());
            for (var i = 0, ii = animationElements.length; i < ii; i++) {
                if (animationElements[i].anim == anim && animationElements[i].el == el) {
                    animationElements[ii - 1].start = animationElements[i].start;
                    break;
                }
            }
            return element;
        //
        //
        // var a = params ? R.animation(params, ms, easing, callback) : anim,
        //     status = element.status(anim);
        // return this.animate(a).status(a, status * anim.ms / a.ms);
        };
        function CubicBezierAtTime(t, p1x, p1y, p2x, p2y, duration) {
            var cx = 3 * p1x,
            bx = 3 * (p2x - p1x) - cx,
            ax = 1 - cx - bx,
            cy = 3 * p1y,
            by = 3 * (p2y - p1y) - cy,
            ay = 1 - cy - by;
            function sampleCurveX(t) {
                return ((ax * t + bx) * t + cx) * t;
            }
            function solve(x, epsilon) {
                var t = solveCurveX(x, epsilon);
                return ((ay * t + by) * t + cy) * t;
            }
            function solveCurveX(x, epsilon) {
                var t0, t1, t2, x2, d2, i;
                for (t2 = x, i = 0; i < 8; i++) {
                    x2 = sampleCurveX(t2) - x;
                    if (abs(x2) < epsilon) {
                        return t2;
                    }
                    d2 = (3 * ax * t2 + 2 * bx) * t2 + cx;
                    if (abs(d2) < 1e-6) {
                        break;
                    }
                    t2 = t2 - x2 / d2;
                }
                t0 = 0;
                t1 = 1;
                t2 = x;
                if (t2 < t0) {
                    return t0;
                }
                if (t2 > t1) {
                    return t1;
                }
                while (t0 < t1) {
                    x2 = sampleCurveX(t2);
                    if (abs(x2 - x) < epsilon) {
                        return t2;
                    }
                    if (x > x2) {
                        t0 = t2;
                    } else {
                        t1 = t2;
                    }
                    t2 = (t1 - t0) / 2 + t0;
                }
                return t2;
            }
            return solve(t, 1 / (200 * duration));
        }
        elproto.onAnimation = function(f) {
            f ? eve.on("raphael.anim.frame." + this.id, f) : eve.unbind("raphael.anim.frame." + this.id);
            return this;
        };
        function Animation(anim, ms) {
            var percents = [],
            newAnim = {};
            this.ms = ms;
            this.times = 1;
            if (anim) {
                for (var attr in anim)
                    if (anim[has](attr)) {
                        newAnim[toFloat(attr)] = anim[attr];
                        percents.push(toFloat(attr));
                    }
                percents.sort(sortByNumber);
            }
            this.anim = newAnim;
            this.top = percents[percents.length - 1];
            this.percents = percents;
        }

        Animation.prototype.delay = function(delay) {
            var a = new Animation(this.anim, this.ms);
            a.times = this.times;
            a.del = +delay || 0;
            return a;
        };

        Animation.prototype.repeat = function(times) {
            var a = new Animation(this.anim, this.ms);
            a.del = this.del;
            a.times = math.floor(mmax(times, 0)) || 1;
            return a;
        };
        function runAnimation(anim, element, percent, status, totalOrigin, times) {
            percent = toFloat(percent);
            var params,
            isInAnim,
            isInAnimSet,
            percents = [],
            next,
            prev,
            timestamp,
            ms = anim.ms,
            from = {},
            to = {},
            diff = {};
            if (status) {
                for (i = 0, ii = animationElements.length; i < ii; i++) {
                    var e = animationElements[i];
                    if (e.el.id == element.id && e.anim == anim) {
                        if (e.percent != percent) {
                            animationElements.splice(i, 1);
                            isInAnimSet = 1;
                        } else {
                            isInAnim = e;
                        }
                        element.attr(e.totalOrigin);
                        break;
                    }
                }
            } else {
                status = +to; // NaN
            }
            for (var i = 0, ii = anim.percents.length; i < ii; i++) {
                if (anim.percents[i] == percent || anim.percents[i] > status * anim.top) {
                    percent = anim.percents[i];
                    prev = anim.percents[i - 1] || 0;
                    ms = ms / anim.top * (percent - prev);
                    next = anim.percents[i + 1];
                    params = anim.anim[percent];
                    break;
                } else if (status) {
                    element.attr(anim.anim[anim.percents[i]]);
                }
            }
            if (!params) {
                return;
            }
            if (!isInAnim) {
                for (var attr in params)
                    if (params[has](attr)) {
                        if (availableAnimAttrs[has](attr) || element.ca[attr]) {
                            from[attr] = element.attr(attr);
                            (from[attr] == null) && (from[attr] = availableAttrs[attr]);
                            to[attr] = params[attr];
                            switch (availableAnimAttrs[attr]) {
                                case nu:
                                    diff[attr] = (to[attr] - from[attr]) / ms;
                                    break;
                                case "colour":
                                    from[attr] = R.getRGB(from[attr]);
                                    var toColour = R.getRGB(to[attr]);
                                    diff[attr] = {
                                        r: (toColour.r - from[attr].r) / ms,
                                        g: (toColour.g - from[attr].g) / ms,
                                        b: (toColour.b - from[attr].b) / ms
                                    };
                                    break;
                                case "path":
                                    var pathes = path2curve(from[attr], to[attr]),
                                    toPath = pathes[1];
                                    from[attr] = pathes[0];
                                    diff[attr] = [];
                                    for (i = 0, ii = from[attr].length; i < ii; i++) {
                                        diff[attr][i] = [0];
                                        for (var j = 1, jj = from[attr][i].length; j < jj; j++) {
                                            diff[attr][i][j] = (toPath[i][j] - from[attr][i][j]) / ms;
                                        }
                                    }
                                    break;
                                case "transform":
                                    var _ = element._,
                                    eq = equaliseTransform(_[attr], to[attr]);
                                    if (eq) {
                                        from[attr] = eq.from;
                                        to[attr] = eq.to;
                                        diff[attr] = [];
                                        diff[attr].real = true;
                                        for (i = 0, ii = from[attr].length; i < ii; i++) {
                                            diff[attr][i] = [from[attr][i][0]];
                                            for (j = 1, jj = from[attr][i].length; j < jj; j++) {
                                                diff[attr][i][j] = (to[attr][i][j] - from[attr][i][j]) / ms;
                                            }
                                        }
                                    } else {
                                        var m = (element.matrix || new Matrix),
                                        to2 = {
                                            _: {
                                                transform: _.transform
                                            },
                                            getBBox: function() {
                                                return element.getBBox(1);
                                            }
                                        };
                                        from[attr] = [
                                        m.a,
                                        m.b,
                                        m.c,
                                        m.d,
                                        m.e,
                                        m.f
                                        ];
                                        extractTransform(to2, to[attr]);
                                        to[attr] = to2._.transform;
                                        diff[attr] = [
                                        (to2.matrix.a - m.a) / ms,
                                        (to2.matrix.b - m.b) / ms,
                                        (to2.matrix.c - m.c) / ms,
                                        (to2.matrix.d - m.d) / ms,
                                        (to2.matrix.e - m.e) / ms,
                                        (to2.matrix.f - m.f) / ms
                                        ];
                                    // from[attr] = [_.sx, _.sy, _.deg, _.dx, _.dy];
                                    // var to2 = {_:{}, getBBox: function () { return element.getBBox(); }};
                                    // extractTransform(to2, to[attr]);
                                    // diff[attr] = [
                                    //     (to2._.sx - _.sx) / ms,
                                    //     (to2._.sy - _.sy) / ms,
                                    //     (to2._.deg - _.deg) / ms,
                                    //     (to2._.dx - _.dx) / ms,
                                    //     (to2._.dy - _.dy) / ms
                                    // ];
                                    }
                                    break;
                                case "csv":
                                    var values = Str(params[attr])[split](separator),
                                    from2 = Str(from[attr])[split](separator);
                                    if (attr == "clip-rect") {
                                        from[attr] = from2;
                                        diff[attr] = [];
                                        i = from2.length;
                                        while (i--) {
                                            diff[attr][i] = (values[i] - from[attr][i]) / ms;
                                        }
                                    }
                                    to[attr] = values;
                                    break;
                                default:
                                    values = [][concat](params[attr]);
                                    from2 = [][concat](from[attr]);
                                    diff[attr] = [];
                                    i = element.ca[attr].length;
                                    while (i--) {
                                        diff[attr][i] = ((values[i] || 0) - (from2[i] || 0)) / ms;
                                    }
                                    break;
                            }
                        }
                    }
                var easing = params.easing,
                easyeasy = R.easing_formulas[easing];
                if (!easyeasy) {
                    easyeasy = Str(easing).match(bezierrg);
                    if (easyeasy && easyeasy.length == 5) {
                        var curve = easyeasy;
                        easyeasy = function(t) {
                            return CubicBezierAtTime(t, +curve[1], +curve[2], +curve[3], +curve[4], ms);
                        };
                    } else {
                        easyeasy = pipe;
                    }
                }
                timestamp = params.start || anim.start || +new Date;
                e = {
                    anim: anim,
                    percent: percent,
                    timestamp: timestamp,
                    start: timestamp + (anim.del || 0),
                    status: 0,
                    initstatus: status || 0,
                    stop: false,
                    ms: ms,
                    easing: easyeasy,
                    from: from,
                    diff: diff,
                    to: to,
                    el: element,
                    callback: params.callback,
                    prev: prev,
                    next: next,
                    repeat: times || anim.times,
                    origin: element.attr(),
                    totalOrigin: totalOrigin
                };
                animationElements.push(e);
                if (status && !isInAnim && !isInAnimSet) {
                    e.stop = true;
                    e.start = new Date - ms * status;
                    if (animationElements.length == 1) {
                        return animation();
                    }
                }
                if (isInAnimSet) {
                    e.start = new Date - e.ms * status;
                }
                animationElements.length == 1 && requestAnimFrame(animation);
            } else {
                isInAnim.initstatus = status;
                isInAnim.start = new Date - isInAnim.ms * status;
            }
            eve("raphael.anim.start." + element.id, element, anim);
        }

        R.animation = function(params, ms, easing, callback) {
            if (params instanceof Animation) {
                return params;
            }
            if (R.is(easing, "function") || !easing) {
                callback = callback || easing || null;
                easing = null;
            }
            params = Object(params);
            ms = +ms || 0;
            var p = {},
            json,
            attr;
            for (attr in params)
                if (params[has](attr) && toFloat(attr) != attr && toFloat(attr) + "%" != attr) {
                    json = true;
                    p[attr] = params[attr];
                }
            if (!json) {
                return new Animation(params, ms);
            } else {
                easing && (p.easing = easing);
                callback && (p.callback = callback);
                return new Animation({
                    100: p
                }, ms);
            }
        };

        elproto.animate = function(params, ms, easing, callback) {
            var element = this;
            if (element.removed) {
                callback && callback.call(element);
                return element;
            }
            var anim = params instanceof Animation ? params : R.animation(params, ms, easing, callback);
            runAnimation(anim, element, anim.percents[0], null, element.attr());
            return element;
        };

        elproto.setTime = function(anim, value) {
            if (anim && value != null) {
                this.status(anim, mmin(value, anim.ms) / anim.ms);
            }
            return this;
        };

        elproto.status = function(anim, value) {
            var out = [],
            i = 0,
            len,
            e;
            if (value != null) {
                runAnimation(anim, this, -1, mmin(value, 1));
                return this;
            } else {
                len = animationElements.length;
                for (; i < len; i++) {
                    e = animationElements[i];
                    if (e.el.id == this.id && (!anim || e.anim == anim)) {
                        if (anim) {
                            return e.status;
                        }
                        out.push({
                            anim: e.anim,
                            status: e.status
                        });
                    }
                }
                if (anim) {
                    return 0;
                }
                return out;
            }
        };

        elproto.pause = function(anim) {
            for (var i = 0; i < animationElements.length; i++)
                if (animationElements[i].el.id == this.id && (!anim || animationElements[i].anim == anim)) {
                    if (eve("raphael.anim.pause." + this.id, this, animationElements[i].anim) !== false) {
                        animationElements[i].paused = true;
                    }
                }
            return this;
        };

        elproto.resume = function(anim) {
            for (var i = 0; i < animationElements.length; i++)
                if (animationElements[i].el.id == this.id && (!anim || animationElements[i].anim == anim)) {
                    var e = animationElements[i];
                    if (eve("raphael.anim.resume." + this.id, this, e.anim) !== false) {
                        delete e.paused;
                        this.status(e.anim, e.status);
                    }
                }
            return this;
        };

        elproto.stop = function(anim) {
            for (var i = 0; i < animationElements.length; i++)
                if (animationElements[i].el.id == this.id && (!anim || animationElements[i].anim == anim)) {
                    if (eve("raphael.anim.stop." + this.id, this, animationElements[i].anim) !== false) {
                        animationElements.splice(i--, 1);
                    }
                }
            return this;
        };
        function stopAnimation(paper) {
            for (var i = 0; i < animationElements.length; i++)
                if (animationElements[i].el.paper == paper) {
                    animationElements.splice(i--, 1);
                }
        }
        eve.on("raphael.remove", stopAnimation);
        eve.on("raphael.clear", stopAnimation);
        elproto.toString = function() {
            return "Rapha\xebl\u2019s object";
        };

        elproto.toFront = function() {
            if (this.removed) {
                return this;
            }

            var o = this,
                thisNode = R._engine.getNode(o),
                parent = o.parent,
                followers = o.followers,
                follower,
                i,
                ii;

            if (R._tofront(o, parent)) {
                parent.canvas.appendChild(thisNode);
            }

            for (i = 0, ii = followers.length; i < ii; i++) {
                (follower = followers[i]).stalk && follower.el[follower.stalk](o);
            }
            return o;
        };

        elproto.toBack = function() {
            if (this.removed) {
                return this;
            }

            var o = this,
                thisNode = R._engine.getNode(o),
                parent = o.parent,
                followers = o.followers,
                follower,
                i,
                ii;

            if (R._toback(o, parent)) {
                parent.canvas.insertBefore(thisNode, parent.canvas.firstChild);
            }

            for (i = 0, ii = followers.length; i < ii; i++) {
                (follower = followers[i]).stalk && follower.el[follower.stalk](o);
            }
            return o;
        };

        elproto.insertAfter = function(element) {
            if (this.removed) {
                return this;
            }

            var o = this,
                thisNode = R._engine.getNode(o),
                thatNode = R._engine.getLastNode(element),
                parentNode = element.parent.canvas,
                followers = o.followers,
                follower,
                i,
                ii;

            if (thatNode.nextSibling) {
                parentNode.insertBefore(thisNode, thatNode.nextSibling);
            }
            else {
                parentNode.appendChild(thisNode);
            }
            R._insertafter(o, element, o.parent, element.parent);

            for (i = 0, ii = followers.length; i < ii; i++) {
                (follower = followers[i]).stalk &&
                    follower.el[follower.stalk](element);
            }
            return o;
        };

        elproto.insertBefore = function(element) {
            if (this.removed) {
                return this;
            }

            var o = this,
                thisNode = R._engine.getNode(o),
                thatNode = R._engine.getNode(element),
                followers = o.followers,
                follower,
                i,
                ii;

            element.parent.canvas.insertBefore(thisNode, thatNode);
            R._insertbefore(o, element, o.parent, element.parent);
            o.parent = element.parent;

            for (i = 0, ii = followers.length; i < ii; i++) {
                (follower = followers[i]).stalk &&
                    follower.el[follower.stalk](element);
            }
            return this;
        };

        elproto.appendChild = function (element) {
            if (this.removed || this.type !== 'group') {
                return this;
            }

            var group = this,
                followers = group.followers,
                follower,
                thatNode,
                i,
                ii;

            // If appending in same group, simply perform toFront().
            if (element.parent === group) {
                element.toFront();
                return group;
            }

            thatNode = R._engine.getNode(element);

            // first remove from own group
            R._tear(element, element.parent);

            group.canvas.appendChild(thatNode);
            element.parent = group;

            !group.bottom && (group.bottom = element);
            element.prev = group.top;
            element.next = null;
            group.top && (group.top.next = element);
            group.top = element;

            for (i = 0, ii = followers.length; i < ii; i++) {
                (follower = followers[i]).stalk &&
                    follower.el[follower.stalk](element);
            }

            return group;
        };

        elproto.removeChild = function (element) {
            if (this.removed || this.type !== 'group' || element.parent !== this) {
                return this;
            }

            var o = this,
                thatNode = R._engine.getNode(element),
                paper = o.paper;

            R._tear(element, o);
            paper.canvas.appendChild(thatNode);

            o.parent = paper;
            !paper.bottom && (paper.bottom = o);

            o.prev = paper.top;
            paper.top && (paper.top.next = o);
            paper.top = o;
            o.next = null;

            return o;
        };

        // Set
        var Set = function(items) {
            this.items = [];
            this.length = 0;
            this.type = "set";
            if (items) {
                for (var i = 0, ii = items.length; i < ii; i++) {
                    if (items[i] && (items[i].constructor == elproto.constructor || items[i].constructor == Set)) {
                        this[this.items.length] = this.items[this.items.length] = items[i];
                        this.length++;
                    }
                }
            }
        },
        setproto = Set.prototype;

        setproto.push = function() {
            var item,
            len;
            for (var i = 0, ii = arguments.length; i < ii; i++) {
                item = arguments[i];
                if (item && (item.constructor == elproto.constructor || item.constructor == Set)) {
                    len = this.items.length;
                    this[len] = this.items[len] = item;
                    this.length++;
                }
            }
            return this;
        };

        setproto.pop = function() {
            this.length && delete this[this.length--];
            return this.items.pop();
        };

        setproto.forEach = function(callback, thisArg) {
            for (var i = 0, ii = this.items.length; i < ii; i++) {
                if (callback.call(thisArg, this.items[i], i) === false) {
                    return this;
                }
            }
            return this;
        };
        for (var method in elproto)
            if (elproto[has](method)) {
                setproto[method] = (function(methodname) {
                    return function() {
                        var arg = arguments;
                        return this.forEach(function(el) {
                            el[methodname][apply](el, arg);
                        });
                    };
                })(method);
            }
        setproto.attr = function(name, value) {
            if (name && R.is(name, array) && R.is(name[0], "object")) {
                for (var j = 0, jj = name.length; j < jj; j++) {
                    this.items[j].attr(name[j]);
                }
            } else {
                for (var i = 0, ii = this.items.length; i < ii; i++) {
                    this.items[i].attr(name, value);
                }
            }
            return this;
        };

        setproto.clear = function() {
            while (this.length) {
                this.pop();
            }
        };

        setproto.splice = function(index, count, insertion) {
            index = index < 0 ? mmax(this.length + index, 0) : index;
            count = mmax(0, mmin(this.length - index, isNaN(count) && this.length || count));
            var tail = [],
            todel = [],
            args = [],
            i;
            for (i = 2; i < arguments.length; i++) {
                args.push(arguments[i]);
            }
            for (i = 0; i < count; i++) {
                todel.push(this[index + i]);
            }
            for (; i < this.length - index; i++) {
                tail.push(this[index + i]);
            }
            var arglen = args.length;
            for (i = 0; i < arglen + tail.length; i++) {
                this.items[index + i] = this[index + i] = i < arglen ? args[i] : tail[i - arglen];
            }
            i = this.items.length = this.length -= count - arglen;
            while (this[i]) {
                delete this[i++];
            }
            return new Set(todel);
        };

        setproto.exclude = function(el) {
            for (var i = 0, ii = this.length; i < ii; i++)
                if (this[i] == el) {
                    this.splice(i, 1);
                    return true;
                }
        };
        setproto.animate = function(params, ms, easing, callback) {
            (R.is(easing, "function") || !easing) && (callback = easing || null);
            var len = this.items.length,
            i = len,
            item,
            set = this,
            collector;
            if (!len) {
                return this;
            }
            callback && (collector = function() {
                !--len && callback.call(set);
            });
            easing = R.is(easing, string) ? easing : collector;
            var anim = R.animation(params, ms, easing, collector);
            item = this.items[--i].animate(anim);
            while (i--) {
                this.items[i] && !this.items[i].removed && this.items[i].animateWith(item, anim, anim);
            }
            return this;
        };
        setproto.insertAfter = function(el) {
            var i = this.items.length;
            while (i--) {
                this.items[i].insertAfter(el);
            }
            return this;
        };
        setproto.getBBox = function() {
            var x = [],
            y = [],
            x2 = [],
            y2 = [];
            for (var i = this.items.length; i--; )
                if (!this.items[i].removed) {
                    var box = this.items[i].getBBox();
                    x.push(box.x);
                    y.push(box.y);
                    x2.push(box.x + box.width);
                    y2.push(box.y + box.height);
                }
            x = mmin[apply](0, x);
            y = mmin[apply](0, y);
            x2 = mmax[apply](0, x2);
            y2 = mmax[apply](0, y2);
            return {
                x: x,
                y: y,
                x2: x2,
                y2: y2,
                width: x2 - x,
                height: y2 - y
            };
        };
        setproto.clone = function(s) {
            s = new Set;
            for (var i = 0, ii = this.items.length; i < ii; i++) {
                s.push(this.items[i].clone());
            }
            return s;
        };
        setproto.toString = function() {
            return "Rapha\xebl\u2018s set";
        };

        R.registerFont = function(font) {
            if (!font.face) {
                return font;
            }
            this.fonts = this.fonts || {};
            var fontcopy = {
                w: font.w,
                face: {},
                glyphs: {}
            },
            family = font.face["font-family"];
            for (var prop in font.face)
                if (font.face[has](prop)) {
                    fontcopy.face[prop] = font.face[prop];
                }
            if (this.fonts[family]) {
                this.fonts[family].push(fontcopy);
            } else {
                this.fonts[family] = [fontcopy];
            }
            if (!font.svg) {
                fontcopy.face["units-per-em"] = toInt(font.face["units-per-em"], 10);
                for (var glyph in font.glyphs)
                    if (font.glyphs[has](glyph)) {
                        var path = font.glyphs[glyph];
                        fontcopy.glyphs[glyph] = {
                            w: path.w,
                            k: {},
                            d: path.d && "M" + path.d.replace(/[mlcxtrv]/g, function(command) {
                                return {
                                    l: "L",
                                    c: "C",
                                    x: "z",
                                    t: "m",
                                    r: "l",
                                    v: "c"
                                }
                                [command] || "M";
                            }) + "z"
                        };
                        if (path.k) {
                            for (var k in path.k)
                                if (path[has](k)) {
                                    fontcopy.glyphs[glyph].k[k] = path.k[k];
                                }
                        }
                    }
            }
            return font;
        };

        paperproto.getFont = function(family, weight, style, stretch) {
            stretch = stretch || "normal";
            style = style || "normal";
            weight = +weight || {
                normal: 400,
                bold: 700,
                lighter: 300,
                bolder: 800
            }
            [weight] || 400;
            if (!R.fonts) {
                return;
            }
            var font = R.fonts[family];
            if (!font) {
                var name = new RegExp("(^|\\s)" + family.replace(/[^\w\d\s+!~.:_-]/g, E) + "(\\s|$)", "i");
                for (var fontName in R.fonts)
                    if (R.fonts[has](fontName)) {
                        if (name.test(fontName)) {
                            font = R.fonts[fontName];
                            break;
                        }
                    }
            }
            var thefont;
            if (font) {
                for (var i = 0, ii = font.length; i < ii; i++) {
                    thefont = font[i];
                    if (thefont.face["font-weight"] == weight && (thefont.face["font-style"] == style || !thefont.face["font-style"]) && thefont.face["font-stretch"] == stretch) {
                        break;
                    }
                }
            }
            return thefont;
        };

        paperproto.print = function(x, y, string, font, size, origin, letter_spacing) {
            origin = origin || "middle"; // baseline|middle
            letter_spacing = mmax(mmin(letter_spacing || 0, 1), -1);
            var letters = Str(string)[split](E),
            shift = 0,
            notfirst = 0,
            path = E,
            scale;
            R.is(font, string) && (font = this.getFont(font));
            if (font) {
                scale = (size || 16) / font.face["units-per-em"];
                var bb = font.face.bbox[split](separator),
                top = +bb[0],
                lineHeight = bb[3] - bb[1],
                shifty = 0,
                height = + bb[1] + (origin == "baseline" ? lineHeight + ( + font.face.descent) : lineHeight / 2);
                for (var i = 0, ii = letters.length; i < ii; i++) {
                    if (letters[i] == "\n") {
                        shift = 0;
                        curr = 0;
                        notfirst = 0;
                        shifty += lineHeight;
                    } else {
                        var prev = notfirst && font.glyphs[letters[i - 1]] || {},
                        curr = font.glyphs[letters[i]];
                        shift += notfirst ? (prev.w || font.w) + (prev.k && prev.k[letters[i]] || 0) + (font.w * letter_spacing) : 0;
                        notfirst = 1;
                    }
                    if (curr && curr.d) {
                        path += R.transformPath(curr.d, ["t", shift * scale, shifty * scale, "s", scale, scale, top, height, "t", (x - top) / scale, (y - height) / scale]);
                    }
                }
            }
            return this.path(path).attr({
                fill: "#000",
                stroke: "none"
            });
        };


        paperproto.add = function(json) {
            if (R.is(json, "array")) {
                var res = this.set(),
                i = 0,
                ii = json.length,
                j;
                for (; i < ii; i++) {
                    j = json[i] || {};
                    elements[has](j.type) && res.push(this[j.type]().attr(j));
                }
            }
            return res;
        };


        R.format = function(token, params) {
            var args = R.is(params, array) ? [0][concat](params) : arguments;
            token && R.is(token, string) && args.length - 1 && (token = token.replace(formatrg, function(str, i) {
                return args[++i] == null ? E : args[i];
            }));
            return token || E;
        };

        R.fullfill = (function() {
            var tokenRegex = /\{([^\}]+)\}/g,
            objNotationRegex = /(?:(?:^|\.)(.+?)(?=\[|\.|$|\()|\[('|")(.+?)\2\])(\(\))?/g, // matches .xxxxx or ["xxxxx"] to run over object properties
            replacer = function(all, key, obj) {
                var res = obj;
                key.replace(objNotationRegex, function(all, name, quote, quotedName, isFunc) {
                    name = name || quotedName;
                    if (res) {
                        if (name in res) {
                            res = res[name];
                        }
                        typeof res == "function" && isFunc && (res = res());
                    }
                });
                res = (res == null || res == obj ? all : res) + "";
                return res;
            };
            return function(str, obj) {
                return String(str).replace(tokenRegex, function(all, key) {
                    return replacer(all, key, obj);
                });
            };
        })();

        R.ninja = function() {
            oldRaphael.was ? (g.win.Raphael = oldRaphael.is) : delete Raphael;
            return R;
        };

        R.st = setproto;
        // Firefox <3.6 fix: http://webreflection.blogspot.com/2009/11/195-chars-to-help-lazy-loading.html
        (function(doc, loaded, f) {
            if (doc.readyState == null && doc.addEventListener) {
                doc.addEventListener(loaded, f = function() {
                    doc.removeEventListener(loaded, f, false);
                    doc.readyState = "complete";
                }, false);
                doc.readyState = "loading";
            }
            function isLoaded() {
                (/in/).test(doc.readyState) ? setTimeout(isLoaded, 9) : R.eve("raphael.DOMload");
            }
            isLoaded();
        })(document, "DOMContentLoaded");

        oldRaphael.was ? (g.win.Raphael = R) : (Raphael = R);

        eve.on("raphael.DOMload", function() {
            loaded = true;
        });
    })();


    /**
     * @section
     * Raphael 2.1.0 - SVG Rendering Library
     * -------------------------------------
     */
    window.Raphael.svg && function(R) {
        var has = "hasOwnProperty",
        Str = String,
        toFloat = parseFloat,
        toInt = parseInt,
        math = Math,
        mmax = math.max,
        abs = math.abs,
        pow = math.pow,
        sqrt = math.sqrt,
        separator = /[, ]+/,
        isWebKit = /AppleWebKit/.test(R._g.win.navigator.userAgent),
        eve = R.eve,
        E = "",
        S = " ";
        var xlink = "http://www.w3.org/1999/xlink",
        markers = {
            block: "M5,0 0,2.5 5,5z",
            classic: "M5,0 0,2.5 5,5 3.5,3 3.5,2z",
            diamond: "M2.5,0 5,2.5 2.5,5 0,2.5z",
            open: "M6,1 1,3.5 6,6",
            oval: "M2.5,0A2.5,2.5,0,0,1,2.5,5 2.5,2.5,0,0,1,2.5,0z"
        },
        shapeRenderingAttrs = R._shapeRenderingAttrs = {
            speed: "optimizeSpeed",
            crisp: "crispEdges",
            precision: "geometricPrecision"
        },
        markerCounter = {};
        R._url = /msie/i.test(navigator.userAgent) && !window.opera ? E : window.location.href.replace(/#.*?$/, E);
        R.toString = function() {
            return  "Your browser supports SVG.\nYou are running Rapha\xebl " + this.version;
        };
        var $ = R._createNode = function(el, attr) {
            if (attr) {
                if (typeof el == "string") {
                    el = $(el);
                }
                for (var key in attr)
                    if (attr[has](key)) {
                        if (key.substring(0, 6) == "xlink:") {
                            el.setAttributeNS(xlink, key.substring(6), Str(attr[key]));
                        } else {
                            el.setAttribute(key, Str(attr[key]));
                        }
                    }
            } else {
                el = R._g.doc.createElementNS("http://www.w3.org/2000/svg", el);
            }
            return el;
        },
        gradientUnitNames = {
            userSpaceOnUse: 'userSpaceOnUse',
            objectBoundingBox: 'objectBoundingBox'
        },
        gradientSpreadNames = {
            pad: 'pad',
            redlect: 'reflect',
            repeat: 'repeat'
        },
        addGradientFill = function(element, gradient) {
            var type = "linear",
            id = element.id + gradient,
            fx = .5, fy = .5, r, cx, cy, units, spread,
            o = element.node,
            SVG = element.paper,
            s = o.style,
            el = R._g.doc.getElementById(id);
            if (!el && SVG.defs) {
                gradient = Str(gradient).replace(R._radial_gradient, function(all, opts) {
                    type = "radial";
                    opts = opts && opts.split(',') || [];
                    units = opts[5];
                    spread = opts[6];

                    var _fx = opts[0],
                        _fy = opts[1],
                        _r = opts[2],
                        _cx = opts[3],
                        _cy = opts[4],
                        shifted = (_fx && _fy),
                        dir,
                        sqx;

                    if (_r) {
                        r = /\%/.test(_r) ? _r : toFloat(_r);
                    }

                    if (units === gradientUnitNames.userSpaceOnUse) {
                        if (shifted) {
                            fx = _fx;
                            fy = _fy;
                        }
                        if (_cx && _cy) {
                            cx = _cx;
                            cy = _cy;
                            if (!shifted) {
                                fx = cx;
                                fy = cy;
                            }
                        }
                        return E;
                    }

                    if (shifted) {
                        fx = toFloat(_fx);
                        fy = toFloat(_fy);
                        dir = ((fy > .5) * 2 - 1);
                        (sqx = pow(fx - .5, 2)) + pow(fy - .5, 2) > .25 &&
                        (sqx < .25) && (fy = sqrt(.25 - sqx) * dir + .5) &&
                        fy !== .5 &&
                        (fy = fy.toFixed(5) - 1e-5 * dir);
                    }
                    if (_cx && _cy) {
                        cx = toFloat(_cx);
                        cy = toFloat(_cy);
                        dir = ((cy > .5) * 2 - 1);

                        (sqx = pow(cx - .5, 2)) + pow(cy - .5, 2) > .25 &&
                        (sqx < .25) && (cy = sqrt(.25 - sqx) * dir + .5) &&
                        cy !== .5 &&
                        (cy = cy.toFixed(5) - 1e-5 * dir);

                        if (!shifted) {
                            fx = cx;
                            fy = cy;
                        }
                    }

                    return E;
                });
                gradient = gradient.split(/\s*\-\s*/);
                if (type == "linear") {
                    var angle = gradient.shift(),
                        specs = angle.match(/\((.*)\)/),
                        vector,
                        max;

                    specs = specs && specs[1] && specs[1].split(/\s*\,\s*/);
                    angle = -toFloat(angle);
                    if (isNaN(angle)) {
                        return null;
                    }
                    if (specs && specs.length) {
                        if (specs[0] in gradientUnitNames) {
                            units = specs.shift();
                            (specs[0] in gradientSpreadNames) &&
                                (spread = specs.shift());
                        }
                        else {
                            specs[4] && (units = specs[4]);
                            specs[5] && (spread = specs[5]);
                        }

                        

                        vector = [
                            specs[0] || "0%", specs[1] || "0%",
                            specs[2] || "100%", specs[3] || "0%"
                        ];
                    }
                    else {
                        vector = [0, 0, math.cos(R.rad(angle)), math.sin(R.rad(angle))];
                        max = 1 / (mmax(abs(vector[2]), abs(vector[3])) || 1);
                        vector[2] *= max;
                        vector[3] *= max;
                        if (vector[2] < 0) {
                            vector[0] = -vector[2];
                            vector[2] = 0;
                        }
                        if (vector[3] < 0) {
                            vector[1] = -vector[3];
                            vector[3] = 0;
                        }
                    }
                }
                var dots = R._parseDots(gradient);
                if (!dots) {
                    return null;
                }
                id = id.replace(/[\(\)\s,\xb0#]/g, "_");

                if (element.gradient && id !== element.gradient.id) {
                    SVG.defs.removeChild(element.gradient);
                    delete element.gradient;
                }

                if (!element.gradient) {
                    el = $(type + "Gradient", {
                        id: id
                    });
                    element.gradient = el;
                    (units in gradientUnitNames) &&
                            el.setAttribute('gradientUnits', Str(units));
                    (spread in gradientSpreadNames) &&
                            el.setAttribute('spreadMethod', Str(spread));
                    if (type === "radial") {
                        (r !== undefined) && el.setAttribute('r', Str(r));

                        if (cx !== undefined && cy !== undefined) {
                            el.setAttribute('cx', Str(cx));
                            el.setAttribute('cy', Str(cy));
                        }
                        el.setAttribute('fx', Str(fx));
                        el.setAttribute('fy', Str(fy));
                    }
                    else {
                        $(el, {
                            x1: vector[0],
                            y1: vector[1],
                            x2: vector[2],
                            y2: vector[3],
                            gradientTransform: element.matrix.invert()
                        });
                    }
                    SVG.defs.appendChild(el);
                    for (var i = 0, ii = dots.length; i < ii; i++) {
                        el.appendChild($("stop", {
                            offset: dots[i].offset ? dots[i].offset : i ? "100%" : "0%",
                            "stop-color": dots[i].color || "#fff",
                            //add stop opacity information
                            "stop-opacity": dots[i].opacity === undefined ? 1 : dots[i].opacity
                        }));
                    }
                }
            }
            $(o, {
                fill: "url('" + R._url + "#" + id + "')",
                opacity: 1,
                "fill-opacity": 1
            });
            s.fill = E;
            s.opacity = 1;
            s.fillOpacity = 1;
            return 1;
        },
        updatePosition = function(o) {
            var bbox = o.getBBox(1);
            $(o.pattern, {
                patternTransform: o.matrix.invert() + " translate(" + bbox.x + "," + bbox.y + ")"
            });
        },
        addArrow = function(o, value, isEnd) {
            if (o.type == "path") {
                var values = Str(value).toLowerCase().split("-"),
                p = o.paper,
                se = isEnd ? "end" : "start",
                node = o.node,
                attrs = o.attrs,
                stroke = attrs["stroke-width"],
                i = values.length,
                type = "classic",
                from,
                to,
                dx,
                refX,
                attr,
                w = 3,
                h = 3,
                t = 5;
                while (i--) {
                    switch (values[i]) {
                        case "block":
                        case "classic":
                        case "oval":
                        case "diamond":
                        case "open":
                        case "none":
                            type = values[i];
                            break;
                        case "wide":
                            h = 5;
                            break;
                        case "narrow":
                            h = 2;
                            break;
                        case "long":
                            w = 5;
                            break;
                        case "short":
                            w = 2;
                            break;
                    }
                }
                if (type == "open") {
                    w += 2;
                    h += 2;
                    t += 2;
                    dx = 1;
                    refX = isEnd ? 4 : 1;
                    attr = {
                        fill: "none",
                        stroke: attrs.stroke
                    };
                } else {
                    refX = dx = w / 2;
                    attr = {
                        fill: attrs.stroke,
                        stroke: "none"
                    };
                }
                if (o._.arrows) {
                    if (isEnd) {
                        o._.arrows.endPath && markerCounter[o._.arrows.endPath]--;
                        o._.arrows.endMarker && markerCounter[o._.arrows.endMarker]--;
                    } else {
                        o._.arrows.startPath && markerCounter[o._.arrows.startPath]--;
                        o._.arrows.startMarker && markerCounter[o._.arrows.startMarker]--;
                    }
                } else {
                    o._.arrows = {};
                }
                if (type != "none") {
                    var pathId = "raphael-marker-" + type,
                    markerId = "raphael-marker-" + se + type + w + h;
                    if (!R._g.doc.getElementById(pathId)) {
                        p.defs.appendChild($($("path"), {
                            "stroke-linecap": "round",
                            d: markers[type],
                            id: pathId
                        }));
                        markerCounter[pathId] = 1;
                    } else {
                        markerCounter[pathId]++;
                    }
                    var marker = R._g.doc.getElementById(markerId),
                    use;
                    if (!marker) {
                        marker = $($("marker"), {
                            id: markerId,
                            markerHeight: h,
                            markerWidth: w,
                            orient: "auto",
                            refX: refX,
                            refY: h / 2
                        });
                        use = $($("use"), {
                            "xlink:href": "#" + pathId,
                            transform: (isEnd ? "rotate(180 " + w / 2 + " " + h / 2 + ") " : E) + "scale(" + w / t + "," + h / t + ")",
                            "stroke-width": (1 / ((w / t + h / t) / 2)).toFixed(4)
                        });
                        marker.appendChild(use);
                        p.defs.appendChild(marker);
                        markerCounter[markerId] = 1;
                    } else {
                        markerCounter[markerId]++;
                        use = marker.getElementsByTagName("use")[0];
                    }
                    $(use, attr);
                    var delta = dx * (type != "diamond" && type != "oval");
                    if (isEnd) {
                        from = o._.arrows.startdx * stroke || 0;
                        to = R.getTotalLength(attrs.path) - delta * stroke;
                    } else {
                        from = delta * stroke;
                        to = R.getTotalLength(attrs.path) - (o._.arrows.enddx * stroke || 0);
                    }
                    attr = {};
                    attr["marker-" + se] = "url('" + R._url + "#" + markerId + "')";
                    if (to || from) {
                        attr.d = Raphael.getSubpath(attrs.path, from, to);
                    }
                    $(node, attr);
                    o._.arrows[se + "Path"] = pathId;
                    o._.arrows[se + "Marker"] = markerId;
                    o._.arrows[se + "dx"] = delta;
                    o._.arrows[se + "Type"] = type;
                    o._.arrows[se + "String"] = value;
                } else {
                    if (isEnd) {
                        from = o._.arrows.startdx * stroke || 0;
                        to = R.getTotalLength(attrs.path) - from;
                    } else {
                        from = 0;
                        to = R.getTotalLength(attrs.path) - (o._.arrows.enddx * stroke || 0);
                    }
                    o._.arrows[se + "Path"] && $(node, {
                        d: Raphael.getSubpath(attrs.path, from, to)
                    });
                    delete o._.arrows[se + "Path"];
                    delete o._.arrows[se + "Marker"];
                    delete o._.arrows[se + "dx"];
                    delete o._.arrows[se + "Type"];
                    delete o._.arrows[se + "String"];
                }
                for (attr in markerCounter)
                    if (markerCounter[has](attr) && !markerCounter[attr]) {
                        var item = R._g.doc.getElementById(attr);
                        item && item.parentNode.removeChild(item);
                    }
            }
        },
        dasharray = {
            "": [0],
            "none": [0],
            "-": [3, 1],
            ".": [1, 1],
            "-.": [3, 1, 1, 1],
            "-..": [3, 1, 1, 1, 1, 1],
            ". ": [1, 3],
            "- ": [4, 3],
            "--": [8, 3],
            "- .": [4, 3, 1, 3],
            "--.": [8, 3, 1, 3],
            "--..": [8, 3, 1, 3, 1, 3]
        },
        addDashes = function(o, value, params) {
            var predefValue = dasharray[Str(value).toLowerCase()];
            value = predefValue || ((value !== undefined) && [].concat(value));
            if (value) {
                var width = o.attrs["stroke-width"] || "1",
                        butt = {
                        round: width,
                        square: width,
                        butt: 0
                    }[o.attrs["stroke-linecap"] || params["stroke-linecap"]] || 0,
                        i,
                        l = i = value.length;
                if (predefValue) {
                    while (i--) {
                        value[i] = value[i] * width + ((i % 2) ? 1 : -1) * butt;
                    }
                }
                else {
                    for (i = 0; i < l; i += 2) {
                        value[i] -= butt;
                        value[i + 1] && (value[i + 1] += butt);
                        if (value[i] <= 0) {
                            value[i] = 0.1;
                        }
                    }
                }
                if (R.is(value, 'array')) {
                    $(o.node, {
                        "stroke-dasharray": value.join(",")
                    });
                }
            }
        },
        setFillAndStroke = R._setFillAndStroke = function(o, params) {
            if (!o.paper.canvas) {
                return;
            }
            var node = o.node,
                attrs = o.attrs,
                paper = o.paper,
                vis = node.style.visibility;

            node.style.visibility = "hidden";
            for (var att in params) {
                if (params[has](att)) {
                    if (!R._availableAttrs[has](att)) {
                        continue;
                    }
                    var value = params[att];
                    attrs[att] = value;
                    switch (att) {
                        case "blur":
                            o.blur(value);
                            break;
                        case "href":
                        case "title":
                        case "target":
                            var pn = node.parentNode;
                            if (pn.tagName.toLowerCase() != "a") {
                                if (value == E) { break; }
                                var hl = $("a");
                                pn.insertBefore(hl, node);
                                hl.appendChild(node);
                                pn = hl;
                            }
                            if (att == "target") {
                                pn.setAttributeNS(xlink, "show", value == "blank" ? "new" : value);
                            } else {
                                pn.setAttributeNS(xlink, att, value);
                            }
                            node.titleNode = pn;
                            break;
                        case "cursor":
                            node.style.cursor = value;
                            break;
                        case "transform":
                            o.transform(value);
                            break;
                        case "rotation":
                            if (R.is(value, "array")) {
                                o.rotate.apply(o, value);
                            }
                            else {
                                o.rotate(value);
                            }
                            break;
                        case "arrow-start":
                            addArrow(o, value);
                            break;
                        case "arrow-end":
                            addArrow(o, value, 1);
                            break;
                        case "clip-path":
                            var pathClip = true;
                        case "clip-rect":
                            var rect = !pathClip && Str(value).split(separator);
                            o._.clipispath = !!pathClip;
                            if (pathClip || rect.length == 4) {
                                o.clip && o.clip.parentNode.parentNode.removeChild(o.clip.parentNode);
                                var el = $("clipPath"),
                                rc = $(pathClip ? "path" : "rect");
                                el.id = R.createUUID();
                                $(rc, pathClip ? {
                                    d: value ? attrs['clip-path'] = R._pathToAbsolute(value) : R._availableAttrs.path,
                                    fill: 'none'
                                } : {
                                    x: rect[0],
                                    y: rect[1],
                                    width: rect[2],
                                    height: rect[3],
                                    transform: o.matrix.invert()
                                });
                                el.appendChild(rc);
                                paper.defs.appendChild(el);
                                $(node, {
                                    "clip-path": "url('" + R._url +"#" + el.id + "')"
                                });
                                o.clip = rc;
                            }
                            if (!value) {
                                var path = node.getAttribute("clip-path");
                                if (path) {
                                    var clip = R._g.doc.getElementById(path.replace(/(^url\(#|\)$)/g, E));
                                    clip && clip.parentNode.removeChild(clip);
                                    $(node, {
                                        "clip-path": E
                                    });
                                    delete o.clip;
                                }
                            }
                            break;
                        case "path":
                            if (o.type == "path") {
                                $(node, {
                                    d: value ? attrs.path = R._pathToAbsolute(value) : R._availableAttrs.path
                                });
                                o._.dirty = 1;
                                if (o._.arrows) {
                                    "startString" in o._.arrows && addArrow(o, o._.arrows.startString);
                                    "endString" in o._.arrows && addArrow(o, o._.arrows.endString, 1);
                                }
                            }
                            break;
                        case "width":
                            node.setAttribute(att, value);
                            o._.dirty = 1;
                            if (attrs.fx) {
                                att = "x";
                                value = attrs.x;
                            } else {
                                break;
                            }
                        case "x":
                            if (attrs.fx) {
                                value = -attrs.x - (attrs.width || 0);
                            }
                        case "rx":
                            if (att == "rx" && o.type == "rect") {
                                break;
                            }
                        case "cx":
                            node.setAttribute(att, value);
                            o.pattern && updatePosition(o);
                            o._.dirty = 1;
                            break;
                        case "height":
                            node.setAttribute(att, value);
                            o._.dirty = 1;
                            if (attrs.fy) {
                                att = "y";
                                value = attrs.y;
                            } else {
                                break;
                            }
                        case "y":
                            if (attrs.fy) {
                                value = -attrs.y - (attrs.height || 0);
                            }
                        case "ry":
                            if (att == "ry" && o.type == "rect") {
                                break;
                            }
                        case "cy":
                            node.setAttribute(att, value);
                            o.pattern && updatePosition(o);
                            o._.dirty = 1;
                            break;
                        case "r":
                            if (o.type == "rect") {
                                $(node, {
                                    rx: value,
                                    ry: value
                                });
                            } else {
                                node.setAttribute(att, value);
                            }
                            o._.dirty = 1;
                            break;
                        case "src":
                            if (o.type == "image") {
                                node.setAttributeNS(xlink, "href", value);
                            }
                            break;
                        case "stroke-width":
                            if (o._.sx != 1 || o._.sy != 1) {
                                value /= mmax(abs(o._.sx), abs(o._.sy)) || 1;
                            }
                            if (paper._vbSize) {
                                value *= paper._vbSize;
                            }
                            if (isWebKit && value === 0) {
                                value = 0.000001;
                            }
                            node.setAttribute(att, value);
                            if (attrs["stroke-dasharray"]) {
                                addDashes(o, attrs["stroke-dasharray"], params);
                            }
                            if (o._.arrows) {
                                "startString" in o._.arrows && addArrow(o, o._.arrows.startString);
                                "endString" in o._.arrows && addArrow(o, o._.arrows.endString, 1);
                            }
                            break;
                        case "stroke-dasharray":
                            addDashes(o, value, params);
                            break;
                        case "fill":
                            var isURL = Str(value).match(R._ISURL);
                            if (isURL) {
                                el = $("pattern");
                                var ig = $("image");
                                el.id = R.createUUID();
                                $(el, {
                                    x: 0,
                                    y: 0,
                                    patternUnits: "userSpaceOnUse",
                                    height: 1,
                                    width: 1
                                });
                                $(ig, {
                                    x: 0,
                                    y: 0,
                                    "xlink:href": isURL[1]
                                });
                                el.appendChild(ig);

                                (function(el) {
                                    R._preload(isURL[1], function() {
                                        var w = this.offsetWidth,
                                        h = this.offsetHeight;
                                        $(el, {
                                            width: w,
                                            height: h
                                        });
                                        $(ig, {
                                            width: w,
                                            height: h
                                        });
                                        paper.safari();
                                    });
                                })(el);
                                paper.defs.appendChild(el);
                                $(node, {
                                    fill: "url('" + R._url + "#" + el.id + "')"
                                });
                                o.pattern = el;
                                o.pattern && updatePosition(o);
                                break;
                            }
                            var clr = R.getRGB(value);
                            if (!clr.error) {
                                delete params.gradient;
                                delete attrs.gradient;
                                !R.is(attrs.opacity, "undefined") &&
                                    R.is(params.opacity, "undefined") &&
                                    $(node, {
                                        opacity: attrs.opacity
                                    });
                                !R.is(attrs["fill-opacity"], "undefined") &&
                                    R.is(params["fill-opacity"], "undefined") &&
                                    $(node, {
                                        "fill-opacity": attrs["fill-opacity"]
                                    });
                            } else if ((o.type == "circle" || o.type == "ellipse" || Str(value).charAt() != "r") && addGradientFill(o, value)) {
                                if ("opacity" in attrs || "fill-opacity" in attrs) {
                                    var gradient = R._g.doc.getElementById(node.getAttribute("fill").replace(/^url\(#|\)$/g, E));
                                    if (gradient) {
                                        var stops = gradient.getElementsByTagName("stop");
                                        $(stops[stops.length - 1], {
                                            "stop-opacity": ("opacity" in attrs ? attrs.opacity : 1) * ("fill-opacity" in attrs ? attrs["fill-opacity"] : 1)
                                        });
                                    }
                                }
                                attrs.gradient = value;
                                attrs.fill = "none";
                                break;
                            }
                            if (clr[has]("opacity")) {
                                $(node, {
                                    "fill-opacity": clr.opacity > 1 ? clr.opacity / 100 : clr.opacity
                                });
                                o._.opacitydirty = true;
                            }
                            else if (o._.opacitydirty && R.is(attrs['fill-opacity'], "undefined") &&
                                    R.is(params["fill-opacity"], "undefined")) {
                                node.removeAttribute('fill-opacity');
                                delete o._.opacitydirty;
                            }
                        case "stroke":
                            clr = R.getRGB(value);
                            node.setAttribute(att, clr.hex);
                            att == "stroke" && clr[has]("opacity") && $(node, {
                                "stroke-opacity": clr.opacity > 1 ? clr.opacity / 100 : clr.opacity
                            });
                            if (att == "stroke" && o._.arrows) {
                                "startString" in o._.arrows && addArrow(o, o._.arrows.startString);
                                "endString" in o._.arrows && addArrow(o, o._.arrows.endString, 1);
                            }
                            break;
                        case "gradient":
                            (o.type == "circle" || o.type == "ellipse" || Str(value).charAt() != "r") && addGradientFill(o, value);
                            break;
                        case "shape-rendering":
                            attrs[att] = value = shapeRenderingAttrs[value] || value || 'default';
                            node.setAttribute(att, value);
                            node.style.shapeRendering = value;
                            break;
                        case 'line-height': // do not apply
                        case 'vertical-align': // do not apply
                            break;
                        case "visibility":
                            value === 'hidden' ? o.hide() : o.show();
                            break;
                        case "opacity":
                            if (attrs.gradient && !attrs[has]("stroke-opacity")) {
                                $(node, {
                                    "stroke-opacity": value > 1 ? value / 100 : value
                                });
                            }
                        // fall
                        case "fill-opacity":
                            if (attrs.gradient) {
                                gradient = R._g.doc.getElementById(node.getAttribute("fill").replace(/^url\(#|\)$/g, E));
                                if (gradient) {
                                    stops = gradient.getElementsByTagName("stop");
                                    $(stops[stops.length - 1], {
                                        "stop-opacity": value
                                    });
                                }
                                break;
                            }
                        default:
                            att == "font-size" && (value = toInt(value, 10) + "px");
                            var cssrule = att.replace(/(\-.)/g, function(w) {
                                return w.substring(1).toUpperCase();
                            });
                            node.style[cssrule] = value;
                            o._.dirty = 1;
                            node.setAttribute(att, value);
                            break;
                    }
                }
            }

            tuneText(o, params);
            node.style.visibility = vis;
        },
        leading = 1.2,
        tuneText = function(el, params) {
            if (el.type != "text" || !(params[has]("text") || params[has]("font") ||
                    params[has]("font-size") || params[has]("x") || params[has]("y") ||
                    params[has]("line-height") || params[has]("vertical-align"))) {
                return;
            }
            var a = el.attrs,
            node = el.node,
            computedStyle = node.firstChild && R._g.doc.defaultView.getComputedStyle(node.firstChild, E),
            fontSize = computedStyle ? toFloat(computedStyle.getPropertyValue("font-size")) : 10,
            lineHeight = toFloat(params['line-height'] || a['line-height']) || fontSize * leading,
            valign = a[has]("vertical-align") ? a["vertical-align"] : "middle";

            if (isNaN(lineHeight)) {
                lineHeight = fontSize * leading;
            }

            valign = valign === 'top' ? -0.5 : (valign === 'bottom' ? 0.5 : 0);

            if (params[has]("text") && (params.text !== a.text || el._textdirty)) {
                a.text = params.text;
                while (node.firstChild) {
                    node.removeChild(node.firstChild);
                }
                var texts = Str(params.text).split(/\n|<br\s*?\/?>/ig),
                tspans = [],
                tspan;
                for (var i = 0, ii = texts.length; i < ii; i++) {
                    tspan = $("tspan");
                    if (i) {
                        $(tspan, {
                            dy: lineHeight,
                            x: a.x
                        });
                    } else {
                        $(tspan, {
                            dy: lineHeight * texts.length * valign,
                            x: a.x
                        });
                    }
                    if (!texts[i]) { // preserve blank lines
                        tspan.setAttributeNS("http://www.w3.org/XML/1998/namespace",
                            "xml:space","preserve");
                        texts[i] = " ";
                    }
                    tspan.appendChild(R._g.doc.createTextNode(texts[i]));
                    node.appendChild(tspan);
                    tspans[i] = tspan;
                }
                el._textdirty = false;
            } else {
                tspans = node.getElementsByTagName("tspan");
                for (i = 0, ii = tspans.length; i < ii; i++)
                    if (i) {
                        $(tspans[i], {
                            dy: lineHeight,
                            x: a.x
                        });
                    } else {
                        $(tspans[0], {
                            dy: lineHeight * tspans.length * valign,
                            x: a.x
                        });
                    }
            }
            $(node, {
                x: a.x,
                y: a.y
            });
            el._.dirty = 1;
            var bb = el._getBBox(),
            dif = a.y - (bb.y + bb.height / 2);
            dif && R.is(dif, "finite") && tspans[0] && $(tspans[0], {
                dy: dif
            });
        },
        Element = function(node, svg, group) {
            var o = this,
                parent = group || svg;

            o.node = o[0] = node;
            node.raphael = true;
            node.raphaelid = o.id = R._oid++;

            o.matrix = R.matrix();
            o.realPath = null;

            o.attrs = o.attrs || {};
            o.styles = o.styles || {};
            o.followers = o.followers || [];

            o.paper = svg;
            o.ca = o.customAttributes = o.customAttributes ||
                new svg._CustomAttributes();

            o._ = {
                transform: [],
                sx: 1,
                sy: 1,
                deg: 0,
                dx: 0,
                dy: 0,
                dirty: 1
            };

            o.parent = parent;
            !parent.bottom && (parent.bottom = o);

            o.prev = parent.top;
            parent.top && (parent.top.next = o);
            parent.top = o;
            o.next = null;
        },
        elproto = R.el;

        Element.prototype = elproto;
        elproto.constructor = Element;

        R._engine.getNode = function (el) {
            var node = el.node || el[0].node;
            return node.titleNode || node;
        };
        R._engine.getLastNode = function (el) {
            var node = el.node || el[el.length - 1].node;
            return node.titleNode || node;
        };

        R._engine.path = function(pathString, SVG, group) {
            var el = $("path");

            (group && group.canvas && group.canvas.appendChild(el)) ||
            (SVG.canvas && SVG.canvas.appendChild(el));

            var p = new Element(el, SVG, group);
            p.type = "path";
            setFillAndStroke(p, {
                fill: "none",
                stroke: "#000",
                path: pathString
            });
            return p;
        };

        elproto.rotate = function(deg, cx, cy) {
            var o = this,
                bbox;
            if (o.removed) {
                return o;
            }
            deg = Str(deg).split(separator);
            if (deg.length - 1) {
                cx = toFloat(deg[1]);
                cy = toFloat(deg[2]);
            }
            deg = toFloat(deg[0]);
            (cy == null) && (cx = cy);
            if (cx == null || cy == null) {
                bbox = o.getBBox(1);
                cx = bbox.x + bbox.width / 2;
                cy = bbox.y + bbox.height / 2;
            }
            o.transform(o._.transform.concat([["r", deg, cx, cy]]));
            return o;
        };

        elproto.scale = function(sx, sy, cx, cy) {
            var o = this,
                bbox;
            if (o.removed) {
                return o;
            }
            sx = Str(sx).split(separator);
            if (sx.length - 1) {
                sy = toFloat(sx[1]);
                cx = toFloat(sx[2]);
                cy = toFloat(sx[3]);
            }
            sx = toFloat(sx[0]);
            (sy == null) && (sy = sx);
            (cy == null) && (cx = cy);
            if (cx == null || cy == null) {
                bbox = o.getBBox(1);
            }
            cx = cx == null ? bbox.x + bbox.width / 2 : cx;
            cy = cy == null ? bbox.y + bbox.height / 2 : cy;
            o.transform(o._.transform.concat([["s", sx, sy, cx, cy]]));
            return o;
        };

        elproto.translate = function(dx, dy) {
            var o = this;
            if (o.removed) {
                return o;
            }
            dx = Str(dx).split(separator);
            if (dx.length - 1) {
                dy = toFloat(dx[1]);
            }
            dx = toFloat(dx[0]) || 0;
            dy = +dy || 0;
            o.transform(o._.transform.concat([["t", dx, dy]]));
            return o;
        };

        elproto.transform = function(tstr) {
            var o = this,
                _ = o._,
                sw;

            if (tstr == null) {
                return _.transform;
            }
            R._extractTransform(o, tstr);

            o.clip && !_.clipispath && $(o.clip, {
                transform: o.matrix.invert()
            });
            o.pattern && updatePosition(o);
            o.node && $(o.node, {
                transform: o.matrix
            });

            if (_.sx != 1 || _.sy != 1) {
                sw = o.attrs[has]("stroke-width") ? o.attrs["stroke-width"] : 1;
                o.attr({
                    "stroke-width": sw
                });
            }

            return o;
        };

        elproto.hide = function() {
            var o = this;
            !o.removed && o.paper.safari(o.node.style.display = "none");
            return o;
        };

        elproto.show = function() {
            var o = this;
            !o.removed && o.paper.safari(o.node.style.display = E);
            return o;
        };

        elproto.remove = function() {
            if (this.removed || !this.parent.canvas) {
                return;
            }

            var o = this,
                node = R._engine.getNode(o),
                paper = o.paper,
                defs = paper.defs,
                i;


            paper.__set__ && paper.__set__.exclude(o);
            eve.unbind("raphael.*.*." + o.id);

            if (o.gradient && defs) {
                defs.removeChild(o.gradient);
            }
            while (i = o.followers.pop()) {
                i.el.remove();
            }
            o.parent.canvas.removeChild(node);
            R._tear(o, paper);
            for (i in o) {
                o[i] = typeof o[i] === "function" ? R._removedFactory(i) : null;
            }
            o.removed = true;
        };
        elproto._getBBox = function() {
            var o = this,
                node = o.node,
                bbox = {},
                a = o.attrs,
                align,
                hide;

            if (node.style.display === "none") {
                o.show();
                hide = true;
            }

            try {
                bbox = node.getBBox();

                if (o.type == "text") {
                    // If bbox does not have x / y, which is possible in certain
                    // environments, we mathematically calculate these values by
                    // using x, y (adjusted using the values of text-anchor, and
                    // vertical-align attributes), of the element along with the
                    // width and height provided by the getBBox().
                    if (bbox.x === undefined) {
                        align = a['text-anchor'];
                        bbox.x = (a.x || 0) - (bbox.width * ((align === "start") ?
                            0 : (align === "middle") ? 0.5 : 1));
                    }

                    if (bbox.y === undefined) {
                        align = a['vertical-align'];
                        bbox.y = (a.y || 0) - (bbox.height * ((align === "top") ?
                            1.2 : (align === "middle") ? 0.65 : 0));
                    }
                }

            } catch (e) {
            // Firefox 3.0.x plays badly here
            } finally {
                bbox = bbox || {};
            }
            hide && o.hide();
            return bbox;
        };

        elproto.css = function (name, value) {
            // do not parse css in case element is removed.
            if (this.removed) {
                return this;
            }

            // process as getter when a single key is sent as parameter.
            if (value == null && R.is(name, "string")) {
                var names = name.split(separator),
                out = {};
                for (var i = 0, ii = names.length; i < ii; i++) {
                    name = names[i];
                    if (name in this.styles) {
                        out[name] = this.styles[name];
                    }
                }
                return ii - 1 ? out : out[names[0]];
            }
            // process as getter when multiple keys are pre-sent as array.
            if (value == null && R.is(name, "array")) {
                out = {};
                for (i = 0, ii = name.length; i < ii; i++) {
                    out[name[i]] = this.styles(name[i]);
                }
                return out;
            }
            // convert single key-value setter into object style standard.
            if (value != null) {
                var params = {};
                params[name] = value;
            } else if (name != null && R.is(name, "object")) {
                params = name;
            }
            // iterate on keys and set style or raise events.
            var otherkey, doattrs = {};
            for (var key in params) {
                otherkey = key.replace(/\B([A-Z]{1})/g, "-$1").toLowerCase();

                // If keys are supported via attr then use attr instead of css.
                if (R._availableAttrs[has](otherkey) || otherkey === 'color') {
                    // Replace "color" with fill
                    (otherkey === 'color' && this.type === 'text') && (otherkey = 'fill');

                    doattrs[otherkey] = params[key];
                    doattrs.dirty = true;
                    continue;
                }
                eve("raphael.css." + otherkey + "." + this.id, this, params[key], otherkey);
                this.node.style[otherkey] = params[key];
                this.styles[otherkey] = params[key];
            }
            // run on followers
            for (i = 0, ii = this.followers.length; i < ii; i++) {
                this.followers[i].el.css(params);
            }
            // apply css via attrs
            if (doattrs[has]("dirty")) {
                delete doattrs.dirty;
                this.attr(doattrs);
            }
            return this;
        };

        elproto.attr = function(name, value) {
            if (this.removed) {
                return this;
            }
            if (name == null) {
                var res = {};
                for (var a in this.attrs)
                    if (this.attrs[has](a)) {
                        res[a] = this.attrs[a];
                    }
                res.gradient && res.fill == "none" && (res.fill = res.gradient) && delete res.gradient;
                res.transform = this._.transform;
                res.visibility = this.node.style.display === "none" ? "hidden" : "visible";
                return res;
            }
            if (value == null && R.is(name, "string")) {
                if (name == "fill" && this.attrs.fill == "none" && this.attrs.gradient) {
                    return this.attrs.gradient;
                }
                if (name == "transform") {
                    return this._.transform;
                }
                if (name == "visibility") {
                    return this.node.style.display === "none" ? "hidden" : "visible";
                }
                var names = name.split(separator),
                out = {};
                for (var i = 0, ii = names.length; i < ii; i++) {
                    name = names[i];
                    if (name in this.attrs) {
                        out[name] = this.attrs[name];
                    } else if (R.is(this.ca[name], "function")) {
                        out[name] = this.ca[name].def;
                    } else {
                        out[name] = R._availableAttrs[name];
                    }
                }
                return ii - 1 ? out : out[names[0]];
            }
            if (value == null && R.is(name, "array")) {
                out = {};
                for (i = 0, ii = name.length; i < ii; i++) {
                    out[name[i]] = this.attr(name[i]);
                }
                return out;
            }
            if (value != null) {
                var params = {};
                params[name] = value;
            } else if (name != null && R.is(name, "object")) {
                params = name;
            }
            for (var key in params) {
                eve("raphael.attr." + key + "." + this.id, this, params[key], key);
            }
            var todel = {};
            for (key in this.ca) {
                if (this.ca[key] && params[has](key) && R.is(this.ca[key], "function") && !this.ca['_invoked' + key]) {

                    this.ca['_invoked'+key] = true; // prevent recursion
                    var par = this.ca[key].apply(this, [].concat(params[key]));
                    delete this.ca['_invoked'+key];

                    for (var subkey in par) {
                        if (par[has](subkey)) {
                             params[subkey] = par[subkey];
                        }
                    }
                    this.attrs[key] = params[key];
                    if (par === false) {
                        todel[key] = params[key];
                        delete params[key];
                    }
                }
            }

            setFillAndStroke(this, params);

            var follower;
            for (i = 0, ii = this.followers.length; i < ii; i++) {
                follower = this.followers[i];
                (follower.cb && !follower.cb.call(follower.el, params, this)) ||
                    follower.el.attr(params);
            }

            for (subkey in todel) {
                params[subkey] = todel[subkey];
            }
            return this;
        };

        elproto.blur = function(size) {
            // Experimental. No Safari support. Use it on your own risk.
            var t = this;
            if (+size !== 0) {
                var fltr = $("filter"),
                blur = $("feGaussianBlur");
                t.attrs.blur = size;
                fltr.id = R.createUUID();
                $(blur, {
                    stdDeviation: +size || 1.5
                });
                fltr.appendChild(blur);
                t.paper.defs.appendChild(fltr);
                t._blur = fltr;
                $(t.node, {
                    filter: "url('" + R._url + "#" + fltr.id + "')"
                });
            } else {
                if (t._blur) {
                    t._blur.parentNode.removeChild(t._blur);
                    delete t._blur;
                    delete t.attrs.blur;
                }
                t.node.removeAttribute("filter");
            }
        };

        elproto.on = function(eventType, handler) {
            if (this.removed) {
                return this;
            }

            var fn = handler;
            if (R._supportsTouch) {
                eventType = R._touchMap[eventType] ||
                    (eventType === 'click' && 'touchstart') || eventType;
                fn = function(e) {
                    e.preventDefault();
                    handler();
                };
            }
            this.node['on'+ eventType] = fn;
            return this;
        };


        R._engine.group = function(svg, id, group) {
            var el = $("g");
            (group && group.canvas && group.canvas.appendChild(el)) ||
            (svg.canvas && svg.canvas.appendChild(el));

            var g = new Element(el, svg, group);
            g.type = "group";
            g.canvas = g.node;
            g.top = null;
            g.bottom = null;
            id && el.setAttribute('class', ['red', id, g.id].join('-'));

            return g;
        };

        R._engine.circle = function(svg, x, y, r, group) {
            var el = $("circle");
            (group && group.canvas && group.canvas.appendChild(el)) ||
            (svg.canvas && svg.canvas.appendChild(el));

            var res = new Element(el, svg, group);
            res.attrs = {
                cx: x,
                cy: y,
                r: r,
                fill: "none",
                stroke: "#000"
            };
            res.type = "circle";
            $(el, res.attrs);
            return res;
        };
        R._engine.rect = function(svg, x, y, w, h, r, group) {
            var el = $("rect");
            (group && group.canvas && group.canvas.appendChild(el)) ||
            (svg.canvas && svg.canvas.appendChild(el));

            var res = new Element(el, svg, group);
            res.attrs = {
                x: x,
                y: y,
                width: w,
                height: h,
                r: r || 0,
                rx: r || 0,
                ry: r || 0,
                fill: "none",
                stroke: "#000"
            };
            res.type = "rect";
            $(el, res.attrs);
            return res;
        };
        R._engine.ellipse = function(svg, x, y, rx, ry, group) {
            var el = $("ellipse");
            (group && group.canvas && group.canvas.appendChild(el)) ||
            (svg.canvas && svg.canvas.appendChild(el));

            var res = new Element(el, svg, group);
            res.attrs = {
                cx: x,
                cy: y,
                rx: rx,
                ry: ry,
                fill: "none",
                stroke: "#000"
            };
            res.type = "ellipse";
            $(el, res.attrs);
            return res;
        };
        R._engine.image = function(svg, src, x, y, w, h, group) {
            var el = $("image");
            $(el, {
                x: x,
                y: y,
                width: w,
                height: h,
                preserveAspectRatio: "none"
            });
            el.setAttributeNS(xlink, "href", src);
            (group && group.canvas && group.canvas.appendChild(el)) ||
            (svg.canvas && svg.canvas.appendChild(el));

            var res = new Element(el, svg, group);
            res.attrs = {
                x: x,
                y: y,
                width: w,
                height: h,
                src: src
            };
            res.type = "image";
            return res;
        };
        R._engine.text = function(svg, x, y, text, group) {
            var el = $("text");
            (group && group.canvas && group.canvas.appendChild(el)) ||
            (svg.canvas && svg.canvas.appendChild(el));

            var res = new Element(el, svg, group);
            res.attrs = {
                x: x,
                y: y,
                "text-anchor": "middle",
                "vertical-align": "middle",
                text: text,
                //font: R._availableAttrs.font,
                stroke: "none",
                fill: "#000"
            };
            res.type = "text";
            res._textdirty = true;
            setFillAndStroke(res, res.attrs);
            return res;
        };
        /* @diffend */

        R._engine.setSize = function(width, height) {
            this.width = width || this.width;
            this.height = height || this.height;
            this.canvas.setAttribute("width", this.width);
            this.canvas.setAttribute("height", this.height);
            if (this._viewBox) {
                this.setViewBox.apply(this, this._viewBox);
            }
            return this;
        };
        R._engine.create = function() {
            var con = R._getContainer.apply(0, arguments),
            container = con && con.container,
            x = con.x,
            y = con.y,
            width = con.width,
            height = con.height;
            if (!container) {
                throw new Error("SVG container not found.");
            }
            var cnvs = $("svg"),
            css = "overflow:hidden;-webkit-tap-highlight-color:rgba(0,0,0,0);"+
                "-webkit-user-select:none;-moz-user-select:-moz-none;-khtml-user-select:none;"+
                "-ms-user-select:none;user-select:none;-o-user-select:none;cursor:default;",
            isFloating;
            x = x || 0;
            y = y || 0;
            width = width || 512;
            height = height || 342;
            $(cnvs, {
                height: height,
                version: 1.1,
                width: width,
                xmlns: "http://www.w3.org/2000/svg"
            });
            if (container == 1) {
                cnvs.style.cssText = css + "position:absolute;left:" + x + "px;top:" + y + "px";
                R._g.doc.body.appendChild(cnvs);
                isFloating = 1;
            } else {
                cnvs.style.cssText = css + "position:relative";
                if (container.firstChild) {
                    container.insertBefore(cnvs, container.firstChild);
                } else {
                    container.appendChild(cnvs);
                }
            }
            container = new R._Paper;
            container.width = width;
            container.height = height;
            container.canvas = cnvs;
            container.clear();
            container._left = container._top = 0;
            isFloating && (container.renderfix = function() {
                });
            container.renderfix();
            return container;
        };
        R._engine.setViewBox = function(x, y, w, h, fit) {
            eve("raphael.setViewBox", this, this._viewBox, [x, y, w, h, fit]);
            var size = mmax(w / this.width, h / this.height),
            top = this.top,
            aspectRatio = fit ? "meet" : "xMinYMin",
            vb,
            sw;
            if (x == null) {
                if (this._vbSize) {
                    size = 1;
                }
                delete this._vbSize;
                vb = "0 0 " + this.width + S + this.height;
            } else {
                this._vbSize = size;
                vb = x + S + y + S + w + S + h;
            }
            $(this.canvas, {
                viewBox: vb,
                preserveAspectRatio: aspectRatio
            });
            while (size && top) {
                sw = "stroke-width" in top.attrs ? top.attrs["stroke-width"] : 1;
                top.attr({
                    "stroke-width": sw
                });
                top._.dirty = 1;
                top._.dirtyT = 1;
                top = top.prev;
            }
            this._viewBox = [x, y, w, h, !!fit];
            return this;
        };

        R.prototype.renderfix = function() {
            var cnvs = this.canvas,
            s = cnvs.style,
            pos;
            try {
                pos = cnvs.getScreenCTM() || cnvs.createSVGMatrix();
            } catch (e) {
                pos = cnvs.createSVGMatrix();
            }
            var left = -pos.e % 1,
            top = - pos.f % 1;
            if (left || top) {
                if (left) {
                    this._left = (this._left + left) % 1;
                    s.left = this._left + "px";
                }
                if (top) {
                    this._top = (this._top + top) % 1;
                    s.top = this._top + "px";
                }
            }
        };

        R.prototype.clear = function() {
            eve("raphael.clear", this);
            var c = this.canvas;
            while (c.firstChild) {
                c.removeChild(c.firstChild);
            }
            this.bottom = this.top = null;
            (this.desc = $("desc")).appendChild(R._g.doc.createTextNode(R.is(R.desc, "string") && R.desc ||
                "Created with Red Rapha\xebl " + R.version));
            c.appendChild(this.desc);
            c.appendChild(this.defs = $("defs"));
        };

        R.prototype.remove = function() {
            eve("raphael.remove", this);
            this.canvas.parentNode && this.canvas.parentNode.removeChild(this.canvas);
            for (var i in this) {
                this[i] = typeof this[i] == "function" ? R._removedFactory(i) : null;
            }
            this.removed = true;
        };
        var setproto = R.st;
        for (var method in elproto)
            if (elproto[has](method) && !setproto[has](method)) {
                setproto[method] = (function(methodname) {
                    return function() {
                        var arg = arguments;
                        return this.forEach(function(el) {
                            el[methodname].apply(el, arg);
                        });
                    };
                })(method);
            }
    }(window.Raphael);

    /**
     * @section
     * Raphael 2.1.0 - VML Rendering Library
     * -------------------------------------
     */
    window.Raphael.vml && function(R) {
        var has = "hasOwnProperty",
        Str = String,
        toFloat = parseFloat,
        math = Math,
        round = math.round,
        mmax = math.max,
        mmin = math.min,
        sqrt = math.sqrt,
        abs = math.abs,
        fillString = "fill",
        separator = /[, ]+/,
        eve = R.eve,
        ms = " progid:DXImageTransform.Microsoft",
        S = " ",
        E = "",
        map = {
            M: "m",
            L: "l",
            C: "c",
            Z: "x",
            m: "t",
            l: "r",
            c: "v",
            z: "x"
        },
        bites = /([clmz]),?([^clmz]*)/gi,
        blurregexp = / progid:\S+Blur\([^\)]+\)/g,
        val = /-?[^,\s-]+/g,
        cssDot = "position:absolute;left:0;top:0;width:1px;height:1px",
        zoom = 21600,
        pathTypes = {
            path: 1,
            rect: 1,
            image: 1
        },
        ovalTypes = {
            circle: 1,
            ellipse: 1
        },
        path2vml = function(path) {
            var total = /[ahqstv]/ig,
            command = R._pathToAbsolute;
            Str(path).match(total) && (command = R._path2curve);
            total = /[clmz]/g;
            if (command == R._pathToAbsolute && !Str(path).match(total)) {
                var res = Str(path).replace(bites, function(all, command, args) {
                    var vals = [],
                    isMove = command.toLowerCase() == "m",
                    res = map[command];
                    args.replace(val, function(value) {
                        if (isMove && vals.length == 2) {
                            res += vals + map[command == "m" ? "l" : "L"];
                            vals = [];
                        }
                        vals.push(round(value * zoom));
                    });
                    return res + vals;
                });

                return res || 'm0,0';
            }
            var pa = command(path), p, r;
            res = [];
            for (var i = 0, ii = pa.length; i < ii; i++) {
                p = pa[i];
                r = pa[i][0].toLowerCase();
                r == "z" && (r = "x");
                for (var j = 1, jj = p.length; j < jj; j++) {
                    r += round(p[j] * zoom) + (j != jj - 1 ? "," : E);
                }
                res.push(r);
            }
            return res.length ? res.join(S) : 'm0,0';
        },
        compensation = function(deg, dx, dy) {
            var m = R.matrix();
            m.rotate(-deg, .5, .5);
            return {
                dx: m.x(dx, dy),
                dy: m.y(dx, dy)
            };
        },
        setCoords = function(p, sx, sy, dx, dy, deg) {
            var _ = p._,
            m = p.matrix,
            fillpos = _.fillpos,
            o = p.node,
            s = o.style,
            y = 1,
            flip = "",
            dxdy,
            kx = zoom / sx,
            ky = zoom / sy;
            s.visibility = "hidden";
            if (!sx || !sy) {
                return;
            }
            o.coordsize = abs(kx) + S + abs(ky);
            s.rotation = deg * (sx * sy < 0 ? -1 : 1);
            if (deg) {
                var c = compensation(deg, dx, dy);
                dx = c.dx;
                dy = c.dy;
            }
            sx < 0 && (flip += "x");
            sy < 0 && (flip += " y") && (y = -1);
            s.flip = flip;
            o.coordorigin = (dx * -kx) + S + (dy * -ky);
            if (fillpos || _.fillsize) {
                var fill = o.getElementsByTagName(fillString);
                fill = fill && fill[0];
                o.removeChild(fill);
                if (fillpos) {
                    c = compensation(deg, m.x(fillpos[0], fillpos[1]), m.y(fillpos[0], fillpos[1]));
                    fill.position = c.dx * y + S + c.dy * y;
                }
                if (_.fillsize) {
                    fill.size = _.fillsize[0] * abs(sx) + S + _.fillsize[1] * abs(sy);
                }
                o.appendChild(fill);
            }
            s.visibility = "visible";
        };
        R._url = E;
        R.toString = function() {
            return  "Your browser doesn\u2019t support SVG. Falling down to VML.\nYou are running Rapha\xebl " + this.version;
        };
        var addArrow = function(o, value, isEnd) {
            var values = Str(value).toLowerCase().split("-"),
            se = isEnd ? "end" : "start",
            i = values.length,
            type = "classic",
            w = "medium",
            h = "medium";
            while (i--) {
                switch (values[i]) {
                    case "block":
                    case "classic":
                    case "oval":
                    case "diamond":
                    case "open":
                    case "none":
                        type = values[i];
                        break;
                    case "wide":
                    case "narrow":
                        h = values[i];
                        break;
                    case "long":
                    case "short":
                        w = values[i];
                        break;
                }
            }
            var stroke = o.node.getElementsByTagName("stroke")[0];
            stroke[se + "arrow"] = type;
            stroke[se + "arrowlength"] = w;
            stroke[se + "arrowwidth"] = h;
        },
        setFillAndStroke = R._setFillAndStroke = function(o, params) {
            if (!o.paper.canvas) return;
            // o.paper.canvas.style.display = "none";
            o.attrs = o.attrs || {};
            var node = o.node,
            a = o.attrs,
            s = node.style,
            xy,
            newpath = pathTypes[o.type] && (params.x != a.x || params.y != a.y || params.width != a.width || params.height != a.height || params.cx != a.cx || params.cy != a.cy || params.rx != a.rx || params.ry != a.ry || params.r != a.r),
            isOval = ovalTypes[o.type] && (a.cx != params.cx || a.cy != params.cy || a.r != params.r || a.rx != params.rx || a.ry != params.ry),
            isGroup = o.type === 'group',
            res = o;


            for (var par in params)
                if (params[has](par)) {
                    a[par] = params[par];
                }
            if (newpath) {
                a.path = R._getPath[o.type](o);
                o._.dirty = 1;
            }
            params.href && (node.href = params.href);
            params.title && (node.title = params.title);
            params.target && (node.target = params.target);
            params.cursor && (s.cursor = params.cursor);
            "blur" in params && o.blur(params.blur);
            if (params.path && o.type == "path" || newpath) {
                node.path = path2vml(~Str(a.path).toLowerCase().indexOf("r") ? R._pathToAbsolute(a.path) : a.path);
                if (o.type == "image") {
                    o._.fillpos = [a.x, a.y];
                    o._.fillsize = [a.width, a.height];
                    setCoords(o, 1, 1, 0, 0, 0);
                }
            }
            "transform" in params && o.transform(params.transform);
            if ("rotation" in params) {
                var rotation = params.rotation;
                if (R.is(rotation, "array")) {
                    o.rotate.apply(o, rotation);
                }
                else {
                    o.rotate(rotation);
                }
            }
            if ("shape-rendering" in params) {
                node.style.antialias = (params["shape-rendering"] !== 'crisp');
            }
            if ("visibility" in params) {
                params.visibility === 'hidden' ? o.hide() : o.show();
            }
            if (isOval) {
                var cx = +a.cx,
                cy = +a.cy,
                rx = +a.rx || +a.r || 0,
                ry = + a.ry || + a.r || 0;
                node.path = R.format("ar{0},{1},{2},{3},{4},{1},{4},{1}x", round((cx - rx) * zoom), round((cy - ry) * zoom), round((cx + rx) * zoom), round((cy + ry) * zoom), round(cx * zoom));
            }
            if ("clip-rect" in params) {
                var rect = Str(params["clip-rect"]).split(separator);

                if (rect.length == 4) {
                    rect[0] = +rect[0];
                    rect[1] = +rect[1];
                    rect[2] = +rect[2] + rect[0];
                    rect[3] = +rect[3] + rect[1];

                    

                    var div = isGroup ? node : (node.clipRect ||
                            R._g.doc.createElement("div")),
                        offset,
                        dstyle = div.style;

                    if (isGroup) {
                        o.clip = rect.slice(); // copy param
                        offset = o.matrix.offset();
                        offset = [toFloat(offset[0]), toFloat(offset[1])];
                        // invert matrix calculation
                        rect[0] -= offset[0];
                        rect[1] -= offset[1];
                        rect[2] -= offset[0];
                        rect[3] -= offset[1];
                        // Fix for bug in ie clip-auto when height/width is not defined
                        

                        dstyle.width = "10800px";
                        dstyle.height = "10800px";
                    }
                    else if (!node.clipRect) {
                        dstyle.top = "0";
                        dstyle.left = "0";
                        dstyle.width = o.paper.width + "px";
                        dstyle.height = o.paper.height + "px";
                        node.parentNode.insertBefore(div, node);
                        div.appendChild(node);
                        node.clipRect = div;
                    }
                    dstyle.position = "absolute";
                    dstyle.clip = R.format("rect({1}px {2}px {3}px {0}px)", rect);
                }
                if (!params["clip-rect"]) {
                    if (isGroup && o.clip) {
                        node.style.clip = "rect(auto auto auto auto)";
                        delete o.clip;
                    }
                    else if (node.clipRect) {
                        node.clipRect.style.clip = "rect(auto auto auto auto)";
                    }
                }
            }
            if (o.textpath) {
                var textpathStyle = o.textpath.style;
                params.font && (textpathStyle.font = params.font);
                params["font-family"] && (textpathStyle.fontFamily = '"' + params["font-family"].split(",")[0].replace(/^['"]+|['"]+$/g, E) + '"');
                params["font-size"] && (textpathStyle.fontSize = params["font-size"]);
                params["font-weight"] && (textpathStyle.fontWeight = params["font-weight"]);
                params["font-style"] && (textpathStyle.fontStyle = params["font-style"]);
            }
            if ("arrow-start" in params) {
                addArrow(res, params["arrow-start"]);
            }
            if ("arrow-end" in params) {
                addArrow(res, params["arrow-end"], 1);
            }
            if (params.opacity != null ||
                params["stroke-width"] != null ||
                params.fill != null ||
                params.src != null ||
                params.stroke != null ||
                params["stroke-width"] != null ||
                params["stroke-opacity"] != null ||
                params["fill-opacity"] != null ||
                params["stroke-dasharray"] != null ||
                params["stroke-miterlimit"] != null ||
                params["stroke-linejoin"] != null ||
                params["stroke-linecap"] != null) {
                var fill = node.getElementsByTagName(fillString),
                newfill = false,
                fillOpacity = -1;
                fill = fill && fill[0];
                !fill && (newfill = fill = createNode(fillString));
                if (o.type == "image" && params.src) {
                    fill.src = params.src;
                }
                params.fill && (fill.on = true);
                if (fill.on == null || params.fill == "none" || params.fill === null) {
                    fill.on = false;
                }
                if (fill.on && params.fill) {
                    var isURL = Str(params.fill).match(R._ISURL);
                    if (isURL) {
                        fill.parentNode == node && node.removeChild(fill);
                        fill.rotate = true;
                        fill.src = isURL[1];
                        fill.type = "tile";
                        var bbox = o.getBBox(1);
                        fill.position = bbox.x + S + bbox.y;
                        o._.fillpos = [bbox.x, bbox.y];

                        R._preload(isURL[1], function() {
                            o._.fillsize = [this.offsetWidth, this.offsetHeight];
                        });
                    } else {
                        var color = R.getRGB(params.fill);
                        fill.color = color.hex;
                        fill.src = E;
                        fill.type = "solid";
                        if (color.error && (res.type in {
                            circle: 1,
                            ellipse: 1
                        } || Str(params.fill).charAt() != "r") && addGradientFill(res, params.fill, fill)) {
                            a.fill = "none";
                            a.gradient = params.fill;
                            fill.rotate = false;
                        }
                        else if ("opacity" in color && !("fill-opacity" in params)) {
                            fillOpacity = color.opacity;
                        }
                    }
                }
                if (fillOpacity !== -1 || "fill-opacity" in params || "opacity" in params) {
                    var opacity = ((+a["fill-opacity"] + 1 || 2) - 1) * ((+a.opacity + 1 || 2) - 1) * ((+fillOpacity + 1 || 2) - 1);
                    opacity = mmin(mmax(opacity, 0), 1);
                    fill.opacity = opacity;
                    if (fill.src) {
                        fill.color = "none";
                    }
                }
                node.appendChild(fill);
                var stroke = (node.getElementsByTagName("stroke") && node.getElementsByTagName("stroke")[0]),
                newstroke = false;
                !stroke && (newstroke = stroke = createNode("stroke"));
                if ((params.stroke && params.stroke != "none") ||
                    params["stroke-width"] ||
                    params["stroke-opacity"] != null ||
                    params["stroke-dasharray"] ||
                    params["stroke-miterlimit"] ||
                    params["stroke-linejoin"] ||
                    params["stroke-linecap"]) {
                    stroke.on = true;
                }
                (params.stroke == "none" || params.stroke === null || stroke.on == null || params.stroke == 0 || params["stroke-width"] == 0) && (stroke.on = false);
                var strokeColor = R.getRGB(('stroke' in params) ? params.stroke : a.stroke);
                stroke.on && params.stroke && (stroke.color = strokeColor.hex);
                opacity = ((+a["stroke-opacity"] + 1 || 2) - 1) * ((+a.opacity + 1 || 2) - 1) * ((+strokeColor.opacity + 1 || 2) - 1);
                var width = (toFloat(params["stroke-width"]) || 1) * .75;
                opacity = mmin(mmax(opacity, 0), 1);
                params["stroke-width"] == null && (width = a["stroke-width"]);
                params["stroke-width"] && (stroke.weight = width);
                width && width < 1 && (opacity *= width) && (stroke.weight = 1);
                stroke.opacity = opacity;

                params["stroke-linejoin"] && (stroke.joinstyle = params["stroke-linejoin"]) || newstroke && (newstroke.joinstyle = 'miter');
                stroke.miterlimit = params["stroke-miterlimit"] || 8;
                params["stroke-linecap"] && (stroke.endcap = params["stroke-linecap"] == "butt" ? "flat" : params["stroke-linecap"] == "square" ? "square" : "round");
                if (params["stroke-dasharray"]) {
                    var dasharray = {
                        "-": "shortdash",
                        ".": "shortdot",
                        "-.": "shortdashdot",
                        "-..": "shortdashdotdot",
                        ". ": "dot",
                        "- ": "dash",
                        "--": "longdash",
                        "- .": "dashdot",
                        "--.": "longdashdot",
                        "--..": "longdashdotdot"
                    };
                    stroke.dashstyle = dasharray[has](params["stroke-dasharray"]) ? dasharray[params["stroke-dasharray"]] :
                            ((params["stroke-dasharray"].join && params["stroke-dasharray"].join(' ')) || E);
                }
                newstroke && node.appendChild(stroke);
            }
            if (res.type == "text") {
                res.paper.canvas.style.display = E;
                var span = res.paper.span,
                m = 100,
                fontSize = a.font && a.font.match(/\d+(?:\.\d*)?(?=px)/),
                lineHeight = a['line-height'] && (a['line-height']+E).match(/\d+(?:\.\d*)?(?=px)/);
                s = span.style;
                a.font && (s.font = a.font);
                a["font-family"] && (s.fontFamily = a["font-family"]);
                a["font-weight"] && (s.fontWeight = a["font-weight"]);
                a["font-style"] && (s.fontStyle = a["font-style"]);
                fontSize = toFloat(a["font-size"] || fontSize && fontSize[0]) || 10;
                s.fontSize = fontSize * m + "px";
                lineHeight = toFloat(a["line-height"] || lineHeight && lineHeight[0]) || 12;
                a["line-height"] && (s.lineHeight = lineHeight * m + 'px');
                res.textpath.string && (span.innerHTML = Str(res.textpath.string).replace(/</g, "&#60;").replace(/&/g, "&#38;").replace(/\n/g, "<br>"));
                var brect = span.getBoundingClientRect();
                res.W = a.w = (brect.right - brect.left) / m;
                res.H = a.h = (brect.bottom - brect.top) / m;
                // res.paper.canvas.style.display = "none";
                res.X = a.x;
                res.Y = a.y;
                var leading = lineHeight - fontSize;
                switch(a["vertical-align"]) {
                    case "top":
                        res.bby = res.H / 2; // + leading;
                        break;
                    case "bottom":
                        res.bby = -res.H / 2; // - leading;
                        break;
                    default:
                        res.bby = 0;
                }

                ("x" in params || "y" in params || res.bby !== undefined) && (res.path.v = R.format("m{0},{1}l{2},{1}", round(a.x * zoom), round((a.y + (res.bby || 0)) * zoom), round(a.x * zoom) + 1));
                var dirtyattrs = ["x", "y", "text", "font", "font-family", "font-weight", "font-style", "font-size", "line-height"];
                for (var d = 0, dd = dirtyattrs.length; d < dd; d++)
                    if (dirtyattrs[d] in params) {
                        res._.dirty = 1;
                        break;
                    }

                // text-anchor emulation
                switch (a["text-anchor"]) {
                    case "start":
                        res.textpath.style["v-text-align"] = "left";
                        res.bbx = res.W / 2;
                        break;
                    case "end":
                        res.textpath.style["v-text-align"] = "right";
                        res.bbx = -res.W / 2;
                        break;
                    default:
                        res.textpath.style["v-text-align"] = "center";
                        res.bbx = 0;
                        break;
                }
                res.textpath.style["v-text-kern"] = true;
            }
        // res.paper.canvas.style.display = E;
        },
        addGradientFill = function(o, gradient, fill) {
            o.attrs = o.attrs || {};
            var attrs = o.attrs,
            pow = Math.pow,
            opacity,
            oindex,
            type = "linear",
            fxfy = ".5 .5";
            o.attrs.gradient = gradient;
            gradient = Str(gradient).replace(R._radial_gradient, function(all, opts) {
                type = "radial";
                opts = opts && opts.split(',') || [];

                // fx,fy of vml is cx,cy of svg
                var cx = opts[0],
                    cy = opts[1],
                    r = opts[2],
                    fx = opts[3],
                    fy = opts[4],
                    units = opts[5];
                if (fx && fy) {
                    fx = toFloat(fx);
                    fy = toFloat(fy);
                    pow(fx - .5, 2) + pow(fy - .5, 2) > .25 && (fy = sqrt(.25 - pow(fx - .5, 2)) * ((fy > .5) * 2 - 1) + .5);
                    fxfy = fx + S + fy;
                }
                return E;
            });
            gradient = gradient.split(/\s*\-\s*/);
            if (type == "linear") {
                var angle = gradient.shift();
                angle = -toFloat(angle);
                if (isNaN(angle)) {
                    return null;
                }
            }
            var dots = R._parseDots(gradient);
            if (!dots) {
                return null;
            }
            o = o.shape || o.node;
            if (dots.length) {
                o.removeChild(fill);
                fill.on = true;
                fill.method = "none";
                fill.color = dots[0].color;
                fill.color2 = dots[dots.length - 1].color;
                //For VML use first and last available alpha
                var clrs = [],
                opacity1 = 1,
                opacity2 = dots[0].opacity === undefined ? 1 : dots[0].opacity;
                for (var i = 0, ii = dots.length; i < ii; i++) {
                    dots[i].offset && clrs.push(dots[i].offset + S + dots[i].color);
                    if (dots[i].opacity !== undefined) {
                        opacity1 = dots[i].opacity;//update with latest avaible opacity
                    }
                }
                fill.colors = clrs.length ? clrs.join() : "0% " + fill.color;
                //set opacity1 & opacity2
                fill.opacity = opacity1;
                fill['o:opacity2'] = opacity2;
                if (type == "radial") {
                    fill.type = "gradientTitle";
                    fill.focus = "100%";
                    fill.focussize = "0 0";
                    fill.focusposition = fxfy;
                    fill.angle = 0;
                } else {
                    // fill.rotate= true;
                    fill.type = "gradient";
                    fill.angle = (270 - angle) % 360;
                }
                o.appendChild(fill);
            }
            return 1;
        },
        Element = function(node, vml, group) {
            var o = this,
                parent = group || vml;

            o.node = o[0] = node;
            node.raphael = true;
            node.raphaelid = o.id = R._oid++;

            o.X = 0;
            o.Y = 0;

            o.attrs = o.attrs || {};
            o.styles = o.styles || {};
            o.followers = o.followers || [];

            o.paper = vml;
            o.ca = o.customAttributes = o.customAttributes ||
                new vml._CustomAttributes();

            o.matrix = R.matrix();
            o._ = {
                transform: [],
                sx: 1,
                sy: 1,
                dx: 0,
                dy: 0,
                deg: 0,
                dirty: 1,
                dirtyT: 1
            };

            o.parent = parent;
            !parent.bottom && (parent.bottom = o);

            o.prev = parent.top;
            parent.top && (parent.top.next = o);
            parent.top = o;
            o.next = null;
        };
        var elproto = R.el;

        Element.prototype = elproto;
        elproto.constructor = Element;

        elproto.transform = function(tstr) {
            if (tstr == null) {
                return this._.transform;
            }
            var vbs = this.paper._viewBoxShift,
            vbt = vbs ? "s" + [vbs.scale, vbs.scale] + "-1-1t" + [vbs.dx, vbs.dy] : E,
            oldt;

            if (vbs) {
                oldt = tstr = Str(tstr).replace(/\.{3}|\u2026/g, this._.transform || E);
            }

            R._extractTransform(this, vbt + tstr);

            var matrix = this.matrix.clone(),
            skew = this.skew,
            o = this.node,
            split,
            isGrad = ~Str(this.attrs.fill).indexOf("-"),
            isPatt = !Str(this.attrs.fill).indexOf("url(");
            matrix.translate(-.5, -.5);
            if (isPatt || isGrad || this.type == "image") {
                skew.matrix = "1 0 0 1";
                skew.offset = "0 0";
                split = matrix.split();
                if ((isGrad && split.noRotation) || !split.isSimple) {
                    o.style.filter = matrix.toFilter();
                    var bb = this.getBBox(),
                    bbt = this.getBBox(1),
                    xget = bb.x2 && bbt.x2 && 'x2' || 'x',
                    yget = bb.y2 && bbt.y2 && 'y2' || 'y',
                    dx = bb[xget] - bbt[xget],
                    dy = bb[yget] - bbt[yget];
                    o.coordorigin = (dx * -zoom) + S + (dy * -zoom);
                    setCoords(this, 1, 1, dx, dy, 0);
                } else {
                    o.style.filter = E;
                    setCoords(this, split.scalex, split.scaley, split.dx, split.dy, split.rotate);
                }
            } else {
                o.style.filter = E;
                skew.matrix = Str(matrix);
                skew.offset = matrix.offset();
            }
            oldt && (this._.transform = oldt);

            return this;
        };
        elproto.rotate = function(deg, cx, cy) {
            if (this.removed) {
                return this;
            }
            if (deg == null) {
                return;
            }
            deg = Str(deg).split(separator);
            if (deg.length - 1) {
                cx = toFloat(deg[1]);
                cy = toFloat(deg[2]);
            }
            deg = toFloat(deg[0]);
            (cy == null) && (cx = cy);
            if (cx == null || cy == null) {
                var bbox = this.getBBox(1);
                cx = bbox.x + bbox.width / 2;
                cy = bbox.y + bbox.height / 2;
            }
            this._.dirtyT = 1;
            this.transform(this._.transform.concat([["r", deg, cx, cy]]));
            return this;
        };
        elproto.translate = function(dx, dy) {
            if (this.removed) {
                return this;
            }
            dx = Str(dx).split(separator);
            if (dx.length - 1) {
                dy = toFloat(dx[1]);
            }
            dx = toFloat(dx[0]) || 0;
            dy = +dy || 0;
            if (this._.bbox) {
                this._.bbox.x += dx;
                this._.bbox.y += dy;
            }
            this.transform(this._.transform.concat([["t", dx, dy]]));
            return this;
        };
        elproto.scale = function(sx, sy, cx, cy) {
            if (this.removed) {
                return this;
            }
            sx = Str(sx).split(separator);
            if (sx.length - 1) {
                sy = toFloat(sx[1]);
                cx = toFloat(sx[2]);
                cy = toFloat(sx[3]);
                isNaN(cx) && (cx = null);
                isNaN(cy) && (cy = null);
            }
            sx = toFloat(sx[0]);
            (sy == null) && (sy = sx);
            (cy == null) && (cx = cy);
            if (cx == null || cy == null) {
                var bbox = this.getBBox(1);
            }
            cx = cx == null ? bbox.x + bbox.width / 2 : cx;
            cy = cy == null ? bbox.y + bbox.height / 2 : cy;

            this.transform(this._.transform.concat([["s", sx, sy, cx, cy]]));
            this._.dirtyT = 1;
            return this;
        };
        elproto.hide = function(soft) {
            var o = this;
            !o.removed && (o.node.style.display = "none");
            return o;
        };

        elproto.show = function(soft) {
            var o = this;
            !o.removed && (o.node.style.display = E);
            return o;
        };
        elproto._getBBox = function() {
            if (this.removed) {
                return {};
            }
            return {
                x: this.X + (this.bbx || 0) - this.W / 2,
                y: this.Y + (this.bby || 0) - this.H / 2,
                width: this.W,
                height: this.H
            };
        };
        elproto.remove = function() {
            if (this.removed || !this.parent.canvas) {
                return;
            }
            var i,
                thisNode = R._engine.getNode(this);
            this.paper.__set__ && this.paper.__set__.exclude(this);
            eve.unbind("raphael.*.*." + this.id);
            while (i = this.followers.pop()) {
                i.el.remove();
            }
            this.shape && this.shape.parentNode.removeChild(this.shape);
            thisNode.parentNode.removeChild(thisNode);
            R._tear(this, this.paper);
            for (var i in this) {
                this[i] = typeof this[i] == "function" ? R._removedFactory(i) : null;
            }
            this.removed = true;
        };
        elproto.css = function (name, value) {
            // do not parse css in case element is removed.
            if (this.removed) {
                return this;
            }

            // process as getter when a single key is sent as parameter.
            if (value == null && R.is(name, "string")) {
                var names = name.split(separator),
                out = {};
                for (var i = 0, ii = names.length; i < ii; i++) {
                    name = names[i];
                    if (name in this.styles) {
                        out[name] = this.styles[name];
                    }
                }
                return ii - 1 ? out : out[names[0]];
            }
            // process as getter when multiple keys are pre-sent as array.
            if (value == null && R.is(name, "array")) {
                out = {};
                for (i = 0, ii = name.length; i < ii; i++) {
                    out[name[i]] = this.styles(name[i]);
                }
                return out;
            }
            // convert single key-value setter into object style standard.
            if (value != null) {
                var params = {};
                params[name] = value;
            } else if (name != null && R.is(name, "object")) {
                params = name;
            }
            // iterate on keys and set style or raise events.
            var otherkey, doattrs = {};
            for (var key in params) {
                otherkey = key.replace(/\B([A-Z]{1})/g, "-$1").toLowerCase();
                // Replace "color" with fill
                (otherkey === 'color' && this.type === 'text') && (otherkey = 'fill');
                // If keys are supported via attr then use attr instead of css.
                if (R._availableAttrs[has](otherkey)) {
                    doattrs[otherkey] = params[key];
                    doattrs.dirty = true;
                    continue;
                }
                eve("raphael.css." + otherkey + "." + this.id, this, params[key], otherkey);
                (params[key] != undefined) && (this.node.style[otherkey] = params[key]);
                this.styles[otherkey] = params[key];
            }

            for (i = 0, ii = this.followers.length; i < ii; i++) {
                this.followers[i].el.css(params);
            }

            // apply css via attrs
            if (doattrs[has]("dirty")) {
                delete doattrs.dirty;
                this.attr(doattrs);
            }

            return this;
        };
        elproto.attr = function(name, value) {
            if (this.removed) {
                return this;
            }
            if (name == null) {
                var res = {};
                for (var a in this.attrs)
                    if (this.attrs[has](a)) {
                        res[a] = this.attrs[a];
                    }
                res.gradient && res.fill == "none" && (res.fill = res.gradient) && delete res.gradient;
                res.transform = this._.transform;
                res.visibility = this.node.style.display === "none" ? "hidden" : "visible";
                return res;
            }
            if (value == null && R.is(name, "string")) {
                if (name == fillString && this.attrs.fill == "none" && this.attrs.gradient) {
                    return this.attrs.gradient;
                }
                if (name == "visibility") {
                    return this.node.style.display === "none" ? "hidden" : "visible";
                }
                var names = name.split(separator),
                out = {};
                for (var i = 0, ii = names.length; i < ii; i++) {
                    name = names[i];
                    if (name in this.attrs) {
                        out[name] = this.attrs[name];
                    } else if (R.is(this.ca[name], "function")) {
                        out[name] = this.ca[name].def;
                    } else {
                        out[name] = R._availableAttrs[name];
                    }
                }
                return ii - 1 ? out : out[names[0]];
            }
            if (this.attrs && value == null && R.is(name, "array")) {
                out = {};
                for (i = 0, ii = name.length; i < ii; i++) {
                    out[name[i]] = this.attr(name[i]);
                }
                return out;
            }
            var params;
            if (value != null) {
                params = {};
                params[name] = value;
            }
            value == null && R.is(name, "object") && (params = name);
            for (var key in params) {
                eve("raphael.attr." + key + "." + this.id, this, params[key], key);
            }
            if (params) {
                var todel = {};
                for (key in this.ca)
                    if (this.ca[key] && params[has](key) && R.is(this.ca[key], "function") && !this.ca['_invoked' + key]) {
                        this.ca['_invoked' + key] = true; // prevent recursion
                        var par = this.ca[key].apply(this, [].concat(params[key]));
                        delete this.ca['_invoked' + key];

                        for (var subkey in par) {
                            if (par[has](subkey)) {
                                params[subkey] = par[subkey];
                            }
                        }
                        this.attrs[key] = params[key];
                        if (par === false) {
                            todel[key] = params[key];
                            delete params[key];
                        }
                    }
                // this.paper.canvas.style.display = "none";
                if ('text' in params && this.type == "text") {
                    this.textpath.string = params.text.replace(/<br\s*?\/?>/ig, '\n');
                }
                setFillAndStroke(this, params);
                var follower;
                for (i = 0, ii = this.followers.length; i < ii; i++) {
                    follower = this.followers[i];
                    (follower.cb && !follower.cb.call(follower.el, params, this)) ||
                        follower.el.attr(params);
                }
                for (var subkey in todel) {
                    params[subkey] = todel[subkey];
                }
            // this.paper.canvas.style.display = E;
            }
            return this;
        };

        elproto.blur = function(size) {
            var s = this.node.runtimeStyle,
            f = s.filter;
            f = f.replace(blurregexp, E);
            if (+size !== 0) {
                this.attrs.blur = size;
                s.filter = f + S + ms + ".Blur(pixelradius=" + (+size || 1.5) + ")";
                s.margin = R.format("-{0}px 0 0 -{0}px", round(+size || 1.5));
            } else {
                s.filter = f;
                s.margin = 0;
                delete this.attrs.blur;
            }
            return this;
        };

        elproto.on = function(eventType, handler) {
            if (this.removed) {
                return this;
            }

            this.node['on'+ eventType] = function() {
                var evt = R._g.win.event;
                evt.target = evt.srcElement;
                handler(evt);
            };
            return this;
        };

        R._engine.getNode = function (el) {
            var node = el.node || el[0].node;
            return node.clipRect || node;
        };
        R._engine.getLastNode = function (el) {
            var node = el.node || el[el.length - 1].node;
            return node.clipRect || node;
        };

        R._engine.group = function(vml, id, group) {
            var el = R._g.doc.createElement("div"),
                p = new Element(el, vml, group);

            el.style.cssText = cssDot;

            id && (el.className = ['red', id, p.id].join('-'));
            (group || vml).canvas.appendChild(el);

            p.type = 'group';
            p.canvas = p.node;
            p.transform = R._engine.group.transform;
            p.top = null;
            p.bottom = null;

            return p;
        };

        R._engine.group.transform = function(tstr) {
            if (tstr == null) {
                return this._.transform;
            }

            var o = this,
                s = o.node.style,
                c = o.clip,
                vbs = o.paper._viewBoxShift,
                vbt = vbs ? "s" + [vbs.scale, vbs.scale] + "-1-1t" + [vbs.dx, vbs.dy] : E,
                oldt,
                matrix,
                offset,
                tx,
                ty;

            if (vbs) {
                oldt = tstr = Str(tstr).replace(/\.{3}|\u2026/g, o._.transform || E);
            }
            R._extractTransform(o, vbt + tstr);
            matrix = o.matrix;
            offset = matrix.offset();
            tx = toFloat(offset[0]) || 0;
            ty = toFloat(offset[1]) || 0;

            s.left = tx + "px";
            s.top = ty + "px";
            s.zoom = (o._.tzoom = matrix.get(0)) + E;

            

            c && (s.clip = R.format("rect({1}px {2}px {3}px {0}px)", [
                c[0] - tx, c[1] - ty, c[2] - tx, c[3] - ty
            ]));

            return o;
        };

        R._engine.path = function(pathString, vml, group) {
            var el = createNode("shape");
            el.style.cssText = cssDot;
            el.coordsize = zoom + S + zoom;
            el.coordorigin = vml.coordorigin;
            var p = new Element(el, vml, group),
            attr = {
                fill: "none",
                stroke: "#000"
            };

            pathString && (attr.path = pathString);
            p.type = "path";
            p.path = [];
            p.Path = E;
            setFillAndStroke(p, attr);
            (group || vml).canvas.appendChild(el);

            var skew = createNode("skew");
            skew.on = true;
            el.appendChild(skew);
            p.skew = skew;
            return p;
        };

        R._engine.rect = function(vml, x, y, w, h, r, group) {
            var path = R._rectPath(x, y, w, h, r),
            res = vml.path(path, group),
            a = res.attrs;
            res.X = a.x = x;
            res.Y = a.y = y;
            res.W = a.width = w;
            res.H = a.height = h;
            a.r = r;
            a.path = path;
            res.type = "rect";
            return res;
        };
        R._engine.ellipse = function(vml, x, y, rx, ry, group) {
            var res = vml.path(undefined, group);
            res.X = x - rx;
            res.Y = y - ry;
            res.W = rx * 2;
            res.H = ry * 2;
            res.type = "ellipse";
            setFillAndStroke(res, {
                cx: x,
                cy: y,
                rx: rx,
                ry: ry
            });
            return res;
        };
        R._engine.circle = function(vml, x, y, r, group) {
            var res = vml.path(undefined, group);
            res.X = x - r;
            res.Y = y - r;
            res.W = res.H = r * 2;
            res.type = "circle";
            setFillAndStroke(res, {
                cx: x,
                cy: y,
                r: r
            });
            return res;
        };
        R._engine.image = function(vml, src, x, y, w, h, group) {
            var path = R._rectPath(x, y, w, h),
            res = vml.path(path, group).attr({
                stroke: "none"
            }),
            a = res.attrs,
            node = res.node,
            fill = node.getElementsByTagName(fillString)[0];
            a.src = src;
            res.X = a.x = x;
            res.Y = a.y = y;
            res.W = a.width = w;
            res.H = a.height = h;
            a.path = path;
            res.type = "image";
            fill.parentNode == node && node.removeChild(fill);
            fill.rotate = true;
            fill.src = src;
            fill.type = "tile";
            res._.fillpos = [x, y];
            res._.fillsize = [w, h];
            node.appendChild(fill);
            setCoords(res, 1, 1, 0, 0, 0);
            return res;
        };
        R._engine.text = function(vml, x, y, text, group) {
            var el = createNode("shape"),
            path = createNode("path"),
            o = createNode("textpath");
            x = x || 0;
            y = y || 0;
            text = text;
            path.v = R.format("m{0},{1}l{2},{1}", round(x * zoom), round(y * zoom), round(x * zoom) + 1);
            path.textpathok = true;
            o.string = Str(text).replace(/<br\s*?\/?>/ig, '\n');
            o.on = true;
            el.style.cssText = cssDot;
            el.coordsize = zoom + S + zoom;
            el.coordorigin = "0 0";
            var p = new Element(el, vml, group),
            attr = {
                fill: "#000",
                stroke: "none",
                text: text
            };

            p.shape = el;
            p.path = path;
            p.textpath = o;
            p.type = "text";
            p.attrs.text = Str(text || E);
            p.attrs.x = x;
            p.attrs.y = y;
            p.attrs.w = 1;
            p.attrs.h = 1;
            setFillAndStroke(p, attr);
            el.appendChild(o);
            el.appendChild(path);
            (group || vml).canvas.appendChild(el);

            var skew = createNode("skew");
            skew.on = true;
            el.appendChild(skew);
            p.skew = skew;
            return p;
        };

        R._engine.setSize = function(width, height) {
            var cs = this.canvas.style;
            this.width = width;
            this.height = height;
            width == +width && (width += "px");
            height == +height && (height += "px");
            cs.width = width;
            cs.height = height;
            cs.clip = "rect(0 " + width + " " + height + " 0)";
            if (this._viewBox) {
                R._engine.setViewBox.apply(this, this._viewBox);
            }
            return this;
        };
        R._engine.setViewBox = function(x, y, w, h, fit) {
            eve("raphael.setViewBox", this, this._viewBox, [x, y, w, h, fit]);
            var width = this.width,
            height = this.height,
            size = 1 / mmax(w / width, h / height),
            H, W;
            if (fit) {
                H = height / h;
                W = width / w;
                if (w * H < width) {
                    x -= (width - w * H) / 2 / H;
                }
                if (h * W < height) {
                    y -= (height - h * W) / 2 / W;
                }
            }
            this._viewBox = [x, y, w, h, !!fit];
            this._viewBoxShift = {
                dx: -x,
                dy: -y,
                scale: size
            };
            this.forEach(function(el) {
                el.transform("...");
            });
            return this;
        };
        var createNode;
        R._engine.initWin = function(win) {
            var doc = win.document;
            doc.createStyleSheet().addRule(".rvml", "behavior:url(#default#VML)");
            try {
                !doc.namespaces.rvml && doc.namespaces.add("rvml", "urn:schemas-microsoft-com:vml");
                createNode = R._createNode = function(tagName, attrs) {
                    var el = doc.createElement('<rvml:' + tagName + ' class="rvml">'),
                    prop;
                    for (prop in attrs) {
                        el[prop] = Str(attrs[prop]);
                    }
                    return el;
                };
            } catch (e) {
                createNode = R._createNode = function(tagName, attrs) {
                    var el = doc.createElement('<' + tagName + ' xmlns="urn:schemas-microsoft.com:vml" class="rvml">'),
                    prop;
                    for (prop in attrs) {
                        el[prop] = Str(attrs[prop]);
                    }
                    return el;
                };
            }
        };
        R._engine.initWin(R._g.win);
        R._engine.create = function() {
            var con = R._getContainer.apply(0, arguments),
            container = con.container,
            height = con.height,
            s,
            width = con.width,
            x = con.x,
            y = con.y;
            if (!container) {
                throw new Error("VML container not found.");
            }
            var res = new R._Paper,
            c = res.canvas = R._g.doc.createElement("div"),
            cs = c.style;
            x = x || 0;
            y = y || 0;
            width = width || 512;
            height = height || 342;
            res.width = width;
            res.height = height;
            width == +width && (width += "px");
            height == +height && (height += "px");
            res.coordsize = zoom * 1e3 + S + zoom * 1e3;
            res.coordorigin = "0 0";
            res.span = R._g.doc.createElement("span");
            res.span.style.cssText = "position:absolute;left:-9999em;top:-9999em;padding:0;margin:0;line-height:1;";
            c.appendChild(res.span);
            cs.cssText = R.format("top:0;left:0;width:{0};height:{1};display:inline-block;cursor:default;position:relative;clip:rect(0 {0} {1} 0);overflow:hidden", width, height);
            if (container == 1) {
                R._g.doc.body.appendChild(c);
                cs.left = x + "px";
                cs.top = y + "px";
                cs.position = "absolute";
            } else {
                if (container.firstChild) {
                    container.insertBefore(c, container.firstChild);
                } else {
                    container.appendChild(c);
                }
            }
            res.renderfix = function() {
            };
            return res;
        };
        R.prototype.clear = function() {
            eve("raphael.clear", this);
            this.canvas.innerHTML = E;
            this.span = R._g.doc.createElement("span");
            this.span.style.cssText = "position:absolute;left:-9999em;top:-9999em;padding:0;margin:0;line-height:1;display:inline;";
            this.canvas.appendChild(this.span);
            this.bottom = this.top = null;
        };
        R.prototype.remove = function() {
            eve("raphael.remove", this);
            this.canvas.parentNode.removeChild(this.canvas);
            for (var i in this) {
                this[i] = typeof this[i] == "function" ? R._removedFactory(i) : null;
            }
            return true;
        };

        var setproto = R.st;
        for (var method in elproto)
            if (elproto[has](method) && !setproto[has](method)) {
                setproto[method] = (function(methodname) {
                    return function() {
                        var arg = arguments;
                        return this.forEach(function(el) {
                            el[methodname].apply(el, arg);
                        });
                    };
                })(method);
            }
    }(window.Raphael);

    // Restore old Raphael or remove it from global scope
    lib.Raphael = RedRaphael;
    lib.Raphael.desc = 'framework ' + global.core.version.join('.');
    if (someRaphael && someRaphael !== RedRaphael) {
        window.Raphael = someRaphael;
    }
    else if (window.Raphael === RedRaphael) {
        window.Raphael = undefined;
    }

}]);/*jslint forin: true, regexp: true, todo: true, white: false, browser: true,
    sloppy: true, white: true */
/*global window: true, FusionCharts */

/**
 * Red Raphael JavaScript Library
 * ------------------------------
 * @section Extension for support of drop-shadow on elements
 */

FusionCharts(['private', 'modules.renderer.js-raphaelshadow', function () {
    var global = this,
        lib = global.hcLib,
        win = window,
        nav = win.navigator,
        userAgent = nav.userAgent,
        math = win.Math,
        mathSqrt = math.sqrt,
        mathLog = window.Math.log,
        toFloat = win.parseFloat,
        toInt = win.parseInt,

        isWebKit = /AppleWebKit/.test(userAgent),
        isSubSafari5 = /Safari/.test(userAgent) && /Version\/[1-4]\./.test(userAgent),
        isChrome = /Chrome/.test(userAgent),
        isIE = /msie/i.test(userAgent) && !win.opera,

        EMP = "", // empty string
        SPC = " ", // white-space
        NONE = "none",
        ROUND = "round",
        DEFAULT = "default",

        STROKE_OPACITY = "stroke-opacity",
        STROKE_WIDTH = "stroke-width",
        DROP_SHADOW = "drop-shadow",
        WEBKIT_SVG_SHADOW = "-webkit-svg-shadow",

        BLACK = "rgba(0,0,0,1)",

        hasSVGFilters = win.SVGFilterElement  || (win.SVGFEColorMatrixElement &&
            win.SVGFEColorMatrixElement.SVG_FECOLORMATRIX_TYPE_SATURATE === 2),

        R = lib.Raphael,
        eve = R.eve,
        math = Math,
        mathMax = math.max,
        createNode = R._createNode,
        supervisor;

    if (R.svg) {

        // Browsers that support SVG filters needs filters to not just be
        // created, but managed as well. This is done so that multiple elements
        // can share same filter definition.
        if (hasSVGFilters) {

            R.el.dropshadow = function (dx, dy, spread, color) {
                var o = this,
                    node = o.node,
                    shadow = o._.shadowFilter,
                    cache = o.paper.cacheShadows || (o.paper.cacheShadows = {}),
                    hash = DROP_SHADOW + [dx, dy, spread, color].join(SPC),
                    prop,
                    filter,
                    opacity,
                    el;

                if (dx === NONE) {
                    if (shadow) {
                        shadow.use -= 1; // dereference
                        o.node.removeAttribute("filter");

                        // In case there is no remainig reference
                        // for the shadow, we need to remove the
                        // element in use.
                        if (!shadow.use) {
                            hash = shadow.hash; // retain hash
                            for (prop in shadow) {
                                el = shadow[prop];
                                if (el.parentNode) {
                                    el.parentNode.removeChild(el);
                                }
                                delete shadow[prop];
                            }
                            // Cleanup
                            el = null;
                            delete cache[hash];
                        }
                        // Cleanup
                        shadow = null;
                        delete o._.shadowFilter;
                    }
                }
                // In case of a valid value and shadow is yet to be
                // defined then create one.
                else if (!(shadow && cache[hash] === shadow)) {
                    filter = o.paper.defs.appendChild(createNode('filter', {
                        id: R.createUUID(),
                        width: "200%",
                        height: "200%"
                    }));
                    color = R.color(color);
                    if (color.error) {
                        color = R.color(BLACK);
                    }
                    opacity = R.pick(color.opacity, 1);

                    // Create the filters that are required to give shadow
                    // effect on an element.
                    shadow = o._.shadowFilter = cache[hash] = {
                        use: 1,
                        filter: filter,
                        hash: hash,
                        offset: filter.appendChild(createNode('feOffset', {
                            result: "offOut",
                            "in": "SourceGraphic",
                            dx: toFloat(dx),
                            dy: toFloat(dy)
                        })),
                        matrix: filter.appendChild(createNode('feColorMatrix', {
                            result: "matrixOut",
                            "in": "offOut",
                            type: "matrix",
                            // remove all colors and add specified color
                            // retain original alpha channel to avoid feOffset
                            // being overridden
                            values: "0 0 0 0 " + color.r / 255 +
                                    " 0 0 0 0 " + color.g / 255 +
                                    " 0 0 0 0 " + color.b / 255 +
                                    " 0 0 0 " + opacity + " 0"
                        })),
                        blur: filter.appendChild(createNode("feGaussianBlur", {
                            result: "blurOut",
                            "in": "matrixOut",
                            stdDeviation: mathSqrt(toFloat(spread))
                        })),
                        blend: filter.appendChild(createNode("feBlend", {
                            "in": "SourceGraphic",
                            in2: "blurOut",
                            mode: "normal"
                        }))
                    };

                    node.setAttribute('filter',
                        "url('" + R._url + "#" + filter.id + "')");
                }

                return this;
            };
        }

        var forbiddenAttrs = {
            'drop-shadow': 'drop-shadow',
            'stroke': 'stroke',
            'fill': 'fill',
            'stroke-width': 'stroke-width',
            'stroke-opacity': 'stroke-opacity',
            'stroke-linecap': 'stroke-linecap',
            'shape-rendering': 'shape-rendering',
            'transform': 'transform'
        };

        supervisor = function (params, leader) {
            var o = this,
                scale = o.__shadowscale,
                del = {},
                matrix,
                key;

            for (var key in params) {
                if (forbiddenAttrs[key]) {
                    del[key] = params[key];
                    delete params[key];
                }
                switch (key) {
                    case "transform":
                        matrix = leader.matrix.clone();
                        matrix.translate(o.__shadowx, o.__shadowy);
                        o.transform(matrix.toTransformString());
                    break;
                    case STROKE_WIDTH:
                        params[key] = ((del[key] || 1) + 6 - 2 * o.__shadowlevel) * scale;
                    break;
                }
            }
            o.attr(params);
            for (var key in del) {
                params[key] = del[key];
            }

        };

        R.ca[DROP_SHADOW] = function (offX, offY, spread, color, scale, group) {
            var o = this,
                node = o.node,
                shadows = o._.shadows || (o._.shadows = []),
                opacity,
                shadow,
                offset,
                matrix,
                style,
                i;

            if (o.__shadowblocked) {
                return false;
            }
            else if (offX === NONE) {
                while (shadow = shadows.pop()) {
                    shadow.remove();
                }
            }
            else {
                color = R.color(color);
                if (color.error) {
                    color = R.color(BLACK);
                }

                if (scale instanceof Array) {
                    tScale = scale[0];
                    strScale = scale[1];
                }
                else {
                    tScale = strScale = scale;
                }

                var tScale = 1 / R.pick(tScale, 1),
                strScale = 1 / R.pick(strScale, 1);

                offX = R.pick(offX, 1) * tScale;
                offY = R.pick(offY, 1) * tScale;
                opacity = R.pick(color.opacity, 1) * 0.05;
                offset = toInt(o.attr('stroke-width') || 1, 10) + 6;
                matrix = o.matrix.clone();
                matrix.translate(offX, offY);

                for (i = 1; i <= 3; i++) {
                    shadow = (shadows[i - 1] || o.clone()
                            .follow(o, supervisor, !group && 'before')).attr({
                        'stroke': color.hex,
                        'stroke-opacity': opacity * i,
                        'stroke-width':  (offset - 2 * i) * strScale,
                        'transform': matrix.toTransformString(),
                        'stroke-linecap': 'round',
                        'shape-rendering': 'default',
                        'fill': NONE
                    });

                    shadow.__shadowlevel = i;
                    shadow.__shadowscale = strScale;
                    shadow.__shadowx = offX;
                    shadow.__shadowy = offY;
                    group && group.appendChild(shadow);

                    shadows.push(shadow);
                }

            }

            return false;
        };


       /**
        * Add or remove a shadow composition to the element.
        *
        * @param {Boolean} apply
        * @param {Number} opacity
        */
        R.el.shadow = function (apply, opacity, scale, group) {

            var useFilter;

            // allow alternative polymorphism in last two parameters
            if (scale && scale.constructor === R.el.constructor) {
                group = scale;
                scale = undefined;
            }

            // In case the parameter is provided in object style then expand it
            if (typeof apply === 'object') {
                opacity && opacity.constructor === R.el.constructor && (group = opacity);
                opacity = apply.opacity;
                scale = apply.scalefactor;
                useFilter = !!apply.useFilter;
                apply = (apply.apply === undefined) ? !!opacity : apply.apply;
            }

            // In case opacity is undefined, set it to full.
            (opacity === undefined) && (opacity = 1);

            // Check if filter based shadow needs some modification or not.
            if (this.dropshadow) {
                if (useFilter) {
                    apply && this.dropshadow(1, 1, 3, 'rgb(64,64,64)') ||
                            this.dropshadow(NONE);
                    return this;
                }
                else if (this._.shadowFilter) {
                    this.dropshadow(NONE);
                }
            }

            return this.attr(DROP_SHADOW, apply ?
                    [1, 1, 3, 'rgba(64,64,64,' + (opacity) + ')', scale, group] : NONE);

        };

    }

    // For VML based browsers, there is a single implementation across IE 6-8.
    // As such, it requires only a single implementation.
    else if (R.vml) {

        R.ca['drop-shadow'] = function (offX, offY, spread, color, scale, group) {
            var o = this,
                shadow = o._.shadow,
                style,
                filter,
                opacity;

            // do not apply shadow on shadow!
            if (o.isShadow) {
                return false;
            }

            if (offX === NONE) {
                shadow && (shadow = o._.shadow = shadow.remove());
            }
            else {
                if (!shadow) {

                    shadow = o._.shadow = o.clone();
                    // while adding to separate shadow group, we cannot mark the
                    // shadow as stalker as that would break the shadow away from
                    // shadow group and insert it before the main element.
                    group &&
                        group.appendChild(shadow.follow(o)) ||
                        shadow.follow(o, undefined, 'before');

                    shadow.attr({
                        fill: 'none',
                        'fill-opacity': 0.5,
                        'stroke-opacity': 1
                    }).isShadow = true;

                    if (shadow.attr('stroke-width') <= 0) {
                        shadow.attr('stroke-width', 1);
                    }
                }

                style = shadow.node.runtimeStyle;
                filter = style.filter.replace(/ progid:\S+Blur\([^\)]+\)/g, EMP);

                color = R.color(color);
                if (color.error) {
                    color = R.color(BLACK);
                }
                opacity = R.pick(color.opacity, 1) / 5;

                if (scale instanceof Array) {
                    tScale = scale[0];
                }
                else {
                    tScale = scale;
                }

                var tScale = 1 / R.pick(scale, 1);

                offX = R.pick(offX, 1) * tScale;
                offY = R.pick(offY, 1) * tScale;

                shadow.translate(offX, offY);
                style.filter = filter +
                    " progid:DXImageTransform.Microsoft.Blur(pixelRadius=" +
                    toFloat(spread * .4) + " makeShadow=True Color=" +
                    color.hex + " shadowOpacity='" + opacity + "');";
            }

            return false;
        };

        /**
         * Add or remove a shadow composition to the element.
         *
         * @param {Boolean} apply
         * @param {Number} opacity
         */
        R.el.shadow = function (apply, opacity, scale, group) {
            var o = this;

            // allow alternative polymorphism in last two parameters
            if (scale && scale.constructor === R.el.constructor) {
                group = scale;
                scale = undefined;
            }

            // In case the parameter is provided in object style then expand it
            if (typeof apply === 'object') {
                opacity && opacity.type === 'group' && (group = opacity);
                opacity = apply.opacity;
                scale = apply.scalefactor;
                apply = apply.apply === undefined ? !!opacity : apply.apply;
            }

            // In case opacity is undefined, set it to full.
            (opacity === undefined) && (opacity = 1);

            return o.attr(DROP_SHADOW, apply || !opacity ?
                [1, 1, 5, 'rgba(64,64,64,' + (opacity) + ')', scale, group] : NONE);

        };
    }
    else if (R.canvas) {
        R.el.shadow = function () {
            return this;
        };
    }
}]);/*jslint forin: true, regexp: true, todo: true, white: false, browser: true,
    sloppy: true, white: true */
/*global window: true, FusionCharts */

/**
 * Red Raphael JavaScript Library
 * ------------------------------
 * @section Extension for support of easy drawing of polygons using raphael
 *
 * @since 3.3
 */

FusionCharts(['private', 'modules.renderer.js-raphaelshapes', function () {
    var global = this,
        lib = global.hcLib,
        R = lib.Raphael,

        hasTouch = "createTouch" in document,

        userAgent = navigator.userAgent,
        win = window,
        isIE = /msie/i.test(userAgent) && !win.opera,

        math = Math,
        mathCos = math.cos,
        mathSin = math.sin,
        mathAbs = math.abs,
        mathPow = math.pow,
        mathAtan2 = math.atan2,
        mathMin = math.min,
        mathRound = math.round,
        mathFloor = math.floor,
        mathPI = math.PI,
        twoPI = 2 * mathPI,
        toInt = parseInt,
        toFloat = parseFloat,
        toStr = String,

        HAS = 'hasOwnProperty',
        ARRAY = 'array',
        BLANK = '',
        COMMA = ',',
        SPACE = ' ',
        NONE = 'none',
        HIDDEN = 'hidden',
        CRISP = 'crisp',
        FILL = 'fill',
        WIDTH = 'width',
        HEIGHT = 'height',
        M = 'M',
        L = 'L',
        A = 'A',
        Z = 'Z',
        FILL = 'fill',
        STROKE = 'stroke',
        PATH = 'path',
        POLYPATH = 'polypath',
        RINGPATH = 'ringpath',
        CUBEPATH = 'cubepath',
        TEXTBOUND = 'text-bound',

        FLAT = 'flat',
        TRANSPARENT = 'transparent',
        HORIZONTAL = 'horizontal',
        VERTICAL = 'vertical',
        SCROLL_RATIO = 'scroll-ratio',
        SCROLL_POSITION = 'scroll-position',
        SCROLL_ORIENTATION = 'scroll-orientation',
        SCROLL_REPAINT = 'scroll-repaint',
        SCROLL_DISPLAY_STYLE = 'scroll-display-style',
        SCROLL_DISPLAY_BUTTONS = 'scroll-display-buttons',

        EVE_SCROLLSTART = 'raphael.scroll.start.',
        EVE_SCROLLCHANGE = 'raphael.scroll.change.',
        EVE_SCROLLEND = 'raphael.scroll.end.',

        EPSILON = mathPow(2, -24),
        TRACKER_FILL = 'rgba(192,192,192,'+ (isIE ? 0.002 : 0.000001) +')', // invisible but clickable

        eve = R.eve,
        crispFixer = (R.vml && 0.5 || 0),

        createNode = R._createNode,
        setFillAndStroke = R._setFillAndStroke,
        Element = R.el.constructor;

    R.crispBound = R._cacher(function (x, y, w, h, s) {
        var at = {},
            normalizer;

        x = x || 0;
        y = y || 0;
        w = w || 0;
        h = h || 0;
        s = s || 0;
        normalizer = s % 2 / 2 + crispFixer;

        // normalize for crisp edges
        at.x = mathRound(x + normalizer) - normalizer;
        at.y = mathRound(y + normalizer) - normalizer;
        at.width = mathRound(x + w + normalizer) - normalizer - at.x;
        at.height = mathRound(y + h + normalizer) - normalizer - at.y;
        at['stroke-width'] = s;

        (at.width === 0 && w !== 0) && (at.width = 1);
        (at.height === 0 && h !== 0) && (at.height = 1);

        return at;
    }, R);

    R.el.crisp = function () {
        var o = this,
            attrs = o.attrs,
            key,
            attr = {},
            values = o.attr(['x', 'y', 'width', 'height', 'stroke-width']);

        values = R.crispBound(values.x, values.y, values.width, values.height,
            values['stroke-width']);

        for (key in values) {
            if (attrs[key] === values[key]) { // only set attribute if changed
                delete values[key];
            }
        }

        return o.attr(values);
    };

    R.fn.polypath = function () { // args: sides, cx, cy, r, angle, dip, group
        var args = arguments,
            lastArg = args.length - 1,
            group = args[lastArg],
            path;

        group && (group.constructor === R.el.constructor) ?
            (args[lastArg] = undefined) : (group = undefined);

        path = this.path(undefined, group);
        path.ca.polypath = R.fn.polypath.ca;

        (arguments.length - !!group) &&
            path.attr(POLYPATH, [args[0], args[1], args[2], args[3], args[4], args[5]]) ||
            (path.attrs.polypath = [0, 0, 0, 0, 0, 0]);
        return path;
    };

    R.fn.polypath.ca = function (sides, cx, cy, r, startAngle, dip) {

        var path,
            inangle,
            i,
            angle,
            h;

        path = [];
        sides = toInt(sides, 10) || 0;
        cx = toFloat(cx) || 0;
        cy = toFloat(cy) || 0;
        r = toFloat(r) || 0;
        startAngle = (startAngle === null || isNaN(startAngle)) ? mathPI * 0.5 : R.rad(startAngle);
        dip = (dip === null || isNaN(dip)) ? 0 : toFloat(dip);
        angle = startAngle;

        if (sides > 2) {
            inangle = 2 * mathPI / sides;

            switch(dip) {
                // polygon
                case 0:
                    for (i = 0; i < sides; i++) {
                        path.push(L,
                                    cx + r * mathCos(-angle),
                                    cy + r * mathSin(-angle)
                                  );
                        angle += inangle;
                    }
                     // we need to replace the first command to move. it was not
                     // done earlier and is done now to ease out the algorithm.
                    path[0] = M;
                    // close path at end
                    path.push(Z);
                break;

                // spoke
                case 1:
                    for (i = 0; i < sides; i++) {
                        path.push(M, cx, cy,
                                  L,
                                    cx + r * mathCos(-angle),
                                    cy + r * mathSin(-angle)
                                  );
                        angle += inangle;
                    }
                break;

                // star
                default:
                    inangle *= 0.5;
                    // R cos(alpha) here is the radial distance of midpoint of two
                    // consecutive vertices.
                    h = r * mathCos(inangle) * (1 - dip);

                    for (i = 0; i < sides; i++) {
                        path.push(L,
                                    cx + r * mathCos(-angle),
                                    cy + r * mathSin(-angle)
                                  );
                        angle += inangle;

                        path.push(L,
                                    cx + h * mathCos(-angle),
                                    cy + h * mathSin(-angle)
                                  );
                        angle += inangle;
                    }
                     // we need to replace the first command to move. it was not
                     // done earlier and is done now to ease out the algorithm.
                    path[0] = M;
                    // close path at end
                    path.push(Z);
                break;
            }
        }
        // If 'sides' is less than three then draw a circle.
        else {
            // In case r is zero, we need to avoid creating arcs so that VML
            // does not get broken due to zero-radius arcs.
            if (r === 0) {
                path.push(M, cx, cy,
                          L, cx, cy,
                          Z);
            }
            else {
                path.push(M, cx - r, cy,
                          A, r, r, 0, 0, 0, cx + r, cy,
                          A, r, r, 0, 0, 0, cx - r, cy,
                          Z);
            }
        }

        return {
            path: path
        };
    };

    R.fn.ringpath = function () { // args: x, y, r1, r2, start, end, group
        var args = arguments,
            lastArg = args.length - 1,
            group = args[lastArg],
            path;

        group && (group.constructor === R.el.constructor) ?
            (args[lastArg] = undefined) : (group = undefined);

        path = this.path(undefined, group);
        path.ca.ringpath = R.fn.ringpath.ca;

        (arguments.length - !!group) &&
            path.attr(RINGPATH, [args[0], args[1],args[2], args[3], args[4], args[5]]) ||
            (path.attrs.ringpath = [0, 0, 0, 0, 0, 0]);
        return path;
    };

    R.fn.ringpath.ca = function (x, y, r1, r2, start, end) {
        var o = this,
            // The angles are normalized to be in the range of - twoPI to +twoPI.
            delta = (end % twoPI) - (start % twoPI),
            deltaOrig = end - start,
            cosStart,
            sinStart,
            cosEnd,
            sinEnd,
            longshort,
            path;

        // Save the angle in private for use.
        o._.ringangle = (start + end) * 0.5;

        // For deltaOrig very close to zero, thin line drawing is required.
        if (mathAbs(deltaOrig) < EPSILON) {
            cosStart = mathCos(start);
            sinStart = mathSin(start);

            path = [
                M, x + r1 * cosStart, y + r1 * sinStart,
                L, x + r2 * cosStart, y + r2 * sinStart,
                Z
            ];
        }
        // If delta is very close to multiples of PI, requiring full
        // circle drawing.
        // When angle is twoPI split arcs are drawn to combat the full arc
        // drawing issue.
        else if (mathAbs(deltaOrig) > EPSILON && mathAbs(deltaOrig) % twoPI < EPSILON) {
            path = [
                M, x - r1, y,
                A, r1, r1, 0, 0, 0, x + r1, y,
                A, r1, r1, 0, 0, 0, x - r1, y
            ];
            // draw inner arc only if specified. this helps draw only a circle
            // when inner radius is zero.
            if (r2 !== 0) {
                path = path.concat([
                    M, x - r2, y,
                    A, r2, r2, 0, 0, 1, x + r2, y,
                    A, r2, r2, 0, 0, 1, x - r2, y
                ]);
            }
            path.push(Z);
        }
        else {
            cosStart = mathCos(start);
            sinStart = mathSin(start);
            cosEnd = mathCos(end);
            sinEnd = mathSin(end);

            delta = delta % twoPI;

            // Negative resolved value of delta indicate it to be between - twoPI
            // and zero. The value is further normalised to be in the range of zero
            // to twoPI.
            if (delta < 0) {
                delta += twoPI;
            }

            longshort = delta < mathPI ? 0 : 1;

            path = [
                M, x + r1 * cosStart, y + r1 * sinStart,
                A, r1,  r1, 0, longshort, 1, x + r1 * cosEnd, y + r1 * sinEnd,
                L, x + r2 * cosEnd, y + r2 * sinEnd
            ];
            // Draw inner arc only when inner radius is not zero. This is needed
            // to avoid zero arc related issue on Raphael's VML.
            if (r2 !== 0) {
                path.push(A, r2, r2, 0, longshort, 0, x + r2 * cosStart,
                    y + r2 * sinStart);
            }
            path.push(Z);
        }

        return {
            path: path
        };
    };

    R.fn.cubepath = function () { // args: [x, y, w, h, zw, zh]
        var paper = this,
            shapeDefaultAttrs = {
                'stroke-linejoin': 'round',
                'shape-rendering': 'precision',
                'stroke': NONE
            },
            args = arguments,
            lastArg = args.length - 1,
            group = args[lastArg],
            top,
            side,
            face;

        group && (group.constructor === R.el.constructor) ?
            (args[lastArg] = undefined) : (group = undefined);

        top = paper.path(undefined, group).attr(shapeDefaultAttrs);
        side = paper.path(undefined, group).attr(shapeDefaultAttrs);
        face = paper.path(undefined, group).attr(shapeDefaultAttrs);

        face._.cubetop = top.follow(face, undefined, 'before');
        face._.cubeside = side.follow(face, undefined, 'before');

        for (var a in R.fn.cubepath.ca) {
            face.ca[a] = R.fn.cubepath.ca[a];
        }

        return face.attr(CUBEPATH, [args[0] || 0, args[1] || 0, args[2] || 0,
            args[3] || 0, args[4] || 0, args[5] || 0]);
    };

    R.fn.cubepath.ca = {
        cubepath: function (x, y, w, h, zw, zh) {
            var o = this,
                t = o._.cubetop,
                s = o._.cubeside;

            /* The issue of pixel wide gap found between adjacent faces when input params
             * are not all intezers, is solved by adding extra portion in top and side faces.
             * The side face is extended to the left with a pixel wide rectange, whole top
             * end is cut diagonally to avoid overlapping stoke effect. Like wise, the top face
             * is extended below with a pixel height rectangle whose left end is cut diagonally for
             * the same rason as above. Motive was to keep the bounding box intact as intended.
             */
            o.attr(PATH, ["M", x + w, y, "l", 0, h, -w, 0, 0, -h, "z"]);
            t.attr(PATH, ["M", x, y, "l", 1, 1, w - 1, 0, 0, -1, zw, -zh, -w, 0, "z"]);
            s.attr(PATH, ["M", x + w -1, y + 1, "l", 0, h - 1, 1, 0, zw, -zh, 0, -h, -zw, zh]);

            return false;
        },

        'stroke-linejoin': function () {
            // We force the linejoin to always be round. Otherwise, the cube
            // edges will look horrible.
            return {
                'stroke-linejoin': 'round'
            };
        },

        'drop-shadow': function (dx, dy, spread, color) {
            var o = this,
                top  = o._.cubetop,
                side = o._.cubeside;

            // Only allow filter based shadow.
            if (o.dropshadow) {
                top.dropshadow(dx, -dy, spread, color);
                side.dropshadow(dx, -dy, spread, color);
            }

            return false;
        },

        'fill': function (color, nogradient) {
            var o = this,
                top  = o._.cubetop,
                side = o._.cubeside,
                attr = o.attr(CUBEPATH) || [0, 0, 0, 0, 0, 0],
                width = attr[2],
                height = attr[3],
                zw = attr[4],
                zh = attr[5],
                rgba;

            color = R.color(color);

            if (nogradient) {
                o.attr(FILL, color);
                top.attr(FILL, R.tintshade(color, -.78).rgba);
                side.attr(FILL, R.tintshade(color, -.65).rgba);
            }
            else {
                // Since the color has been already calculated in object form,
                // we manually recalculate the rgba here since re-sending object
                // to Raphael's tintshade can cause it to return stale result
                // from its cache.
                rgba = ('opacity' in color) ?
                    ('rgba(' + [color.r, color.g, color.b, color.opacity] + ')') :
                    ('rgb(' +[color.r, color.g, color.b] + ')');

                o.attr(FILL, [270, R.tintshade(rgba, .55).rgba,
                    R.tintshade(rgba, -.65).rgba].join('-'));
                side.attr(FILL, [270,
                    R.tintshade(rgba, -.75).rgba,
                    R.tintshade(rgba, -.35).rgba].join('-'));
                top.attr(FILL, [45 + R.deg(mathAtan2(zh, zw + width)),
                    R.tintshade(rgba, -.78).rgba,
                    R.tintshade(rgba, .22).rgba].join('-'));
                /* @note
                // This is the gradient calculation mapping that accounts for
                // the skew of the top face.
                o.attr(FILL, [285, R.tintshade(rgba, .55).rgba,
                    R.tintshade(rgba, -.65).rgba].join('-'));
                side.attr(FILL, [50 + R.deg(mathAtan2(height + zh, zw)),
                    R.tintshade(rgba, -.45).rgba,
                    R.tintshade(rgba, -.75).rgba].join('-'));
                top.attr(FILL, [R.deg(mathAtan2(zh, zw + width)),
                    R.tintshade(rgba, -.85).rgba,
                    R.tintshade(rgba, .35).rgba].join('-'));
                */
            }

            // We return false so that the attribute is not applied to the
            // composite shape's leading element (the front face.)
            return false;
        }
    };

    R.ca[TEXTBOUND] = function (fill, stroke, strokeWidth, padding, cornerRadius, dasharray) {
        var o = this,
            paper = o.paper,
            bound = o._.textbound;

        if (this.type !== 'text') {
            return;
        }

        if ((!stroke || stroke === NONE) && (!fill || fill === NONE)) {
            o._.textbound = (bound && bound.unfollow(o).remove());
            return false;
        }

        (!strokeWidth || !R.is(strokeWidth, "finite")) && (strokeWidth = 0);
        (!cornerRadius || !R.is(cornerRadius, "finite")) && (cornerRadius = 0);
        !bound && (bound = o._.textbound = paper.rect(0, 0, 0, 0, o.group)
            .follow(o, R.ca[TEXTBOUND].reposition, 'before'));

        bound.attr({
            'stroke': stroke,
            'stroke-width': strokeWidth,
            'fill': fill,
            'shape-rendering': (strokeWidth === 1) && CRISP || BLANK,
            r: cornerRadius
        });
        dasharray && bound.attr('stroke-dasharray', dasharray);

        // Call the repositioning function
        R.ca[TEXTBOUND].reposition.call(bound, o.attrs, o);
        return false;
    };

    R.ca[TEXTBOUND].reposition = function (params, leader) {
        var o = this,
            updates = {},
            attr,
            padding,
            padX,
            padY,
            bbox,
            w,
            h;

        // check visibility first
        if (params[HAS]('visibility')) {
            o.attr('visibility', params.visibility);
        }

        // filter out the attributes that affects text-bound.
        if (!(params[HAS](TEXTBOUND) || params[HAS]('x') || params[HAS]('y') ||
                params[HAS]('text') || params[HAS]('text-anchor') ||
                params[HAS]('text-align') || params[HAS]('font-size') ||
                params[HAS]('line-height') || params[HAS]('vertical-align') ||
                params[HAS]('transform'))) {
           return;
        }

        attr = leader.attrs[TEXTBOUND] || [];
        padding = toStr(attr[3] || '0').split(/\s*\,\s*/g);
        padX = toFloat(padding[0]) || 0;
        padY = R.pick(toFloat(padding[1]), padX);
        bbox = leader.getBBox();
        w = bbox.width;
        h = bbox.height;

        // In case bounding box failed to return value, we do not need to
        // change position.
        if (!isNaN(w)) {
            updates.x = bbox.x - padX;
            updates.y = bbox.y - padY;
            updates.width = w + padX * 2;
            updates.height = h + padY * 2;
        }

        o.attr(updates);
    };


    /**
     * Generate a composite collection of object to provide scrollbar
     * functionality on SVG.
     *
     * @param {number} x
     * @param {number} y
     * @param {number} w
     * @param {number} h
     * @param {boolean} horiz
     * @param {object} options
     * - showButtons:boolean
     * - displayStyleFlat:boolean
     * - scrollRatio:number
     * - scrollPosition:number
     * @param {RaphaelElement} parent
     */
    R.fn.scroller = function (x, y, w, h, horiz, options, parent) {
        var paper = this,
            o = paper.group('scroller', parent),
            attrs = o.attrs,
            scroller = o._.scroller = {},
            orientation = horiz && HORIZONTAL || VERTICAL,
            _trackAnim,
            _anchorAnimAttr = {},
            _dragstart,
            _dragaxis;

        // Create the scroller track and setup click behaviour on track region.
        scroller.track = paper.rect(o).mousedown(function (evt, x, y) {
            var orientation = attrs[SCROLL_ORIENTATION],
                pos = attrs[SCROLL_POSITION],
                dx;

            dx = (orientation === HORIZONTAL) ? (evt.layerX || evt.x) : (evt.layerY || evt.y);
            dx = (dx - scroller.anchorOffset) / scroller.trackLength;

            _trackAnim = R.animation({
                'scroll-position': dx
            }, 2000 * mathAbs(pos - dx), 'easeIn');
            o.animate(_trackAnim);

            eve(EVE_SCROLLSTART + o.id, o, pos);
        }).mouseup(function () {
            this.stop(_trackAnim);
            eve(EVE_SCROLLEND + this.id, this, attrs[SCROLL_POSITION]);
        }, o, true);

        // Create the track and anchor elements as the will always be needed!
        // Setup drag behaviour of the anchor.
        scroller.anchor = paper.rect(o).drag(function () {
            _anchorAnimAttr[SCROLL_POSITION] = _dragstart +
                arguments[_dragaxis] / scroller.trackLength;
            o.animate(_anchorAnimAttr, 0);
        }, function (_x, _y, event) {
            _dragaxis = (attrs[SCROLL_ORIENTATION] === HORIZONTAL) ? 0 : 1;
            eve(EVE_SCROLLSTART + o.id, o,
                _dragstart = attrs[SCROLL_POSITION]);
            event.stopPropagation();
        }, function () {
            eve(EVE_SCROLLEND + o.id, o,
                _dragstart = attrs[SCROLL_POSITION]);
        });

        // Add the custom functions.
        for (var a in R.fn.scroller.fn) {
            o[a] = R.fn.scroller.fn[a];
        }
        // Add the custom attributes.
        for (var a in R.fn.scroller.ca) {
            o.ca[a] = R.fn.scroller.ca[a];
        }

        // Set initial attributes to cover dependency of scroll-orientation.
        attrs[SCROLL_ORIENTATION] = orientation;
        attrs['stroke-width'] = 1;
        o.ca[SCROLL_REPAINT] = o.ca['scroll-repaint-' + orientation];

        !R.is(options, "object") && (options = {});
        return o.attr({
            ishot: true,
            'scroll-display-buttons': options.showButtons && 'arrow' || NONE,
            'scroll-display-style': options.displayStyleFlat && FLAT || '3d',
            'scroll-ratio': toFloat(options.scrollRatio) || 1,
            'scroll-position': toFloat(options.scrollPosition) || 0,
            'scroll-repaint': [x, y, w, h]
        });
    };

    R.fn.scroller.fn = {
        scroll: function (callback, scope) {
            var o = this,
                scroller = o._.scroller;
            scope = scope || o;
            scroller.callback = function () {
                return callback.apply(scope, arguments);
            };
            return o;
        }
    };

    R.fn.scroller.ca = {
        'stroke-width': function (value) {
            return false;
        },

        'drop-shadow': function (ox, oy, spread, color, s, g) {
            this._.scroller.track.attr('drop-shadow', [ox, oy, spread, color, s, g]);
            return false;
        },

        'scroll-display-style': function (value) {
            var o = this,
                attrs = o.attrs,
                currentStyle = attrs[SCROLL_DISPLAY_STYLE],
                fill = attrs.fill;

            value = {
                flat: FLAT,
                '3d': '3d',
                transparent: TRANSPARENT
            }[value] || currentStyle;

            // In case of change in value, and if already filled, re-fill.
            if (fill && value !== currentStyle) {
                attrs[SCROLL_DISPLAY_STYLE] = value;
                o.attr(FILL, fill);
            }

            return {
                'scroll-display-style': value
            };
        },

        'scroll-display-buttons': function (value) {
            var o = this,
                paper = o.paper,
                scroller = o._.scroller,
                attrs = o.attrs,
                currentDisplayButtons = attrs[SCROLL_DISPLAY_BUTTONS],
                repaint = attrs[SCROLL_REPAINT],
                _anim0, _anim1;

            // Validate the input.
            value = {
                    none: NONE,
                    arrow: 'arrow'
                }[value] || currentDisplayButtons;

            // This is a simple job! If button is needed, draw the elements and
            // if not then remove them. We first check change in this attr's
            // value. That saves us needless check whether the elements to be
            // removed exists or not.
            if (value !== currentDisplayButtons) {
                attrs[SCROLL_DISPLAY_BUTTONS] = value; // set for repaint
                if (value === NONE && scroller.start) {
                    scroller.arrowstart.remove(); delete scroller.arrowstart;
                    scroller.arrowend.remove(); delete scroller.arrowend;
                    scroller.start.remove(); delete scroller.start;
                    scroller.end.remove(); delete scroller.end;
                }
                else {
                    

                    scroller.arrowstart = paper.polypath(o);
                    scroller.arrowend = paper.polypath(o);

                    // For scroller animation on button click, we run two sets.
                    // The first animation ensures that the anchor moves 20% for
                    // interaction for botton-less touchpads.
                    // and then the second set of animation becomes cancelable
                    // by mouse up.
                    scroller.start = paper.rect(o).mousedown(function () {
                        var pos;
                        if ((pos = attrs[SCROLL_POSITION]) === 0) {
                            return;
                        }

                        o.animate({
                            'scroll-position': pos - 0.1
                        }, 100).animate((_anim0 = R.animation({
                            'scroll-position': 0
                        }, 4500 * pos, 'easeIn')));
                        eve(EVE_SCROLLSTART + o.id, o,pos);
                    }).mouseup(function (){
                        o.stop(_anim0);
                        eve(EVE_SCROLLEND + o.id, o,
                            attrs[SCROLL_POSITION]);
                    }, o, true);
                    scroller.end = paper.rect(o).mousedown(function () {
                        var pos;
                        if ((pos = attrs[SCROLL_POSITION]) === 1) {
                            return;
                        }

                        o.animate({
                            'scroll-position': pos + 0.1
                        }, 100).animate((_anim1 = R.animation({
                            'scroll-position': 1
                        }, 4500 * (1 - pos), 'easeIn')));
                        eve(EVE_SCROLLSTART + o.id, o, pos);
                    }).mouseup(function (){
                        o.stop(_anim1);
                        eve(EVE_SCROLLEND + o.id, o,
                            attrs[SCROLL_POSITION]);
                    }, o, true);
                    // if the scroller has been filled before, we need to
                    // re-fill it! Else the new elements will look odd
                    if (attrs.fill) {
                        o.attr(FILL, attrs.fill);
                    }
                }

                // Repaint on change of buttons
                if (repaint) {
                    o.attr(SCROLL_REPAINT, repaint);
                }
            }

            return {
                'scroll-display-buttons': value
            };
        },

        'scroll-orientation': function (value) {
            var o = this,
                attrs = o.attrs,
                repaint = attrs[SCROLL_REPAINT],
                currentOrientation = attrs[SCROLL_ORIENTATION];

            value = {
                horizontal: HORIZONTAL,
                vertical: VERTICAL
            }[value] || currentOrientation;

            // Register change in orientation and redraw.
            if (currentOrientation !== value) {
                o.ca[SCROLL_REPAINT] = o.ca['scroll-repaint-' + value];
                if (repaint) {
                    repaint[2] = repaint[2] + repaint[3];
                    repaint[3] = repaint[2] - repaint[3];
                    repaint[2] = repaint[2] - repaint[3];
                    o.attr(SCROLL_REPAINT, repaint);
                }
                // if the scroller has been filled before, we need to
                // re-fill it! Else the new elements will look odd
                if (attrs.fill) {
                    o.attr(FILL, attrs.fill);
                }
            }

            return {
                'scroll-orientation': value
            };
        },

        'scroll-ratio': function (value) {
            var o = this,
                attrs = o.attrs,
                currentRatio = attrs[SCROLL_RATIO],
                repaint = attrs[SCROLL_REPAINT],
                horiz = (attrs[SCROLL_ORIENTATION] === HORIZONTAL),
                scroller = o._.scroller,
                anchor = scroller.anchor,
                wOrh = horiz ? WIDTH : HEIGHT,
                anchorWidth;

            // We validate the scroll-position value. Restricting it strictly
            // between 0 and 1. But not exactly 0 as that would mean zero
            // dimension anchor!
            

            value = value > 1 ? 1 : (value < 0.01 ? 0.01 : toFloat(value));

            // On change of ratio on a painted scroller, we need to resize
            // and reposition the anchor. Thankfully, the calculation of the
            // new anchor dimension is fairly simple when we take the scroller's
            // total dimension as reference.
            if (repaint && value !== currentRatio) {
                attrs[SCROLL_RATIO] = value;
                // Note that the anchor is padded by half a pixel, as such,
                // the calculation is done accordingly.
                

                //anchor.attr(wOrh, value * (anchorWidth + 1) / currentRatio - 1);
                // since position percentage remains same, we need to set the
                // "force" flag of positioning to true.
                o.attr(SCROLL_REPAINT, repaint);
            }

            return {
                'scroll-ratio': value
            };
        },

        'scroll-position': function (value, _force) {
            var o = this,
                attrs = o.attrs,
                horiz = (attrs[SCROLL_ORIENTATION] === HORIZONTAL),
                repaint = attrs[SCROLL_REPAINT],
                currentPosition = attrs[SCROLL_POSITION],
                scroller =  o._.scroller,
                anchor = scroller.anchor,
                button;

            // Positionhas to be validated between 0 and 1, else anchor will
            // spill out of area!
            value = value > 1 ? 1 : (value < 0 ? 0 : toFloat(value));
            isNaN(value) && (value = currentPosition);

            // On change of value, we recalculate the anchor dimension (width or
            // height based on directionality) from the painted originals.
            // Buttons' presence has to be accounted for.
            // We can avoid complicated ratio calculation by retrieving the
            // already calculated result from the anchor dimension.
            if (repaint && (currentPosition !== value || _force)) {
                button = scroller.start &&
                    scroller.start.attr(horiz && WIDTH || HEIGHT) || 0;
                horiz &&
                    anchor.attr('x', repaint[0] + button +
                        (repaint[2] - 2 * button - anchor.attr(WIDTH)) * value + 0.5) ||
                    anchor.attr('y', repaint[1] + button +
                        (repaint[3] - 2 * button - anchor.attr(HEIGHT)) * value + 0.5);

                // Raise event and execute callback on position change.
                if (!_force && attrs[SCROLL_RATIO] < 1) {
                    eve(EVE_SCROLLCHANGE + o.id, o, value);
                    scroller.callback && scroller.callback(value);
                }
            }

            return {
                'scroll-position': value
            };
        },

        r: function (value) {
            var o = this,
                scroller = o._.scroller;

            scroller.track.attr('r', value);
            scroller.anchor.attr('r', (o.attrs[SCROLL_DISPLAY_BUTTONS] === NONE) &&
                    value || 0);

            return false;
        },

        'scroll-repaint-horizontal': function (x, y, w, h) {
            var o = this,
                attrs = o.attrs,
                scroller = o._.scroller,
                ratio = attrs[SCROLL_RATIO],
                position = attrs[SCROLL_POSITION],
                button = 0,
                track = w * ratio,
                nobutton = attrs[SCROLL_DISPLAY_BUTTONS] === NONE;

            w && (w -= 1);
            x && (x += 0.5);
            h && (h -= 1);
            y && (y += 0.5);

            // The track forms the base of the scroller and as such, occupies
            // entire space.
            scroller.track.attr({
                width: w,
                height: h,
                y: y,
                x: x
            }).crisp();

            // Draw buttons if needed and also perform calculations that the
            // presence of button will affect anchor.
            if (!nobutton) {
                button = mathMin(h, w * 0.5);
                track -= button * 2 * ratio;

                scroller.start.attr({
                    width: button,
                    height: h,
                    x: x,
                    y: y
                });
                scroller.arrowstart.attr(POLYPATH,
                    [3, x + button * 0.5, y + h * 0.5, button * 0.25, 180]);
                scroller.end.attr({
                    width: button,
                    height: h,
                    x: x + w - button,
                    y: y
                });
                scroller.arrowend.attr(POLYPATH,
                    [3, x + w - button * 0.5, y + button * 0.5, button * 0.25, 0]);
            }

            // The anchor position is calculated in full (ratio included).
            // This saves needless function/attr call.
            scroller.trackLength = w - 2 * button - track;
            scroller.trackOffset = x + button + 0.5;
            scroller.anchorOffset = scroller.trackOffset + (track - 1) * 0.5;
            scroller.anchor.attr({
                height: h,
                width: track - 1,
                y: y,
                x: scroller.trackOffset + scroller.trackLength * position
            }).crisp();
        },

        'scroll-repaint-vertical': function (x, y, w, h) {
            var o = this,
                attrs = o.attrs,
                scroller = o._.scroller,
                ratio = attrs[SCROLL_RATIO],
                position = attrs[SCROLL_POSITION],
                button = 0,
                track = h * ratio,
                nobutton = attrs[SCROLL_DISPLAY_BUTTONS] === NONE;

            w && (w -= 1);
            x && (x += 0.5);
            h && (h -= 1);
            y && (y += 0.5);

            // The track forms the base of the scroller and as such, occupies
            // entire space.
            scroller.track.attr({
                width: w,
                height: h,
                y: y,
                x: x
            }).crisp();

            // Draw buttons if needed and also perform calculations that the
            // presence of button will affect anchor.
            if (!nobutton) {
                button = mathMin(w, h * 0.5);
                track -= button * 2 * ratio;
                scroller.start.attr({
                    width: w,
                    height: button,
                    x: x,
                    y: y
                });
                scroller.arrowstart.attr(POLYPATH,
                    [3, x + w * 0.5, y + button * 0.5, button * 0.25, 90])
                scroller.end.attr({
                    width: w,
                    height: button,
                    x: x,
                    y: y + h - button
                });
                scroller.arrowend.attr(POLYPATH,
                    [3, x + w * 0.5, y + h - button * 0.5, button * 0.25, -90]);
            }

            // The anchor position is calculated in full (ratio included).
            // This saves needless function/attr call.
            scroller.trackLength = h - 2 * button - track;
            scroller.trackOffset = y + button + 0.5;
            scroller.anchorOffset = scroller.trackOffset + (track - 1) * 0.5;
            scroller.anchor.attr({
                height: track - 1,
                width: w,
                y: scroller.trackOffset + scroller.trackLength * position,
                x: x
            }).crisp();
        },

        fill: function (color) {
            var o = this,
                attrs = o.attrs,
                scroller = o._.scroller,
                repaint = attrs[SCROLL_REPAINT],
                flat = (attrs[SCROLL_DISPLAY_STYLE] === FLAT),
                horiz = (attrs[SCROLL_ORIENTATION] === HORIZONTAL),
                setter = { // will use single obj as setter (save mem)
                    stroke: NONE
                },
                strokeCompensation;

            // For touch devices, we increase accessibility by adding an
            // increased area of transparent stroke
            if (hasTouch && repaint &&
                    (strokeCompensation = 16 - repaint[horiz && 3 || 2]) > 3) {
                setter.stroke = TRACKER_FILL;
                setter['stroke-width'] = strokeCompensation;
            }

            // Parse color. Pass it via tintshade to get standard rgba text
            color = R.color(color);
            color.error && (color = '#000000');
            color = ('opacity' in color) ?
                    ('rgba(' + [color.r, color.g, color.b, color.opacity] + ')') :
                    ('rgb(' +[color.r, color.g, color.b] + ')');

            // Individually calculate the fill gradients of various elements
            // using tint/shade of the base color and set it on the scroller
            // elements.
            // Note that we multiply gradient angle with boolean. Neat trick to
            // set them zero when boolean is false.
            setter.fill = flat && color || [90 * horiz,
                R.tintshade(color, .15).rgba, color].join('-');
            setter.stroke = R.tintshade(color, -.75).rgba;
            scroller.track.attr(setter);

            setter.fill = flat && R.tintshade(color, -.6).rgba || [270 * horiz,
                R.tintshade(color, .3).rgba + ":40",
                R.tintshade(color, -.7).rgba].join('-');
            setter.stroke = R.tintshade(color, -.6).rgba;
            scroller.anchor.attr(setter);
            // reset stroke
            setter.stroke = NONE;

            // Now, if buttons are available, we fill the tracker and the
            // arrows.
            if (attrs[SCROLL_DISPLAY_BUTTONS] !== NONE) {
                setter.fill = TRACKER_FILL;
                scroller.start.attr(setter);
                scroller.end.attr(setter);

                setter.fill = R.tintshade(color, -.4).rgba;
                scroller.arrowstart.attr(setter);
                scroller.arrowend.attr(setter);
            }

            // return false to prevent default.
            return false;
        }
    };

    var arraySlice = Array.prototype.slice;
    R.fn.symbol = function () {// name, x, y, (r || w , h)
        var paper = this,
            args = arguments,
            lastArg = args.length - 1,
            group = args[lastArg],
            o;

        group && (group.constructor === R.el.constructor) ?
            (args[lastArg] = undefined) : (group = undefined);

        o = paper.path(undefined, group);
        o.ca.symbol = R.fn.symbol.ca.symbol;
        return (args.length === !!group+0) ? o : o.attr('symbol', args);
    };

    R.fn.symbol.cache = {
        '': R._cacher(function (x, y, r, h) {
                return (arguments.length > 3) ?
                    ["M", x, y, "h", r, "v", h, "h", -r, "v", -h, "z"] :
                        ["M", x - r, y - r,
                            "h", r *= 2, "v", r, "h", -r, "v", -r, "z"];
        })
    };
    R.fn.symbol.ca = {
        symbol: function (name) {
            var o = this,
                args = R.is(name, 'object') && (arguments.length === 1) &&
                    !R.is(name, 'function') ? name : arguments,
                symbolFn,
                symbolData;

            (args === name) && (name = args[0]);

            symbolFn = R.is(name, "function") && name ||
                R.fn.symbol.cache[name] || R.fn.symbol.cache[''];
            symbolData = symbolFn && symbolFn.apply(R, arraySlice.call(args, 1));

            (R.is(symbolData, "array") || R.is(symbolData, "string")) ?
                o.attr('path', symbolData) :
                    (symbolData && o.attr(symbolData));
        }
    };

    R.addSymbol = function (name, fn) {

        var items = R.is(fn, "function") &&
                (items = {}, (items[name] = fn), items) || name,
            cache = R.fn.symbol.cache,
            alias = [],
            i;

        for (i in items) {
            fn = items[i];
            cache[i] = R.is(fn, "function") && R._cacher(fn, R) ||
                (alias.push(i), fn);
        }
        while (i = alias.pop()) {
            cache[i] = cache[cache[i]];
        }
    };

    /**
     * Renders a Raphael composite button element.
     *
     * @param {number} x
     * @param {number} y
     * @param {string} labelText
     * @param {string} symbolName
     * @param {object} options
     * Supports the following option attributes during construction
     * - symbolPadding
     * - horizontalPadding
     * - verticalPadding
     * - width
     * - height
     * - r
     * - symbolPosition,
     * - symbolPadding
     * - disabled
     * @param {RaphaelElement} parent
     */
    R.fn.button = function (x, y, labelText, symbolName, options, parent) {
        var paper = this,
            o = paper.group('button', parent),
            button = o._.button = {
                bound: paper.rect(o),
                tracker: paper.rect(o).attr({
                    fill: TRACKER_FILL,
                    stroke: TRACKER_FILL,
                    cursor: 'pointer'
                }).data('compositeButton', o)
            },
            a;

        !R.is(options, 'object') && (options = {});
        for (a in R.fn.button.fn) {
            o[a] = R.fn.button.fn[a];
        }
        for (a in R.fn.button.ca) {
            o.ca[a] = R.fn.button.ca[a];
        }

        return o.attr({
            ishot: true,
            'button-padding': [options.horizontalPadding, options.verticalPadding],
            'button-label': labelText,
            'button-symbol': symbolName,
            'button-disabled': options.disabled,
            'button-symbol-position': options.symbolPosition,
            'button-symbol-padding': options.symbolPadding
        }).attr('button-repaint', [x, y, options.width, options.height, options.r]);
    };

    R.fn.button.e = {
        hoverin: function () {
            var o = this,
                button = o._.button,
                callback = button.hoverbackIn;
            (callback && (callback() === false)) ||
                (o.attr('fill', 'hover').hovered = true);
        },
        hoverout: function () {
            var o = this,
                button = o._.button,
                callback = button.hoverbackOut;
            (callback && (callback() === false)) ||
                (o.attr('fill', (o.pressed || o.active) && 'active' || 'normal').hovered = false);
        },
        mousedown: function () {
            var o = this;
            o.attr('fill', 'active').pressed = true;
        },
        mouseup: function () {
            var o = this,
                button = o._.button,
                callback = button.callback;
            o.attr('fill', o.hovered && 'hover' || o.active && 'active' || 'normal').pressed = false;
            callback();
        }
    };
    R.fn.button.fn = {
        buttonclick: function (callback, scope) {
            var o = this,
                button = o._.button;
            scope = scope || o;
            button.callback = function () {
                return callback.apply(scope, arguments);
            };
            return o;
        },

        labelcss: function () {
            var button = this._.button,
                label = button.label;
            button.cssArg = arguments;
            label && label.css.apply(label, arguments);
            return this;
        },

        buttonhover: function (callbackIn, callbackOut, scopeIn, scopeOut) {
            var o = this,
                button = o._.button;
            scopeIn = scopeIn || o;
            scopeOut = scopeOut || o;
            button.hoverbackIn = function () {
                return callbackIn.apply(scopeIn, arguments);
            };
            button.hoverbackOut = function () {
                return callbackOut.apply(scopeOut, arguments);
            };
            return o;
        }
    };

    R.fn.button.ca = {
        'button-active': function (value) {
            var o = this;
            o.attr('fill', (o.active = !!value) ?
                'active' : (o.hovered && 'hover' || 'normal'));
        },

        'button-disabled': function (value) {
            var o = this,
                paper = o.paper,
                button = o._.button,
                tracker = button.tracker,
                events = paper.button.e;

            value = toStr(value);
            if (value === 'disabled' || value === 'true' || value === '1') {
                tracker.attr('fill', 'rgba(204,204,205,.5)')
                    .unmousedown(events.mousedown).unmouseup(events.mouseup)
                    .unhover(paper.button.e.hoverin, paper.button.e.hoverout);
            }
            else {
                tracker.attr('fill', TRACKER_FILL)
                    .mousedown(events.mousedown, o).mouseup(events.mouseup, o, true)
                    .hover(paper.button.e.hoverin, paper.button.e.hoverout, o, o);
            }
        },

        'button-label': function (text) {
            var o = this,
                button = o._.button,
                attrs = o.attrs,
                label = button.label,
                cssArg = button.cssArg,
                repaint = o.attrs['button-repaint'];

            text = toStr(text || BLANK);

            if (text === NONE) {
                label && (button.label = label.remove());
            }
            else if (text) {
                !label && (label = button.label = o.paper.text(o)
                    .insertBefore(button.tracker));
                label.attr({
                    text: text,
                    'text-anchor': 'start',
                    'vertical-align': 'top'
                });
                cssArg && cssArg.length && label.css.apply(label, cssArg)
            }

            if (repaint && attrs['button-label'] !== text) {
                o.attr('button-repaint', repaint);
            }
        },

        'button-symbol': function (name) {
            var o = this,
                attrs = o.attrs,
                button = o._.button,
                symbol = button.symbol,
                repaint = o.attrs['button-repaint'];

            name = toStr(name || BLANK);

            if (name === NONE) {
                symbol && (button.symbol = symbol.remove());
            }
            else if (name && !symbol) {
                symbol = button.symbol = o.paper.symbol(o)
                    .insertAfter(button.bound);
            }

            if (repaint && attrs['button-symbol'] !== name) {
                o.attr('button-repaint', repaint);
            }
        },

        'button-symbol-position': function (position) {
            return {
                'button-symbol-position': {
                    top: 'top',
                    right: 'right',
                    bottom: 'bottom',
                    left: 'left',
                    none: 'none'
                }[toStr(position).toLowerCase()] || NONE
            };
        },

        'button-symbol-padding': function (value) {
            return {
                'button-symbol-padding': toFloat(value)
            };
        },

        'button-padding': function (px, py) {
            return {
                'button-padding': [(px == null) && (px = 5) || toFloat(px),
                    (py == null) && px || toFloat(py)]
            };
        },

        'button-repaint': function (x, y, w, h, r) {
            var o = this,
                button = o._.button,
                bound = button.bound,
                label = button.label,
                symbol = button.symbol,
                attrs = o.attrs,
                attrPads = attrs['button-padding'],
                padX = attrPads[0],
                padY = attrPads[1],
                symX,
                symY,
                symR,
                padSym,
                bbox,
                obj;

            // In case a specific coord is not provided, set them to zero.
            (x == undefined) && (x = 0);
            (y == undefined) && (y = 0);

            if (w == undefined || h == undefined) {
                bbox = label && label.getBBox() || { width: 0, height: 0 };
                w == undefined && (w = padX * 2 + bbox.width);
                h == undefined && (h = padY * 2 + bbox.height);
            }

            obj = R.crispBound(x, y, w, h, bound.attr('stroke-width'));
            obj.r = r = R.pick(r, mathRound(mathMin(h, w) * 0.1));
            x = obj.x;
            y = obj.y;
            w = obj.width;
            h = obj.height;

            label && label.attr({
                x: x + padX,
                y: y + padY
            });

            if (symbol) {
                // auto alculate symbol radius
                !R.is((padSym = attrs['button-symbol-padding']), "finite") &&
                    (padSym = h * 0.2);
                symR = (h - padY) * 0.5;

                switch (attrs['button-symbol-position'] + (label && '+' || '-')) {
                    case 'right+':
                        w += symR * 2 + padY;
                        symX = x + w - symR - padX;
                        symY = y + h * 0.5;
                    break;
                    case 'left+':
                        w += symR * 2 + padY;
                        symX = x + padX + symR;
                        symY = y + h * 0.5;
                        label.attr('x', symX + symR + padSym)
                    break;
                    case 'top+':
                        h += symR * 2 + padSym;
                        symX = x + w * 0.5;
                        symY = y + attrPads[1] + symR;
                        label && label.attr('y', symY + symR + padSym)
                    break;
                    case 'bottom+':
                        h += symR * 2 + padSym;
                        symX = x + w * 0.5;
                        symY = y + h - padY - symR;
                    break;
                    default: // none
                        symX = (x + w * 0.5);
                        symY = (y + h * 0.5);
                }
                symbol.attr('symbol', [attrs['button-symbol'], symX, symY, symR]);
            }

            button.bound.attr(obj);
            button.tracker.attr(obj);
        },

        fill: function (color, labelFill, symbolFill, hover) {

            var o = this,
                button = o._.button,
                bound = button.bound,
                symbol = button.symbol,
                label = button.label,
                state = {
                    normal: button.gradient,
                    active: button.gradientActive,
                    hover: button.gradientHover
                }[color];

            if (!state) {
                color = R.getRGB(color);
                color.error && (color = R.color('#cccccc'));
                color = ('opacity' in color) ?
                    ('rgba(' + [color.r, color.g, color.b, color.opacity] + ')') :
                    ('rgb(' +[color.r, color.g, color.b] + ')');

                button.gradient = [90,
                    R.tintshade(color, -.8).rgba + ':0',
                    R.tintshade(color, .8).rgba + ':100'].join('-'),
                button.gradientActive = [270,
                    R.tintshade(color, -.8).rgba + ':0',
                    R.tintshade(color, .8).rgba + ':100'].join('-');

                hover = R.getRGB(hover);
                hover.error && (hover = color) ||
                    (hover = ('opacity' in hover) ?
                        ('rgba(' + [hover.r, hover.g, hover.b, hover.opacity] + ')') :
                        ('rgb(' +[hover.r, hover.g, hover.b] + ')'));

                button.gradientHover = [90,
                    R.tintshade(hover, -.9).rgba + ':0',
                    R.tintshade(hover, .7).rgba + ':100'].join('-'),

                symbolFill = symbolFill || R.tintshade(color, 0.2).rgba;
                labelFill = labelFill || R.tintshade(color, -0.2).rgba;

                button.symbolFill = symbolFill;
                button.labelFill = labelFill;

                state = ((o.pressed || o.active) && button.gradientActive) ||
                        (o.hovered && button.gradienthover) || button.gradient;
            }

            bound.attr('fill', state);
            symbol && symbol.attr('fill', button.symbolFill);
            label && label.attr('fill', button.labelFill);
            return false;
        },

        stroke: function (color, forSymbol) {
            var button = this._.button,
                symbol = button.symbol;

            color = R.color(color);
            color.error && (color = R.color('#999999'));

            button.bound.attr('stroke', color);
            symbol && symbol.attr('stroke', forSymbol || color);

            return false;
        },

        'stroke-width': function (value, forSymbol) {
            var button = this._.button,
                symbol = button.symbol;

            button.bound.attr('stroke-width', value);
            button.tracker.attr('stroke-width', value);
            symbol && symbol.attr('stroke-width', forSymbol);

            return false;
        }
    };

/** ***************************************************************************
 * @section
 * High performance path rendering extension for Red Raphael.
 *
 ** ***************************************************************************/

    var LITEPATH = 'litepath',
        CSSFLOOD = "position:absolute;left:0;top:0;width:21600px;height:21600px;",
        COORD21600 = "21600 21600",

        s2vcmd = {
            'Q': 'L',
            'Z': 'X',
            'q': 'l',
            'z': 'x',
            ',': ' '
        },
        p2s = /,?([achlmqrstvxz]),?/gi,
        p2srep,
        path2string = function() {
            return this.join(COMMA).replace(p2s, p2srep);
        },

        litepathsetter,
        vmlTransformHelper;


    if (R.svg) {
        p2srep = "$1";

        litepathsetter = function (path) {
            var o = this;

            if (!path) {
                path = 'M0,0';
            }
            else if (typeof path === 'string') {
                path = path.replace(p2s, p2srep);
            }
            else {
                path.toString = path2string;
            }

            o.node.setAttribute('d', path.toString());
            return o;
        };

        R._engine.litepath = function(path, svg, zoom, group) {

            var el = createNode("path");

            (group || svg).canvas.appendChild(el);

            var p = new Element(el, svg, group);
            p.type = LITEPATH;

            setFillAndStroke(p, {
                fill: NONE,
                stroke: "#000"
            });

            return p;
        };

        R._getPath.litepath = function (el) {
            return R.parsePathString(el.node.getAttribute('d'));
        };
    }
    else if (R.vml) {
        p2srep = function (cmd, $1) {
            return (s2vcmd[$1] || $1);
        };

        vmlTransformHelper = function () {
            var o = this;
            o._transform.apply(o, arguments);
            o._.bcoord && (o.node.coordsize = o._.bcoord);
            return o;
        };


        litepathsetter = function (path) {
            var o = this;

            if (!path) {
                path = 'M0,0';
            }
            else if (typeof path === 'string') {
                path = path.replace(p2s, p2srep);
            }
            else {
                path.toString = path2string;
            }

            o.node.path = path;
            return o;
        };

        R._engine.litepath = function(pathString, vml, zoom, group) {
            var el = createNode("shape"),
                s = el.style,
                p = new Element(el, vml, group),
                attr = {
                    fill: NONE,
                    stroke: "#000"
                };

            s.cssText = CSSFLOOD;
            zoom = toFloat(zoom);
            if (isNaN(zoom)) {
                el.coordsize = COORD21600;
            }
            else {
                p._.bzoom = zoom;
                s.width = "1px";
                s.height = "1px";
                el.coordsize = p._.bcoord = zoom + SPACE + zoom;
            }
            el.coordorigin = vml.coordorigin;

            p.type = LITEPATH;
            p._transform = p.transform;
            p.transform = vmlTransformHelper;

            R._setFillAndStroke(p, attr);
            (group || vml).canvas.appendChild(el);

            var skew = createNode("skew");
            skew.on = true;
            el.appendChild(skew);
            p.skew = skew;
            return p;
        };

        R._getPath.litepath = function (el) {
            return R.parsePathString(el.node.path || BLANK);
        };
    }

    // pathString
    R.fn[LITEPATH] = function(path, zoom, group) {
        var out,
            s;

        if (zoom && zoom.constructor === Element) {
            group = zoom;
            zoom = undefined;
        }
        if (path && path.constructor === Element) {
            group = path;
            path = BLANK;
        }

        // create element and update the custom attribute.
        out = R._engine[LITEPATH](path, this, zoom, group);
        out.ca[LITEPATH] = litepathsetter;

        path && out.attr(LITEPATH, R.is(path, ARRAY) ? [path] : path);

        this.__set__ && this.__set__.push(out);
        return out;
    };


}]);/*jslint forin: true, regexp: true, todo: true, white: false, browser: true,
 sloppy: true, white: true */
/*global window: true, FusionCharts */

/**
 * Red Raphael JavaScript Library
 * ------------------------------
 * @section Extension for support of export feature of paper
 * @since 3.3
 */
'use strict';
FusionCharts(['private', 'modules.renderer.js-raphaelexport', function() {
        var global = this,
                lib = global.hcLib,
                R = lib.Raphael,
                pluckNumber = lib.pluckNumber,
                pluck = lib.pluck,
                availableAttrs = R._availableAttrs,

                NONE = 'none',
                BLANK = '',
                SPACE = ' ',
                UNDERSCORE = "_",
                COLON = ':',
                SCOLONSPACE = '; ',
                EQUALQUOT = '="',
                QUOT = '"',
                QUOTSPACE = QUOT + SPACE,
                LT = '<',
                GT = '>',
                NODESTRPART5 = '</',
                XLINK = ' xlink:href="',
                IMGNODE = 'image',
                TXTNODE = 'text',
                GRADIENT = 'gradient',
                RECT = 'rect',
                ASPRATIO = ' preserveAspectRatio="none"',
                NODESTRPART2 = ' transform="matrix(',
                NODESTRPART3 = ')" style="',
                VALIGNSTR = 'vertical-align',
                TEXTANCHOR = 'text-anchor',
                DEFANCHOR = ' text-anchor="middle"',
                MIDDLE = 'middle',
                TOP = 'top',
                BOTTOM = 'bottom',
                FONTSIZE = 'font-size',
                FONT = 'font',
                LINEHEIGHT = 'line-height',
                FONTFAMILY = 'font-family',
                FONTWEIGHT = 'font-weight',
                CURSOR = 'cursor:',
                TSPANSTR1 = '<tspan ',
                TSPANSTR2 = 'dy="',
                TSPANSTR3 = '" x="',
                TSPANSTR4 = 'dy="',
                RX = 'rx',
                RY = 'ry',
                TSPANSTR6 = '</tspan>',
                PXSPACE = 'px; ',
                CLIPRECT = 'clip-rect',
                CLIPSTR1 = '<clipPath id="',
                CLIPSTR2 = '"><rect x="',
                CLIPSTR3 = '" y="',
                CLIPSTR4 = '" width="',
                CLIPSTR5 = '" height="',
                CLIPSTR6 = '"/></clipPath>',
                CLIPSTR7 = ' clip-path="url(#',
                CLIPSTR8 = QUOT + NODESTRPART2,
                URLCLOSE = '\')"',
                BRACKETCLOSE = ')',
                DTAG = ' d="',
                FILLSTR1 = 'fill:',
                FILLSTR2 = ' fill="',
                FILLSTR3 = ' fill="url(\'#',
                FILLSTR4 = ' fill-opacity="',
                STROKE1 = ' stroke="',
                STROKE2 = ' stroke-opacity="',
                STROKEOPAC = 'stroke-opacity',
                LINEAR = "linear",
                RADIAL = "radial",
                RGRADIENTSTR1 = '<radialGradient fx = "',
                RGRADIENTSTR3 = '</radialGradient>',
                RGRADIENTSTR2 = '" fy = "',
                ID = '" id = "',
                RGRADIENTSTR4 = '">',
                LGRADIENTSTR6 = '</linearGradient>',
                LGRADIENTSTR5 = '" gradientTransform ="matrix(',
                LGRADIENTSTR1 = '<linearGradient x1 = "',
                LGRADIENTSTR2 = '" y1 = "',
                LGRADIENTSTR3 = '" x2 = "',
                LGRADIENTSTR4 = '" y2 = "',
                STOPSTR1 = '<stop',
                STOPSTR2 = ' offset="',
                STOPSTR3 = '" stop-color="',
                STOPSTR4 = '" stop-opacity="',
                STOPSTR5 = '" />',
                COLORWHITE = '#fff',
                PERCENT100 = '100%',
                PERCENT0 = '0%',
                DEFMATRIX = '1,0,0,1,0,0',
                //frequently used reg-exp
                matrixSanitizerReg = /^matrix\(|\)$/g,
                commaSanitizerReg = /\,/g,
                textNewLineReg = /\n|<br\s*?\/?>/ig,
                retriveNumReg = /[^\d\.]/ig,
                idSanitizerReg = /[\(\)\s,\xb0#]/g,
                grouptagtestReg = /group/ig,
                ampregex = /&/g,
                quot1regex = /"/g,
                quot2regex = /'/g,
                ltregex = /</g,
                gtregex = />/g,
                ampSTR = '&amp;',
                quot1STR = '&quot;',
                quot2STR = '&#39;',
                ltSTR = '&lt;',
                gtSTR = '&gt;',
                ID_Counter = 0;

        //raphael toSvg methode
        //Wrapper function
        (function(R) {
            var math = Math,
                    toFloat = parseFloat,
                    round = math.round,
                    mmax = math.max,
                    mmin = math.min,
                    abs = math.abs,
                    pow = math.pow,
                    Str = String,
                    separator = /[, ]+/,
                    regStore = [
                {//clean all prefis and add xlink
                    reg: /xmlns\=\"http\:\/\/www.w3.org\/2000\/svg\"/ig,
                    repStr: ''
                },
                {//clean all prefis and add xlink
                    reg: /^.*<svg /,
                    repStr: '<svg xmlns:xlink="http://www.w3.org/1999/xlink" xmlns="http://www.w3.org/2000/svg" '
                },
                {//clean all suffix
                    reg: /\/svg>.*$/,
                    repStr: '/svg>'
                },
                {//remove desc tag
                    reg: /\<desc\>[^\<]*\<\/desc\>/,
                    repStr: BLANK
                },
                {//clean all extra attributes
                    

                    reg: /zIndex="[^"]+"/g,
                    repStr: BLANK
                },
                {//Patched for iOS bug : #FCXT-28
                    reg: /url\((\\?[\'\"])[^#]+#/g,
                    repStr: 'url($1#'
                },
                {//sanitize href
                    reg: / href=/g,
                    repStr: ' xlink:href='
                }, //following are IE specific
                {//quote the attribute value
                    reg: /(id|class|width|height)=([^" >]+)/g,
                    repStr: '$1="$2"'
                },
                {//sanitize element tag
                    reg: /:(path|rect)/g,
                    repStr: '$1'
                },
                {//sanitize image/img tag
                    reg: /\<ima?ge? ([^\>]+?)[^\/]\>/gi,
                    repStr: '<image $1 />'
                },
                {//remove closing image/img tag
                    reg: /\<\/ima?ge?\>/g,
                    repStr: BLANK
                },
                {// closes image tags for firefox
                    reg: /style="([^"]+)"/g,
                    repStr: function(s) {
                        return s.toLowerCase();
                    }
                }
            ],
            attributeParser = {
                blur: function (){
                    

                },
                transform: function() {
                    //skip this attribute
                },
                src: function(node, conf) {
                    var attrsObj = conf.attrs,
                            value = attrsObj.src;
                    conf.attrSTR += XLINK + value + QUOT;
                },
                path: function(node, conf) {
                    var attrsObj = conf.attrs,
                            value = attrsObj.path;
                        value = R._pathToAbsolute(value || BLANK);
                    conf.attrSTR += DTAG + ((value.toString && value.toString()) || BLANK).replace(commaSanitizerReg, SPACE) + QUOT;
                },
                gradient: function(node, conf, defs) {
                    var attrsObj = node.attrs,
                            value = attrsObj.gradient,
                            type = LINEAR,
                            id = value,
                            angle,
                            fx = .5, fy = .5,
                            gStr = BLANK,
                            gCloseStr = BLANK,
                            stopStr = BLANK;
                    id = id.replace(idSanitizerReg, UNDERSCORE);
                    if (!defs[id]) {
                        value = Str(value).replace(R._radial_gradient, function(all, _fx, _fy) {
                            type = RADIAL;
                            if (_fx && _fy) {
                                fx = toFloat(_fx);
                                fy = toFloat(_fy);
                                var dir = ((fy > .5) * 2 - 1);
                                pow(fx - .5, 2) + pow(fy - .5, 2) > .25 &&
                                        (fy = math.sqrt(.25 - pow(fx - .5, 2)) * dir + .5) &&
                                        fy != .5 &&
                                        (fy = fy.toFixed(5) - 1e-5 * dir);
                            }
                            return BLANK;
                        });
                        value = value.split(/\s*\-\s*/);
                        if (type === LINEAR) {
                            angle = value.shift();
                            angle = -toFloat(angle);
                            if (isNaN(angle)) {
                                return null;
                            }
                            var vector = [0, 0, math.cos(R.rad(angle)), math.sin(R.rad(angle))],
                                    max = 1 / (mmax(abs(vector[2]), abs(vector[3])) || 1);
                            vector[2] *= max;
                            vector[3] *= max;
                            if (vector[2] < 0) {
                                vector[0] = -vector[2];
                                vector[2] = 0;
                            }
                            if (vector[3] < 0) {
                                vector[1] = -vector[3];
                                vector[3] = 0;
                            }
                        }
                        var dots = R._parseDots(value);
                        if (!dots) {
                            return null;
                        }

                        if (type === RADIAL) {
                            

                            gStr = RGRADIENTSTR1 + fx + RGRADIENTSTR2 +
                                    fy + ID + id + RGRADIENTSTR4;
                            gCloseStr = RGRADIENTSTR3;
                        }
                        else {
                            gStr = LGRADIENTSTR1 + vector[0] + LGRADIENTSTR2 +
                                    vector[1] + LGRADIENTSTR3 + vector[2] + LGRADIENTSTR4 + vector[3] +
                                    LGRADIENTSTR5 + node.matrix.invert() + BRACKETCLOSE+ ID
                                    + id + RGRADIENTSTR4;
                            gCloseStr = LGRADIENTSTR6;
                        }

                        for (var i = 0, ln = dots.length; i < ln; i++) {
                            stopStr += STOPSTR1 +
                                    STOPSTR2 + (dots[i].offset ? dots[i].offset : (i ? PERCENT100 : PERCENT0)) +
                                    STOPSTR3 + (dots[i].color || COLORWHITE) +
                                    STOPSTR4 + (dots[i].opacity === undefined ? 1 : dots[i].opacity) + STOPSTR5;
                        }
                        defs[id] = true;
                        defs.str += gStr + stopStr + gCloseStr;
                    }
                    conf.attrSTR += FILLSTR3 + id + URLCLOSE;
                },
                fill: function(node, conf) {
                    var attrsObj = conf.attrs,
                        value = attrsObj.fill,
                        color,
                        opacity;
                    if (!node.attrs.gradient) {
                        color = R.color(value);
                        opacity = color.opacity;
                        if (node.type === TXTNODE) {
                            conf.styleSTR += FILLSTR1 + color + SCOLONSPACE + STROKEOPAC + COLON + 0 + SCOLONSPACE;
                        }
                        else {
                            conf.attrSTR += FILLSTR2 + color + QUOT;
                            if(!attrsObj["fill-opacity"] && (opacity || opacity === 0)) {
                                conf.attrSTR += FILLSTR4 + opacity + QUOT;
                            }
                        }
                    }
                },
                stroke: function(node, conf) {
                    var attrsObj = conf.attrs,
                    value = attrsObj.stroke,
                    color,
                    opacity;
                    color = R.color(value);
                    opacity = color.opacity;
                    if (node.type === TXTNODE) {
                        //conf.styleSTR += FILLSTR1 + color + SCOLONSPACE;
                    }
                    else {
                        conf.attrSTR += STROKE1 + color + QUOT;
                        if(!attrsObj[STROKEOPAC] && (opacity || opacity === 0)) {
                            conf.attrSTR += STROKE2 + opacity + QUOT;
                        }
                    }
                },
                'clip-rect': function(node, conf, defs) {
                    var attrsObj = conf.attrs;

                    var     value = Str(attrsObj[CLIPRECT]),
                            rect = value.split(separator),
                            id = value.replace(idSanitizerReg, UNDERSCORE) +
                                UNDERSCORE + UNDERSCORE + (ID_Counter ++);
                    if (rect.length === 4) {
                        if (!defs[id]) {
                            defs[id] = true;
                            defs.str += CLIPSTR1 + id + CLIPSTR2 +
                                    rect[0] + CLIPSTR3 + rect[1] + CLIPSTR4 +
                                    rect[2] + CLIPSTR5 + rect[3] + CLIPSTR8 +
                                    node.matrix.invert().toMatrixString().replace(matrixSanitizerReg, BLANK) +
                                    BRACKETCLOSE + CLIPSTR6;                            
                        }
                        conf.attrSTR += CLIPSTR7 + id + BRACKETCLOSE + QUOT;
                    }
                },
                cursor: function(node, conf) {
                    var attrsObj = conf.attrs,
                            value = attrsObj.cursor;
                    if (value) {
                        conf.styleSTR += CURSOR + value + SCOLONSPACE;
                    }
                },
                font: function(node, conf) {
                    var attrsObj = conf.attrs,
                            value = attrsObj.font;
                    conf.styleSTR += FONT + COLON + value.replace(/\"/ig, SPACE) + SCOLONSPACE;
                },
                'font-size': function(node, conf) {
                    var attrsObj = conf.attrs,
                        value = pluck(attrsObj[FONTSIZE], '10');
                    if (value && value.replace) {
                        value = value.replace(retriveNumReg, BLANK);
                    }
                    conf.styleSTR += FONTSIZE + COLON + value + PXSPACE;
                },
                'font-weight': function(node, conf) {
                    var attrsObj = conf.attrs,
                            value = attrsObj[FONTWEIGHT];
                    conf.styleSTR += FONTWEIGHT + COLON + value + SCOLONSPACE;
                },
                'font-family': function(node, conf) {
                    var attrsObj = conf.attrs,
                            value = attrsObj[FONTFAMILY];
                    conf.styleSTR += FONTFAMILY + COLON + value + SCOLONSPACE;
                },
                'line-height': function() {
                },
                'clip-path': function() {
                },
                'visibility': function() {
                },
                'vertical-align': function() {
                },
                'text-anchor': function(node, conf) {
                    var attrsObj = conf.attrs,
                    value = attrsObj[TEXTANCHOR] || MIDDLE;
                    if (node.type === TXTNODE) {
                        conf.attrSTR += SPACE + TEXTANCHOR + EQUALQUOT + value + QUOT;                        
                    }
                },
                title: function() {
                },
                text: function(node, conf) {
                    var attrsObj = conf.attrs,
                            value = attrsObj.text,
                            fontSize = pluck(attrsObj[FONTSIZE], attrsObj[FONT], '10'),
                            lineHeight = pluck(attrsObj[LINEHEIGHT]),
                            text;
                            if (fontSize && fontSize.replace) {
                                fontSize = fontSize.replace(retriveNumReg, BLANK);
                            }
                            fontSize = pluckNumber(fontSize);
                            if (lineHeight && lineHeight.replace) {
                                lineHeight = lineHeight.replace(retriveNumReg, BLANK);
                            }
                            lineHeight = pluckNumber(lineHeight, fontSize && fontSize * 1.2);
                            var baseHight = fontSize ? fontSize * 0.85 : lineHeight * 0.75,
                            x = attrsObj.x,
                            valign = pluck(attrsObj[VALIGNSTR], MIDDLE).toLowerCase(),
                            texts = Str(value).split(textNewLineReg),
                            ii = texts.length,
                            i = 0,
                            baseAdjust = (valign === TOP ? baseHight : (valign === BOTTOM ?
                            (baseHight - (lineHeight * ii)) : (baseHight - (lineHeight * ii * 0.5))));

                    for (; i < ii; i++) {
                        conf.textSTR += TSPANSTR1;
                        text = (texts[i] || BLANK).replace(ampregex, ampSTR)
                            .replace(quot1regex, quot1STR)
                            .replace(quot2regex, quot2STR)
                            .replace(ltregex, ltSTR)
                            .replace(gtregex, gtSTR);
                        if (i) {
                            conf.textSTR += TSPANSTR2 + lineHeight + TSPANSTR3 + x + QUOTSPACE;
                        }
                        else {
                            conf.textSTR += TSPANSTR4 + baseAdjust + QUOT;
                        }
                        conf.textSTR += GT + text + TSPANSTR6;
                    }
                }
            },
            /**
             * This the methode used to generate SVG string of a Raphael element.
             * This methode is used in non-SVG browser only.
             *
             * @param {RaphaelElement} node is to be converted into xml string
             * @param {object} defs is the store of all defs information
             *
             */

            parseNode = function(node, defs) {
                var xmlSTR = BLANK,
                        conf = {
                    attrSTR: BLANK,
                    styleSTR: BLANK,
                    textSTR: BLANK,
                    attrs: node.attr()
                },
                    isShadow = node.isShadow,
                childXMLSTR = BLANK,
                        nextXMLSTR = BLANK,
                        attrName,
                        styleName,
                        nodeType,
                        attrs = conf.attrs;
                //parse visible nodes only
                if (node.node.style.display !== NONE && !isShadow) {
                    //parse all atributes
                    for (attrName in attrs) {
                        if (attrName !== GRADIENT && (availableAttrs[attrName] !== undefined || attributeParser[attrName])){
                            ///if custom parser exist then use it
                            if (attributeParser[attrName]) {//if need persing
                                attributeParser[attrName](node, conf, defs);
                            }
                            else {//else add the attribute directly
                                conf.attrSTR += SPACE + attrName + EQUALQUOT + attrs[attrName] + QUOT;
                            }
                        }
                    }
                    //add the gradient
                    if(node.attrs.gradient){
                        attributeParser.gradient(node, conf, defs);
                    }
                    if (node.type === RECT && attrs.r){
                        conf.attrSTR += SPACE + RX + EQUALQUOT + attrs.r + QUOT + 
                                SPACE + RY + EQUALQUOT + attrs.r + QUOT;
                    }

                    //Parse all style atributes that are not in attrs
                    for (styleName in node.styles) {
                        conf.styleSTR += styleName + COLON + node.styles[styleName] + SCOLONSPACE;
                    }

                    //node type speciffic changes
                    if (node.type === IMGNODE) {
                        conf.attrSTR += ASPRATIO;
                    }
                    

                    //if node has a child element then parse the child element
                    if (node.bottom) {
                        childXMLSTR = parseNode(node.bottom, defs);
                    }
                    //parse following sibling also
                    if (node.next) {
                        nextXMLSTR = parseNode(node.next, defs);
                    }
                    nodeType = node.type;
                    if (nodeType.match(grouptagtestReg)) {
                        nodeType = 'g';
//                        matrixStr = node.matrix.toMatrixString().replace(matrixSanitizerReg, BLANK);
//                    }
//                    else {
//                        matrixStr = node.matrix.toMatrixString().replace(matrixSanitizerReg, BLANK);
                    }
                    //generate SVG string
                    xmlSTR += LT + nodeType + NODESTRPART2 +
                            node.matrix.toMatrixString().replace(matrixSanitizerReg, BLANK) +
                            NODESTRPART3 + conf.styleSTR + QUOT + conf.attrSTR +
                            GT + conf.textSTR + childXMLSTR + NODESTRPART5 +
                            nodeType + GT + nextXMLSTR;
                }
                else {
                    //parse following sibling also
                    if (node.next) {
                        xmlSTR += parseNode(node.next, defs);
                    }
                }
                return xmlSTR;
            };

            /**
             * This the methode return the SVG string of a Raphael paper.
             *
             */
            R.fn.toSVG = function(keepImages) {
                var paper = this,
                    restore = {svg: R.svg, vml: R.vml},
                    svg = BLANK,
                    defs = {str: BLANK},
                    regObj,
                    i = 0,
                    ln = regStore.length,
                    childXMLSTR = BLANK;

                // If SVG browser then get the innerHTML of the parent node
                // and sanitize the SVG string
                if (R.svg) {
                    if (paper.canvas && paper.canvas.parentNode) {
                        svg = paper.canvas.parentNode.innerHTML;
                        // sanitize svg string
                        for (; i < ln; i += 1) {
                            regObj = regStore[i];
                            svg = svg.replace(regObj.reg, regObj.repStr);
                        }
                    }
                }
                // for VML browser parse node element and create SVG string
                else {
                    svg = '<svg style="overflow: hidden; position: relative;" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="' +
                        paper.width + '" version="1.1" height="' + paper.height + '">';

                    if (paper.bottom) {
                        //parse all node manualy and create XML string
                        childXMLSTR = parseNode(paper.bottom, defs);
                    }
                    svg += '<defs>' + defs.str + '</defs>' + childXMLSTR + '</svg>';
                }
                //remove all image tags
                if (!keepImages) {
                    svg = svg.replace(/\<image [^\>]*\>/gi, BLANK);
                }
                return svg;
            };

        })(R);

    }]);/*jslint forin: true, regexp: true, todo: true, white: false, browser: true,
    sloppy: true, white: true */
/*global window: true, FusionCharts */

/**
 * Red Raphael JavaScript Library
 * ------------------------------
 * @section Extension for support of tooltip
 * @since 3.3
 */

FusionCharts(['private', 'modules.renderer.js-raphaeltooltip', function () {

    var global = this,
        win = window,
        doc = document,
        lib = global.hcLib,
        R = lib.Raphael,
        eve = R.eve,
        createElement = lib.createElement,
        addEvent = lib.addEvent,
        removeEvent = lib.removeEvent,
        getPosition = lib.getPosition,
        hasTouch = lib.hasTouch,
        touchSafeEvent = lib.getTouchEvent,

        math = win.Math,
        mathCeil = math.ceil,
        mathFloor = math.floor,

        NONE = "none",
        INLINE = "inline",
        E = "",
        MINVPWIDTH = 100,
        MINVPHEIGHT = 100,
        vpHeight = win.screen.availHeight,
        vpWidth = win.screen.availWidth,

        cssVendorPrefixes = {'':1, moz:1, webkit:1, o:1, ms:1},
        vendorSpecificStyles = {
            borderRadius: 'borderRadius',
            boxShadow: 'boxShadow'
        },

        regexCamelCase = /\-([a-z])/ig,
        regexCamelCaseReplacer = function (_a, _b) {
            return _b.toUpperCase();
        },

        StyleProperty = function (overrides) {
            var f = tip.forbiddenStyle,
                key,
                csskey,
                subkey;

            for (key in overrides) {
                // In case any hyphenated key is passed, convert it to camelCase.
                csskey = regexCamelCase.test(key) ?
                    key.replace(regexCamelCase, regexCamelCaseReplacer) : key;
                (overrides[key] !== undefined) && !f[csskey] &&
                    (this[csskey] = overrides[key]);

                // Convert color to hex for VML based browsers since they do not
                // support RGBA.
                if (R.vml && /color/ig.test(csskey)) {
                    this[csskey] = R.getRGB(this[csskey]).toString();
                }
            }

            // Do special handling and vendor prefixing for border radius
            for (key in vendorSpecificStyles) {
                if (this[key]) {
                    for (subkey in cssVendorPrefixes) {
                        this[subkey + key] = this[key];
                    }
                }
            }
        },

        tip = lib.toolTip = {
            elementId: "fusioncharts-tooltip-element",
            element: null,
            lastTarget: null,
            currentTarget: null,
            currentPaper: null,
            pointeroffset: 12,

            defaultStyle: lib.extend2(StyleProperty.prototype, {
                backgroundColor: '#ffffee',
                borderColor: '#000000',
                borderWidth: '1px',
                color: '#000000',
                fontSize: '10px',
                lineHeight: '12px',
                padding: '3px',
                borderStyle: "solid"
            }),

            defaultContainerStyle: {
                position: "absolute",
                textAlign: "left",
                margin: "0",
                zIndex: "999",
                pointer: "default",
                display: "block"
            },

            forbiddenStyle: {}
        },
        windowClickEvent = function (event) {
            //remove window click event
            removeEvent(window, 'click', windowClickEvent);
            //hide tooltip
            tip.onhide.call(this, event);
        };

    if (R.svg) {
        tip.defaultContainerStyle['pointerEvents'] = NONE;
        tip.defaultStyle['borderRadius'] = "0";
        tip.defaultStyle['boxShadow'] = NONE;
    }

    if (R.vml) {
        tip.forbiddenStyle['borderRadius'] = true;
        tip.forbiddenStyle['boxShadow'] = true;
        tip.defaultStyle['filter'] = E;
    }

    tip.setup = function () {
        var container = tip.container,
            textElement = tip.textElement,
            containerStyle = tip.style,
            defaultContainerStyle = tip.defaultContainerStyle,
            f = tip.forbiddenStyle,
            key;

        if (!container) {
            container = tip.element = createElement('span');
            (doc.body || doc.getElementsByTagName('body')[0])
                .appendChild(container);
            container.setAttribute("id", tip.elementId);
            containerStyle = tip.containerStyle = R.vml ? container.runtimeStyle :
                container.style;

            textElement = tip.textElement = createElement('span');
            container.appendChild(textElement);
            tip.style = R.vml ? textElement.runtimeStyle : textElement.style;
            tip.style.overflow = "hidden";
            tip.style.display = "block";

            tip.hidden = false;
            tip.hide();
        }

        // Set default styles.
        for (key in defaultContainerStyle) {
            !f[key] && (containerStyle[key] = defaultContainerStyle[key]);
        }

        // on accidental touch of element, move it fast.
        addEvent(container, hasTouch && 'touchstart' || 'mouseover', tip.onredraw);

        // on drag of elements, hide the tooltip
        tip.scatted = true;
        eve.on('raphael.drag.start.*', function () {
            tip.scatted && (tip.waitingScat = true);
        });
        eve.on('raphael.drag.move.*', function () {
            if (tip.waitingScat) {
                tip.block();
                tip.waitingScat = false;
            }
        });
        eve.on('raphael.drag.end.*', function () {
            tip.waitingScat = false;
            if (tip.scatted) {
                tip.unblock(true);
            }
        });

        // Ensure tooltip hides when paper is removed
        eve.on('raphael.remove', function () {
            if (tip.currentPaper === this || tip.currentTarget &&
                (tip.currentTarget.paper === this)) {
                tip.hide();
                tip.currentTarget = tip.currentPaper = null;
            }
        });
    };

    tip.restyle = function (style) {
        var s = tip.style,
            key;

        for (key in style) {
            s[key] = style[key];
        }
    };

    tip.onelement = function (event) {
        var o = event.data,
            paper = o.paper,
            tipStyle = paper.__tip_style;

        // If not setup then do not initiate
        if (!tipStyle) {
            return;
        }

        // prevent hiding.
        tip.hiding && (tip.hiding = clearTimeout(tip.hiding));

        if (tip.currentPaper !== paper) {
            paper.__tip_cp = paper.canvas && getPosition(paper.canvas.parentNode, true) || {};
            tip.restyle(paper.__tip_style);
            tip.currentPaper = paper;
        }
        tip.lastTarget = tip.currentTarget;
        tip.currentTarget = o;

        // update scat information
        (tip.scatted = o.__tip_scatted);

        tip.onredraw.call(this, event);
        //for touch device listen window click to hide tooltip
        if (hasTouch){
            addEvent(window, 'click', windowClickEvent);
            //stop event bubbling
            return false;
        }
    };



    tip.onredraw = function (event) {
        tip.redrawing && clearTimeout(tip.redrawing);
        event = touchSafeEvent(event);
        tip.x = mathFloor(event.pageX);
        tip.y = mathFloor(event.pageY);
        tip.redrawing = setTimeout(tip.redraw, 0);
    };

    tip.onhide = function (e) {
        tip.hiding = setTimeout(tip.hide, 200);
    };

    tip.redraw = function () {
        if (tip.blocked || !tip.currentTarget) {
            return;
        }

        var o = tip.currentTarget,
            paper = o.paper,
            textEl = tip.textElement,
            containerStyle = tip.containerStyle,
            style = tip.style,
            text = o.__tip_text,
            offset = tip.pointeroffset,
            cp = paper.__tip_cp,
            docEl = doc.documentElement || doc.body,
            scrollLeft = docEl.scrollLeft,
            scrollTop = docEl.scrollTop,
            x = tip.x,
            y = tip.y,
            width,
            height,
            pw = paper.width,
            ph = paper.height,
            constrain = paper.__tip_constrain;

        if (pw < MINVPWIDTH || ph < MINVPHEIGHT) {
            constrain = false;
        }

        if (tip.hidden) {
            tip.containerStyle.top = "-999em"; // perform changes out of view
            tip.show();
        }

        if (text !== tip.text) {
            tip.text = text;
            containerStyle.width = containerStyle.height = "";

            // Set text and compute its dimensions when word-wrapping is not
            // applied.
            textEl.innerHTML = text;
            style.whiteSpace = "nowrap";
            width = mathCeil(style.pixelWidth || textEl.offsetWidth || 0);
            height = mathCeil(style.pixelHeight || textEl.offsetHeight || 0);
            style.whiteSpace = "normal";

            // Set tooltip dimension if text is overflowing.
            containerStyle.width = (tip.textWidthOverflow = width > pw) ?
                (pw || 0) - offset * 2 + "px" : "";
            containerStyle.height = (tip.textHeightOverflow = height > ph) ?
                (ph || 0) - offset * 2 + "px" : "";
        }

        width = mathCeil(style.pixelWidth || textEl.offsetWidth || 0);
        height = mathCeil(style.pixelHeight || textEl.offsetHeight || 0);

        // if the tooltip is to be constrained within the paper
        if (constrain) {
            // is there enough space to show the tooltip in the default position
            if (tip.textWidthOverflow) {
                x = cp.left - scrollLeft;
            }
            // if not reposition the tooltip
            else if (x + offset + width > cp.left - scrollLeft + pw - offset) {
                x = x - width - offset;
            }

            if (tip.textHeightOverflow) {
                y = cp.top - scrollTop;
            }
            else if (y + offset + height > cp.top - scrollTop + ph - offset) {
                y = y - height - offset * 1.5;
            }
        }
        else {
            if (scrollLeft + vpWidth < x + offset + width) {
                x = x - width - offset;
            }

            if (scrollTop + vpHeight < y + offset + height) {
                y = y - height - offset * 1.5;
            }
        }

        containerStyle.left = ((x + offset) || 0) + 'px';
        containerStyle.top = ((y + offset) || 0) + 'px';

        if (tip.hidden) {
            tip.show();
        }
    };

    tip.hide = function () {
        tip.hiding && (tip.hiding = clearTimeout(tip.hiding));
        tip.containerStyle.display = NONE;
        tip.hidden = true;
    };

    tip.show = function () {
        if (!tip.blocked) {
            tip.hiding && (tip.hiding = clearTimeout(tip.hiding));
            tip.containerStyle.display = INLINE;
            tip.hidden = false;
        }
    };

    tip.block = function () {
        tip.blocked = true;
        tip.containerStyle.display = NONE;
    };

    tip.unblock = function (retain) {
        tip.blocked = false;
        retain && (tip.containerStyle.display = (tip.hidden && NONE || INLINE));
    };

    R.fn.tooltip = function (css, shadow, constrain) {
        var paper = this,
            op;

        if (shadow) {
            op = (shadow.opacity === undefined ? 1 : shadow.opacity) * 0.4;
            if (R.svg) {
                css['boxShadow'] = '1px 1px 3px rgba(64,64,64,' + op +')';
            }
            else {
                css['filter'] = "progid:DXImageTransform.Microsoft.Shadow(Strength=2, Direction=135, Color='#404040', shadowOpacity='" + op / 2 + "')";
            }
        }

        paper.__tip_style = new StyleProperty(css);
        paper.__tip_cp = paper.canvas && getPosition(paper.canvas.parentNode, true) || {};
        paper.__tip_constrain = Boolean(constrain);

        return paper;
    };

    R.el.tooltip = function (text, x, y, unscat, blocked) {
        tip.setup();
        R.el.tooltip = function (text, x, y, unscat, blocked) {
            var o = this,
                node = o.node,
                notext = (text == undefined) || !(text + E);


            o.__tip_scatted = unscat == undefined ? o.__tip_scatted : !unscat;
            (o.__tip_scatted == undefined) && (o.__tip_scatted = true);

            if (blocked != null) {
                o.__tip_blocked = blocked;
            }

            if (notext ^ !o.__tip_text) {
                if (hasTouch) {
                    (notext ? removeEvent : addEvent)(node, 'click', tip.onelement, o);
                }
                else if (notext) {
                    removeEvent(node, 'mouseover', tip.onelement, o);
                    removeEvent(node, 'mousemove', tip.onredraw, o);
                    removeEvent(node, 'mouseout', tip.onhide, o);
                }
                else {
                    addEvent(node, 'mouseover', tip.onelement, o);
                    addEvent(node, 'mousemove', tip.onredraw, o);
                    addEvent(node, 'mouseout', tip.onhide, o);
                }
            }
            o.__tip_text = text;

            if (tip.currentTarget === o && text !== tip.text && !tip.hidden) {
                tip[notext ? 'hide' : 'redraw']();
            }

            return o;
        };
        return R.el.tooltip.call(this, text, x, y, unscat, blocked);
    };

}]);

FusionCharts(['private', 'modules.renderer.js-base', function () {

    var global = this,
        lib = global.hcLib,
        win = window,
        doc = win.document,
        //strings
        BLANKSTRING = lib.BLANKSTRING,
        createTrendLine = lib.createTrendLine,
        DEFAULT_EXPORT_URL = 'http://export.api3.fusioncharts.com/',
        //add the tools thats are requared
        pluck = lib.pluck,
        getValidValue = lib.getValidValue,
        pluckNumber = lib.pluckNumber,
        defaultPaletteOptions = lib.defaultPaletteOptions,
        getFirstValue = lib.getFirstValue,
        getDefinedColor = lib.getDefinedColor,
        parseUnsafeString = lib.parseUnsafeString,
        FC_CONFIG_STRING = lib.FC_CONFIG_STRING,
        extend2 = lib.extend2, //old: jarendererExtend / margecolone
        getDashStyle = lib.getDashStyle, // returns dashed style of a line series
        toRaphaelColor = lib.toRaphaelColor,
        toPrecision = lib.toPrecision,
        stubFN = lib.stubFN,
        hasSVG = lib.hasSVG,
        isIE = lib.isIE,
        dropHash = lib.regex.dropHash,
        HASHSTRING = lib.HASHSTRING,
        getSentenceCase = lib.getSentenceCase,
        extend = function(a, b) { 

            var n;
            if (!a) {
                a = {};
            }
            for (n in b) {
                a[n] = b[n];
            }
            return a;
        },
        each = lib.each,
        addEvent = lib.addEvent,
        getTouchEvent = lib.getTouchEvent,
        defined = function(obj) {
            return obj !== UNDEFINED && obj !== null;
        },
        pInt = function(s, mag) {
            return parseInt(s, mag || 10);
        },
        isObject = function(obj) {
            return typeof obj === 'object';
        },
        isString = function(s) {
            return typeof s === 'string';
        },
        docMode8 = document.documentMode === 8,
        UNDEFINED,
        TRACKER_FILL = 'rgba(192,192,192,' + (isIE ? 0.002 : 0.000001) + ')', // invisible but clickable
        NORMAL_STATE = '',
        SELECT_STATE = 'select',
        HIDDEN = 'hidden',
        VISIBLE = docMode8 ? 'visible' : '',
        SHOW = 'show',
        HIDE = 'hide',
        CRISP = 'crisp',
        PX = 'px',
        NONE = 'none',
        M = 'M',
        L = 'L',
        A = 'A',
        AT = 'AT',
        WA = 'WA',
        Z = 'Z',
        COMMA = ',',
        math = Math,
        mathSin = math.sin,
        mathCos = math.cos,
        mathATan2 = math.atan2,
        mathRound = math.round,
        mathMin = math.min,
        mathMax = math.max,
        mathAbs = math.abs,
        mathPI = math.PI,
        mathCeil = math.ceil,
        mathFloor = math.floor,
        mathSqrt = math.sqrt,
        mathLog = math.log,
        mathPow = math.pow,
        deg2rad = mathPI / 180,
        rad2deg = 180 / mathPI,
        pi = Math.PI,
        piBy2 = pi / 2,
        pi2 = 2 * pi,
        pi3By2 = pi + piBy2,
        pi4 = 4 * pi,
        getColumnColor = lib.graphics.getColumnColor,
        getFirstColor = lib.getFirstColor,
        setLineHeight = lib.setLineHeight,
        pluckFontSize = lib.pluckFontSize, // To get the valid font size (filters negative values)
        pluckColor = lib.pluckColor,
        hashify = lib.hashify,
        getFirstAlpha = lib.getFirstAlpha,
        getDarkColor = lib.graphics.getDarkColor,
        getLightColor = lib.graphics.getLightColor,
        convertColor = lib.graphics.convertColor,
        COLOR_TRANSPARENT = lib.COLOR_TRANSPARENT,
        POSITION_CENTER = lib.POSITION_CENTER,
        POSITION_TOP = lib.POSITION_TOP,
        POSITION_BOTTOM = lib.POSITION_BOTTOM,
        POSITION_RIGHT = lib.POSITION_RIGHT,
        POSITION_LEFT = lib.POSITION_LEFT,
        POSITION_MIDDLE = 'middle',
        POSITION_START = 'start',
        POSITION_END = 'end',
        GUTTER_4 = 4,
        t = 't',
        r = 'r',
        INT_ZERO = 0,
        chartAPI = lib.chartAPI,
        titleSpaceManager = lib.titleSpaceManager,
        placeLegendBlockBottom = lib.placeLegendBlockBottom,
        placeLegendBlockRight = lib.placeLegendBlockRight,
        mapSymbolName = lib.graphics.mapSymbolName,
        singleSeriesAPI = chartAPI.singleseries,
        multiSeriesAPI = chartAPI.multiseries,
        COMMASTRING = lib.COMMASTRING,
        STRINGUNDEFINED = lib.STRINGUNDEFINED,
        ZEROSTRING = lib.ZEROSTRING,
        ONESTRING = lib.ONESTRING,
        HUNDREDSTRING = lib.HUNDREDSTRING,
        PXSTRING = lib.PXSTRING,
        COMMASPACE = lib.COMMASPACE,
        creditLabel = true && !/fusioncharts\.com$/i.test(location.hostname),
        CREDIT_STRING  = lib.CREDIT_STRING = 'FusionCharts XT Trial',
        /**
                 * Reduces the pain of writing loads of object structures while creating
                 * FusionCharts specific color configurations
                 */
        colorize = function(original, obj) {
            if (!obj) {
                return {
                    FCcolor: original
                };
            }
            else {
                return extend(original.FCcolor, obj);
            }

        },



        //strings
        BLANKSTRINGPLACEHOLDER = lib.BLANKSTRINGPLACEHOLDER,
        parsePointValue = lib.parsePointValue,
        deltend = lib.deltend,
        stableSort = lib.stableSort,
        BGRATIOSTRING = lib.BGRATIOSTRING,
        COLOR_WHITE = lib.COLOR_WHITE,


        //strings
        SAMPLESTRING = lib.SAMPLESTRING,
        TESTSTR = lib.TESTSTR,
        getAngle = lib.graphics.getAngle,
        axisLabelAdder = lib.axisLabelAdder,
        falseFN = lib.falseFN,

        //add the tools thats are requared
        SmartLabelManager = lib.SmartLabelManager,
        NumberFormatter = lib.NumberFormatter,
        getLinkAction = lib.getLinkAction,
        getAxisLimits = lib.getAxisLimits,

        createDialog = lib.createDialog,

        logOf = function (value, base) {
            return (value > 0) ? (mathLog(value) / mathLog(base || 10)) : null;
        },

        hasTouch = lib.hasTouch = document.documentElement.ontouchstart !== undefined,
        /**
         * Remove event added with addEvent
         * @param {Object} el The object
         * @param {String} eventType The event type. Leave blank to remove all events.
         * @param {Function} handler The function to remove
         */
        removeEvent = lib.removeEvent = function(el, eventType, handler) {
            // workaround for jQuery issue with unbinding custom events:
            // http://forum.jquery.com/topic/javascript-error-when-unbinding-a-custom-event-using-jquery-1-4-2
            var func = doc.removeEventListener ? 'removeEventListener' : 'detachEvent';
            if (doc[func] && !el[func]) {
                el[func] = function() {};
            }

            jQuery(el).unbind(eventType, handler);
        },

        /**
         * Fire an event on a custom object
         * @param {Object} el
         * @param {String} type
         * @param {Object} eventArguments
         * @param {Function} defaultFunction
         */
        fireEvent = lib.fireEvent = function(el, type, eventArguments, defaultFunction) {
            var event = jQ.Event(type),
            detachedType = 'detached'+ type;
            extend2(event, eventArguments);

            // Prevent jQuery from triggering the object method that is named the
            // same as the event. For example, if the event is 'select', jQuery
            // attempts calling el.select and it goes into a loop.
            if (el[type]) {
                el[detachedType] = el[type];
                el[type] = null;
            }

            // trigger it
            jQuery(el).trigger(event);

            // attach the method
            if (el[detachedType]) {
                el[type] = el[detachedType];
                el[detachedType] = null;
            }

            if (defaultFunction && !event.isDefaultPrevented()) {
                defaultFunction(event);
            }
        },

        styleValueMap = {
            fontWeight : {
                '1' : 'bold',
                '0': 'normal'
            },
            fontStyle : {
                '1' : 'italic',
                '0': 'normal'
            },
            textDecoration : {
                '1' : 'underline',
                '0': 'none'
            }
        },

        fontStyleMap = {//create the map function for every fontstyle attribute
            font: function (value, obj) {
                obj.style.fontFamily = value;
            },
            size: function (value, obj) {
                if (value) {
                    obj.style.fontSize = pluckFontSize(value) + PXSTRING;
                }

            },
            color: function (value, obj, isDataValuess) {
                obj.style.color = value && value.replace && value.replace(dropHash, HASHSTRING) || BLANKSTRING;
                if (isDataValuess) {
                    obj.color = obj.style.color;
                }
            },
            /* align has been suppressed until better implementation.
            align: function (value, obj) {

                 if (value.toLowerCase) {
                    obj.align = value.toLowerCase();
                }
            },*/
            bgcolor: function (value, obj) {
                obj.style.backgroundColor = value && value.replace && value.replace(dropHash, HASHSTRING) || BLANKSTRING;
            },
            bordercolor: function (value, obj) {
                obj.style.border = '1px solid';
                obj.style.borderColor = value && value.replace && value.replace(dropHash, HASHSTRING) || BLANKSTRING;
            },
            ishtml: BLANKSTRING,
            leftmargin: function (value, obj) {
                obj.style.marginLeft =  pluckNumber(value, 0) + PXSTRING;
            },
            letterspacing: function (value, obj) {
                obj.style.letterSpacing = pluckNumber(value, 0) + PXSTRING;
            },
            bold: function (value, obj) {
                obj.style.fontWeight = styleValueMap.fontWeight[value] || '';
            //obj.style.fontWeight = value == '1' ? 'bold' : '';
            },
            italic: function (value, obj) {
                obj.style.fontStyle = styleValueMap.fontStyle[value] || '';
            },
            underline: function (value, obj) {
                obj.style.textDecoration = styleValueMap.textDecoration[value] || '';
            }
        },

        // Palette string and 3d chart palette string
        chartPaletteStr = {
            chart2D: {
                bgColor : 'bgColor',
                bgAlpha : 'bgAlpha',
                bgAngle : 'bgAngle',
                bgRatio : 'bgRatio',
                canvasBgColor : 'canvasBgColor',
                canvasBaseColor : 'canvasBaseColor',
                divLineColor : 'divLineColor',
                legendBgColor : 'legendBgColor',
                legendBorderColor : 'legendBorderColor',
                toolTipbgColor : 'toolTipbgColor',
                toolTipBorderColor : 'toolTipBorderColor',
                baseFontColor : 'baseFontColor',
                anchorBgColor : 'anchorBgColor'
            },
            chart3D : {
                bgColor : 'bgColor3D',
                bgAlpha : 'bgAlpha3D',
                bgAngle : 'bgAngle3D',
                bgRatio : 'bgRatio3D',
                canvasBgColor : 'canvasBgColor3D',
                canvasBaseColor : 'canvasBaseColor3D',
                divLineColor : 'divLineColor3D',
                divLineAlpha : 'divLineAlpha3D',
                legendBgColor : 'legendBgColor3D',
                legendBorderColor : 'legendBorderColor3D',
                toolTipbgColor : 'toolTipbgColor3D',
                toolTipBorderColor : 'toolTipBorderColor3D',
                baseFontColor : 'baseFontColor3D',
                anchorBgColor : 'anchorBgColor3D'
            }
        },

        handleContainerResize = (function () {
            var store = {},
            INTERVALMS = 300,
            intervalId,
            trackResize = function () {
                var item,
                itemObj,
                itemVar,
                parentEle,
                count = 0,
                ref,
                offW,
                offH;

                for (item in store) {
                    count += 1;
                    itemObj = store[item];
                    itemVar = itemObj.jsVars,
                    ref = itemObj.ref;

                    if ((parentEle = ref && ref.parentNode)) {
                        offW = parentEle.offsetWidth;
                        offH = parentEle.offsetHeight;
                        if (!itemVar.resizeLocked &&
                            (itemVar._containerOffsetW !== offW ||
                                itemVar._containerOffsetH !== offH)) {
                            ref.resize && ref.resize();
                            itemVar._containerOffsetW = offW;
                            itemVar._containerOffsetH = offH;
                        }
                    }
                    else {
                        delete store[item];
                        count -= 1;
                    }
                }

                if (!count) {
                    intervalId = clearInterval(intervalId);
                }
            };

            return function (sender) {
                var vars = sender.jsVars,
                element = sender.ref && sender.ref.parentNode || {};

                vars._containerOffsetW = element.offsetWidth;
                vars._containerOffsetH = element.offsetHeight;
                store[sender.id] = sender;

                if (!intervalId) {
                    intervalId = setInterval(trackResize, INTERVALMS);
                }
            };
        })(),

        privateAPIMethods = {
            getExternalInterfaceMethods: function () {
                var vars = this.jsVars,
                api = chartAPI[vars.type],
                eiMethods = api && api.eiMethods,
                eiMethodString = 'saveAsImage,print,exportChart,getXML,hasRendered,signature,cancelExport,getSVGString,';

                if (typeof eiMethods === 'string') {
                    eiMethodString += eiMethods + COMMASTRING;
                }
                else if (eiMethods !== undefined || eiMethods !== null) {
                    for (var method in eiMethods) {
                        eiMethodString += method + COMMASTRING;
                    }
                }

                return eiMethodString.substr(0, eiMethodString.length -1);
            },

            drawOverlayButton: function (args) {
                var vars = this.jsVars,
                $back = vars.$overlayButton;

                if (args && args.show) {
                    if (!$back) {
                        $back = vars.$overlayButton = jQuery('<span>');
                        $back.click(function () {
                            global.raiseEvent('OverlayButtonClick', args, vars.fcObj);
                        });
                    }

                    $back.text(args.message ? args.message : "Back");
                    vars.overlayButtonMessage = $back.text(); // #FCXT-217

                    // Create the visual layout of the element.
                    $back.css({
                        border: '1px solid ' + (args.borderColor ? args.borderColor.replace(dropHash, HASHSTRING) : "#7f8975"),
                        backgroundColor: (args.bgColor ? args.bgColor.replace(dropHash, HASHSTRING) : "#edefec"),
                        fontFamily: args.font ? args.font : "Verdana",
                        color: '#' + args.fontColor ? args.fontColor: "49563a",
                        fontSize: (args.fontSize ? args.fontSize : '10') + PXSTRING,
                        padding: (args.padding ? args.padding : '3') + PXSTRING,
                        fontWeight: parseInt(args.bold, 10) === 0 ? 'normal' : 'bold',
                        position: 'absolute',
                        top: '0',
                        right: '0',
                        '_cursor': 'hand',
                        cursor: 'pointer'

                    });

                    vars.hcObj.container.appendChild($back[0]);
                    vars.overlayButtonActive = true;
                }
                else if ($back) {
                    $back.detach();
                    vars.overlayButtonActive = false;
                    delete vars.overlayButtonMessage;
                }
            },

            print: function () {
                return this.jsVars.hcObj && this.jsVars.hcObj.hasRendered &&
                this.jsVars.hcObj.print();
            },

            exportChart: function (setup) { //export the chart
                var vars = this.jsVars,
                hcObj = vars.hcObj;

                // check whether exporting is enabled or not
                if (hcObj && hcObj.options && hcObj.options.exporting &&
                    hcObj.options.exporting.enabled) {
                    return hcObj.exportChart(setup);
                }
                return false;
            },

            getSVGString: function () {

                return this.jsVars && this.jsVars.hcObj &&
                    this.jsVars.hcObj.paper && this.jsVars.hcObj.paper.toSVG();
            },

            resize: function () {
                var vars = this.jsVars,
                container = vars.container,
                fcObj = vars.fcObj,
                hcObj = vars.hcObj;

                if (!hcObj) {
                    return;
                }

                // destroy old chart
                if (hcObj && hcObj.destroy) {
                    hcObj.destroy();
                }

                lib.createChart(vars.fcObj, container, vars.type, undefined,
                    undefined, false);

                delete vars.isResizing;

                lib.raiseEvent('resized', {
                    width: fcObj.width,
                    height: fcObj.height,
                    prevWidth: vars.width,
                    prevHeight: vars.height
                }, fcObj, [fcObj.id]);
            },

            lockResize: function (state) {
                return this.jsVars.resizeLocked = state === undefined && true || state;
            },

            showChartMessage: function (text, modal, cancelable) {
                var vars = this.jsVars,
                hcObj = vars.hcObj;

                if (vars.msgStore[text]) {
                    text = vars.msgStore[text];
                }

                if (modal && hcObj && hcObj.hasRendered) {
                    text ? hcObj.showMessage(text, cancelable) : hcObj.hideLoading();
                }
                else {
                    // destroy old chart
                    if (hcObj && hcObj.destroy) {
                        hcObj.destroy();
                    }

                    // create new dialog json and render chart
                    lib.createChart(vars.fcObj, vars.container, vars.type,
                        undefined, text);
                }
                return text;
            },

        signature: function () {
            return 'FusionCharts/3.3.1 (XT)';
        }
    };


    lib.createChart = function (chartObj, container, type, notify, hcJSON,
            animate, suppressDataErrors) {

        var vars = chartObj.jsVars,
        msgStore = vars.msgStore,
        dataComp, dataObj,
        api = chartAPI[type],
        instanceAPI,
        callback = function (obj) {

            var eventArgs = {
                renderer: 'javascript'
            },
            fcObj = vars.fcObj,
            w = fcObj.width,
            h = fcObj.height,
            eiMethods = api && api.eiMethods,
            $back = vars.$overlayButton;

            container.jsVars = chartObj.jsVars;
            vars.container = container;
            vars.hcObj = obj;
            vars.type = type;
            vars.width = container.offsetWidth;
            vars.height = container.offsetHeight;
            vars.instanceAPI = instanceAPI;

            if (obj.hasRendered) {
                // Add private ExternalInterface API
                global.extend(container, privateAPIMethods);

                // Add Public externalInteface API
                if (eiMethods && typeof eiMethods !== 'string') {
                    for (var method in eiMethods) {
                        container[method] = eiMethods[method]
                    }
                }

                // if overlaybutton was there, make it persistent.
                if (vars.overlayButtonActive && $back) {
                    $back.text(vars.overlayButtonMessage); // #FCXT-217
                    obj.container.appendChild($back[0]);
                }
            }

            if (notify) {
                notify({
                    success: obj.hasRendered,
                    ref: container,
                    id: chartObj.id
                });

                if (obj.hasRendered) {
                    w = Number((w && w.match && w.match(/^\s*(\d*\.?\d*)\%\s*$/) || [])[1]);
                    h = Number((h && h.match && h.match(/^\s*(\d*\.?\d*)\%\s*$/) || [])[1]);

                    if ((w || h) && fcObj.ref && fcObj.ref.parentNode) {
                        handleContainerResize(fcObj);
                    }

                    // Call render completion events.
                    lib.raiseEvent('loaded', {
                        type: type,
                        renderer: 'javascript'
                    }, chartObj, [chartObj.id]);

                    lib.raiseEvent('rendered', {
                        renderer: 'javascript'
                    }, fcObj, [fcObj.id]);
                }
            }

            // Fire draw complete irrespective whether rendering was a chart or
            // a message. But do it after rendered event
            if (obj.hasRendered && vars.previousDrawCount < vars.drawCount) {
                eventArgs.width = vars.width;
                eventArgs.height = vars.height;
                eventArgs.drawCount = vars.drawCount;
                eventArgs.drawingLatency = instanceAPI.drawingLatency;
                eventArgs.displayingMessage = vars.hasNativeMessage;
                lib.raiseEvent('drawcomplete', eventArgs, fcObj, [fcObj.id]);
            }
        };

        // set the data-ready flag to false. It is later set to true below in
        // this function itself.
        chartObj.__state.dataReady = false;

        // dispose old instanceAPI
        if (vars.instanceAPI && vars.instanceAPI.dispose) {
            vars.instanceAPI.dispose();
        }
        instanceAPI = api ? new chartAPI(type) : new chartAPI('stub');
        instanceAPI.chartInstance = chartObj;

        // if a JSON is already provided
        if (hcJSON !== undefined) {
            if (typeof hcJSON === 'string') {
                hcJSON = new createDialog(container, hcJSON);
                vars.hasNativeMessage = true;
            }
        }
        //check verious condition where the chart shows an message
        //chart not supported
        else if (!(api && api.init) || (api && api.name === 'stub')) {
            hcJSON = new createDialog(container, msgStore.ChartNotSupported);
            vars.hasNativeMessage = true;
        }
        ////if chart has any msg to show
        else if (vars.message) {
            hcJSON = new createDialog(container, vars.message);
            vars.hasNativeMessage = true;
        }
        ////if chart has data loading error
        else if (vars.loadError) {
            hcJSON = new createDialog(container, msgStore.LoadDataErrorText);
            vars.hasNativeMessage = true;
        }
        ////if chart is retriving data
        else if (vars.stallLoad) {
            hcJSON = new createDialog(container, msgStore.XMLLoadingText);
            vars.hasNativeMessage = true;
        }

        else {
            //get the chart JSON
            dataComp = chartObj.getChartData(FusionChartsDataFormats.JSON, true);
            dataObj = dataComp.data;
            ////if chart will show xml parse error
            if (dataComp.error instanceof Error) {
                hcJSON = new createDialog(container, msgStore.InvalidXMLText);
                vars.hasNativeMessage = true;
                if (!suppressDataErrors) {
                    lib.raiseEvent('dataxmlinvalid', {}, vars.fcObj,
                            [vars.fcObj.id]);
                }
            }
            //convert the chart's JSON into HC compatable data
            else {
                if (!suppressDataErrors) {
                    lib.raiseEvent('dataloaded', {}, vars.fcObj,
                            [vars.fcObj.id]);
                }

                // convert it into HC data
                hcJSON = instanceAPI.init(container, dataObj, chartObj, callback);
                vars.previousDrawCount = vars.drawCount; // store old drawcount
                vars.drawCount += 1;

                //if no data to display
                

                if (hcJSON.series.length === 0) {
                    hcJSON = new createDialog(container, msgStore.ChartNoDataText);
                    vars.hasNativeMessage = true;
                    if (!suppressDataErrors) {
                        lib.raiseEvent('nodatatodisplay', {}, vars.fcObj,
                                [vars.fcObj.id]);
                    }
                }
                else {
                    chartObj.__state.dataReady = true;
                    vars.hasNativeMessage = false;
                    delete vars.message;
                }
            }
        }

        if (!hcJSON) {
            hcJSON = new createDialog(container, 'Error rendering chart {0x01}');
            vars.hasNativeMessage = true;
        }
        // configure container
        hcJSON.chart = hcJSON.chart || {};
        hcJSON.chart.renderTo = container;

        

        // store chart api
        // hcJSON.instanceAPI = instanceAPI;

        // configure the credit label
        hcJSON.credits = hcJSON.credits || {};
        hcJSON.credits.enabled = api && api.creditLabel === true ? true : false;

        // predisable animation (when sent as create-chart param during resize)
        if (animate === false) {
            hcJSON.chart.animation = false;

            (hcJSON.plotOptions || (hcJSON.plotOptions = {})) &&
            (hcJSON.plotOptions.series || (hcJSON.plotOptions.series = {}))
            hcJSON.plotOptions.series.animation = false;
        }

        // Check / set bgColor
        if (container.style) {
            hcJSON.chart.containerBackgroundColor = vars.transparent ?
                'transparent' :
                (chartObj.options.containerBackgroundColor || '#ffffff');
        }

        return instanceAPI.draw(hcJSON, callback);
    };

    /////////// few local functions and tools ///////////
    //***if requared then add them to the lib

    //this function will create a default FCC object
    

    var HCstub = lib.HCstub = function (fc, width, height, iapi) {
        var chartAttr = fc.chart,
            marginTop = pluckNumber(chartAttr.charttopmargin,
                    iapi.charttopmargin, 15),
            marginRight = pluckNumber(chartAttr.chartrightmargin,
                    iapi.chartrightmargin, 15),
            marginBottom = pluckNumber(chartAttr.chartbottommargin,
                    iapi.chartbottommargin, 15),
            marginLeft = pluckNumber(chartAttr.chartleftmargin,
                    iapi.chartleftmargin, 15),
            verticalMargin = marginTop + marginBottom,
            horizontalMargin = marginLeft + marginRight,
            maxVMargin = (0.7 * height),
            maxHMargin = (0.7 * width);


        // failsafe in case some user gives an arbitrarily high value for chart margins
        if (verticalMargin > maxVMargin) {
            marginTop -=
                (((verticalMargin - maxVMargin) * marginTop) / verticalMargin);
            marginBottom -=
                (((verticalMargin - maxVMargin) * marginBottom) / verticalMargin);
        }

        if (horizontalMargin > maxHMargin) {
            marginLeft -=
                (((horizontalMargin - maxHMargin) * marginLeft) / horizontalMargin);
            marginRight -=
                (((horizontalMargin - maxHMargin) * marginRight) / horizontalMargin);
        }

        var stubHC = {
            '_FCconf': {
                0 : {
                    stack : {}
                },
                1 : {
                    stack : {}
                },
                x : {
                    stack : {}
                },
                oriCatTmp : [],
                noWrap : false,//wrap a text if there has no space in width
                marginLeftExtraSpace : 0,
                marginRightExtraSpace : 0,
                marginBottomExtraSpace : 0,
                marginTopExtraSpace : 0,
                marimekkoTotal : 0//total for marimekko charts
            },
            chart: {
                alignTicks: false,
                renderTo: BLANKSTRING,
                ignoreHiddenSeries: false,
                events: {
                },
                reflow: false,
                spacingTop: marginTop,
                spacingRight: marginRight,
                spacingBottom: marginBottom,
                spacingLeft: marginLeft,
                marginTop: marginTop,
                marginRight: marginRight,
                marginBottom: marginBottom,
                marginLeft: marginLeft,
                borderRadius: 0,
                plotBackgroundColor : '#FFFFFF',
                style : {},
                animation: !pluckNumber(chartAttr.defaultanimation, 1) ? false : {
                            duration: pluckNumber(chartAttr.animationduration, 1) * 500
                        }
            },
            

            colors: ["AFD8F8", "F6BD0F", "8BBA00", "FF8E46", "008E8E",
            "D64646", "8E468E", "588526", "B3AA00", "008ED6",
            "9D080D", "A186BE", "CC6600", "FDC689", "ABA000",
            "F26D7D", "FFF200", "0054A6", "F7941C", "CC3300",
            "006600", "663300", "6DCFF6"],
            credits: {
                href: 'http://www.fusioncharts.com?BS=FCHSEvalMark',
                text: CREDIT_STRING,
                enabled: true
            },
            global: {},
            labels: {
                items: []
            },
            lang: {},
            legend: {
                enabled : true,
                symbolWidth: 12,
                borderRadius: 1,
                backgroundColor: '#FFFFFF',
                initialItemX : 0,
                title : {
                    text : BLANKSTRING,
                    x : 0,
                    y : 0,
                    padding : 2
                },
                scroll : {},
                itemStyle: {}
            },
            loading: {},
            plotOptions: {
                series: {
                    pointPadding: 0,
                    borderColor : '#333333',
                    events: {},
                    animation: !pluckNumber(chartAttr.animation,
                        chartAttr.defaultanimation, 1) ? false : {
                            duration: pluckNumber(chartAttr.animationduration, 1) * 1000
                    },
                    states: {
                        hover: {
                            enabled: false
                        },
                        select: {
                            enabled: false
                        }
                    },
                    dataLabels : {
                        enabled : true,
                        color: '#555555',
                        style: {},
                        formatter : function () {
                            if(this.point.showPercentValues) {
                                return iapi.numberFormatter.percentValue(this.percentage);
                            }
                            else {
                                return this.point.displayValue;
                            }
                        }
                    },
                    point: {
                        events: {}
                    }
                },
                area: {
                    states: {
                        hover: {
                            enabled: false
                        }
                    },
                    marker: {
                        lineWidth: 1,
                        radius: 3,
                        states: {
                            hover: {
                                enabled: false
                            },
                            select: {
                                enabled: false
                            }
                        }
                    }
                },
                radar: {
                    states: {
                        hover: {
                            enabled: false
                        }
                    },
                    marker: {
                        lineWidth: 1,
                        radius: 3,
                        states: {
                            hover: {
                                enabled: false
                            },
                            select: {
                                enabled: false
                            }
                        }
                    }
                },
                areaspline: {
                    states: {
                        hover: {
                            enabled: false
                        }
                    },
                    marker: {
                        lineWidth: 1,
                        radius: 3,
                        states: {
                            hover: {
                                enabled: false
                            },
                            select: {
                                enabled: false
                            }
                        }
                    }
                },
                line: {
                    shadow: true,

                    states: {
                        hover: {
                            enabled: false
                        }
                    },
                    marker: {
                        lineWidth: 1,
                        radius: 3,
                        states: {
                            hover: {
                                enabled: false
                            },
                            select: {
                                enabled: false
                            }
                        }
                    }
                },
                scatter: {
                    states: {
                        hover: {
                            enabled: false
                        }
                    },
                    marker: {
                        lineWidth: 1,
                        radius: 3,
                        states: {
                            hover: {
                                enabled: false
                            },
                            select: {
                                enabled: false
                            }
                        }
                    }
                },
                bubble: {
                    states: {
                        hover: {
                            enabled: false
                        }
                    },
                    marker: {
                        lineWidth: 1,
                        radius: 3,
                        states: {
                            hover: {
                                enabled: false
                            },
                            select: {
                                enabled: false
                            }
                        }
                    }
                },
                spline: {
                    states: {
                        hover: {
                            enabled: false
                        }
                    },
                    marker: {
                        lineWidth: 1,
                        radius: 3,
                        states: {
                            hover: {
                                enabled: false
                            },
                            select: {
                                enabled: false
                            }
                        }
                    }
                },
                pie: {
                    size: '80%',
                    allowPointSelect: true,
                    cursor: 'pointer',
                    point: {
                        events: {
                            legendItemClick: chartAttr.interactivelegend ===
                            ZEROSTRING ? falseFN  : function () {
                                this.slice();
                            }
                        }
                    }
                },
                pie3d: {
                    size: '80%',
                    allowPointSelect: true,
                    cursor: 'pointer',
                    point: {
                        events: {
                            legendItemClick: chartAttr.interactivelegend ===
                            ZEROSTRING ? falseFN  : function () {
                                this.slice();
                            }
                        }
                    }
                },
                column: {},
                floatedcolumn : {},
                column3d: {},
                bar : {},
                bar3d : {}
            },
            point: {},
            series: [],
            subtitle: {
                text: BLANKSTRING,
                style : {}
            },
            symbols: [],
            title: {
                text : BLANKSTRING,
                style : {}
            },
            toolbar: {},
            tooltip: {
                style: {}
            },
            xAxis: {
                steppedLabels: {
                    style: {}
                },
                labels: {
                    x : 0,
                    style: {},
                    enabled : false
                },
                lineWidth: 0,
                plotLines: [],
                plotBands: [],
                title : {
                    style: {},
                    text: BLANKSTRING
                },
                tickWidth: 0,
                scroll : {
                    enabled : false
                }
            },
            yAxis: [{
                startOnTick: false,
                endOnTick : false,
                title : {
                    style: {},
                    text : BLANKSTRING
                },
                tickLength  : 0,
                labels: {
                    x : 0,
                    style: {}
                },
                plotBands: [],
                plotLines: []
            }, {
                tickLength  : 0,
                gridLineWidth: 0,
                startOnTick: false,
                endOnTick : false,
                title : {
                    style: {},
                    text : BLANKSTRING
                },
                labels: {
                    x: 0,
                    style: {},
                    enabled : false,
                    formatter : function () {
                        if (this.value !== BLANKSTRINGPLACEHOLDER){
                            return this.value;
                        }
                        else {
                            return BLANKSTRING;
                        }
                    }
                },
                opposite: true,
                plotBands: [],
                plotLines: []
            }],
            exporting: {
                buttons: {
                    exportButton: {},
                    printButton: {
                        enabled: false
                    }
                }
            }
        };
        if (chartAttr.palettecolors && typeof chartAttr.palettecolors === 'string') {
            stubHC.colors = chartAttr.palettecolors.split(COMMASTRING);
        }

        iapi.hcJSON = stubHC;

        return stubHC;

    },

    // Block that will configure a y axis (i.e. add min max and create cat
    /**
     * This function will add plotLines and plotBands For gridLine and
     * alrentenGrid Color
     * Added configuartion for not adding auto calculated X axis
     * labels when there has category at the same position
     */
    configureAxis = function (FCChartObj, hcJSON, axisObj,
        axisConf, showLimits, showDivLineValues, labelsStep, numberFormatter,
        isSeconderyAxis, isXaxis, mlAxisIndex) {

        var value,
            min = axisObj.min,
            max = axisObj.max,
            interval = axisObj.tickInterval,
            numFormatterStr = isXaxis ? 'xAxis' : (axisConf.stacking100Percent ?
                'percentValue' :  'yAxis'),
            lastValue = min,
            labelIndex = 1,
            gridLineColor = axisObj.gridLineColor,
            gridLineWidth = axisObj.gridLineWidth,
            gridLineDashStyle = axisObj.gridLineDashStyle,
            hasZeroPlane = min < INT_ZERO && max > INT_ZERO ? true : false,
            minOnLimit = min === INT_ZERO,
            maxOnLimit = max === INT_ZERO,
            userHidesZeroPlaneValue = pluckNumber(axisConf.showzeroplanevalue,
                FCChartObj.showzeroplanevalue) === 0,
            showZeroPlane = true,
            showZeroPlaneValue,
            defaultZIndex = 1,
            forceDivLines = pluckNumber(FCChartObj.numdivlines, 0) > 0,
            axisGridManager = hcJSON[FC_CONFIG_STRING].axisGridManager,
            HCChartObj = hcJSON.chart,
            paletteIndex = HCChartObj.paletteIndex,
            zeroPlaneWidth,
            zeroPlaneColor,
            zeroPlaneDefaultWidth,
            text,
            zeroPlaneDefaultAlpha,
            plotLineOptions;

        //for non-MLAxis charts
        mlAxisIndex = pluckNumber(mlAxisIndex, isSeconderyAxis ? 1 : 0);

        //remove all previous configuration for fresh calculation
        delete axisObj._altGrid;
        delete axisObj._lastValue;

        //for x axis make sure there has catOccupied obj
        if (isXaxis && !axisConf.catOccupied) {
            axisConf.catOccupied = {};
        }

        // create the Zero plane
        if (hasZeroPlane && (!isXaxis || !axisConf.catOccupied[0])) {
            if (isXaxis) {
                showZeroPlane = pluckNumber(FCChartObj.showvzeroplane, 1);
                showZeroPlaneValue = pluckNumber(FCChartObj.showvzeroplanevalue,
                    showDivLineValues);
                zeroPlaneWidth = pluckNumber(FCChartObj.vzeroplanethickness, 1);
                zeroPlaneColor = zeroPlaneWidth > 0 ?
                convertColor(pluck(FCChartObj.vzeroplanecolor,
                    gridLineColor),
                pluck(FCChartObj.vzeroplanealpha, FCChartObj.vdivlinealpha,
                    defaultPaletteOptions.divLineAlpha[paletteIndex]))
                : COLOR_TRANSPARENT;
            }
            else {
                zeroPlaneDefaultAlpha = pluckNumber(FCChartObj.divlinealpha,
                    defaultPaletteOptions.divLineAlpha[paletteIndex]);
                showZeroPlaneValue = pluckNumber(axisConf.showzeroplanevalue,
                    FCChartObj.showzeroplanevalue, showDivLineValues);
                // For spline line and Kagi charts showzeroplane is enabled
                if (this.defaultZeroPlaneHighlighted === false) {
                    showZeroPlane = pluckNumber(axisConf.showzeroplane,
                        FCChartObj.showzeroplane,
                        !(this.defaultZeroPlaneHidden && !forceDivLines));
                    zeroPlaneDefaultWidth = gridLineWidth;
                }
                else {
                    zeroPlaneDefaultWidth = gridLineWidth === 1 ?
                    2 : gridLineWidth;
                    defaultZIndex = 5;
                    zeroPlaneDefaultAlpha *= 2;
                }
                zeroPlaneWidth = pluckNumber(axisConf.zeroplanethickness,
                    FCChartObj.zeroplanethickness,
                    zeroPlaneDefaultWidth);
                zeroPlaneColor = zeroPlaneWidth > 0 ?
                convertColor(pluck(axisConf.zeroplanecolor,
                    FCChartObj.zeroplanecolor, gridLineColor),
                    pluck(axisConf.zeroplanealpha, FCChartObj.zeroplanealpha,
                        zeroPlaneDefaultAlpha)) :
                COLOR_TRANSPARENT;
            }

            if (showZeroPlane) {
                text = showZeroPlaneValue ? numberFormatter[numFormatterStr](0, mlAxisIndex) : BLANKSTRING;
                plotLineOptions = axisGridManager.addAxisGridLine(axisObj, 0, text,
                    zeroPlaneWidth, gridLineDashStyle, zeroPlaneColor,
                    defaultZIndex, isXaxis);
                plotLineOptions && (plotLineOptions.isZeroPlane = true);
            }
        }

        //min label
        if (showLimits === 1 && (!isXaxis || !axisConf.catOccupied[min])) {
            if (minOnLimit && userHidesZeroPlaneValue) {
                text = BLANKSTRING;
            }
            else {
                text = numberFormatter[numFormatterStr](min, mlAxisIndex);
            }
            plotLineOptions = axisGridManager.addAxisGridLine(axisObj, min, text, 0.1, undefined,
                COLOR_TRANSPARENT, 1, isXaxis);
            plotLineOptions && (plotLineOptions.isMinLabel = true);
        }
        //for zero plane  of width 0 make color TRANSPARENT
        if (gridLineWidth <= 0) {
            gridLineWidth = 0.1;
            gridLineColor = COLOR_TRANSPARENT;
        }


        //calculate divLines
        //Issue #1680 fixed using toPrecision
        value = Number(toPrecision(lastValue + interval, 10));
        for (; value < max; value = Number(toPrecision(value + interval, 10)),
            labelIndex += 1) {
            //if the zero plane layes between lastValue and value
            if (hasZeroPlane && lastValue < INT_ZERO && value > INT_ZERO &&
                !isSeconderyAxis) {
                //add altGrid
                axisGridManager.addAxisAltGrid(axisObj, 0);
                labelIndex += 1;
            }
            //if it is not zero plane
            if (value !== INT_ZERO &&
                (!isXaxis || !axisConf.catOccupied[value])) {
                text = showDivLineValues === 1 &&
                labelIndex % labelsStep === INT_ZERO ?
                numberFormatter[numFormatterStr](value, mlAxisIndex) : BLANKSTRING;
                axisGridManager.addAxisGridLine(axisObj, value, text,
                    gridLineWidth, gridLineDashStyle, gridLineColor, 2,
                    isXaxis);
            }
            lastValue = value;
            //add altGrid
            if (!isSeconderyAxis) {
                axisGridManager.addAxisAltGrid(axisObj, value);
            }
        }
        //add altGrid
        if (!isSeconderyAxis) {
            axisGridManager.addAxisAltGrid(axisObj, max);
        }

        //max label
        if (showLimits === 1 && labelIndex % labelsStep === INT_ZERO &&
            (!isXaxis || !axisConf.catOccupied[max])) {
            if (maxOnLimit && userHidesZeroPlaneValue) {
                text = BLANKSTRING;
            }
            else {
                text = numberFormatter[numFormatterStr](max, mlAxisIndex);
            }
            plotLineOptions = axisGridManager.addAxisGridLine(axisObj, max, text, 0.1,
                gridLineDashStyle, COLOR_TRANSPARENT, 2, isXaxis);
            plotLineOptions && (plotLineOptions.isMaxLabel = true);
        }
        //store the default value to use in realtime update
        if (this.realtimeEnabled) {
            axisObj.labels._enabled = axisObj.labels.enabled;
            axisObj._gridLineWidth = axisObj.gridLineWidth;
            axisObj._alternateGridColor = axisObj.alternateGridColor;
        }
        //disable default labels and grid
        axisObj.labels.enabled = false;
        axisObj.gridLineWidth = INT_ZERO;
        axisObj.alternateGridColor = COLOR_TRANSPARENT;

        // sorting yAxis to fix negative values in bar chart
        axisObj.plotLines.sort(plotLineSortFN);
    },

    //this function will configure the axis and calculate the originaly space requared for the axis eliments
    

    yxAxisConfigurer = function (HCObj, FCObj) {
        var conf = HCObj[FC_CONFIG_STRING], xAxisObj = HCObj.xAxis, xConf = conf.x,
        FCchartObj = FCObj.chart,
        is3D = HCObj.chart.is3D,
        yAxisObj, i, len, yAxisConf, yAxisMaxValue, yAxisMinValue, stopMaxAtZero,
        setMinAsZero, setadaptiveymin,
        numDivLines, adjustDiv, showYAxisValues, showLimits, showDivLineValues,
        showAxisLines = 0, //defaults to zero.
        showYAxisLine, showXAxisLine, showSYAxisLine,
        axisLineColor, xAxisLineColor, yAxisLineColor, sYAxisLineColor,
        axisLineThickness, xAxisLineThickness, yAxisLineThickness, sYAxisLineThickness,
        numberFormatter = this.numberFormatter,
        syncAxisLimits = pluckNumber(FCchartObj.syncaxislimits, 0),
        yaxisvaluesstep,
        sAxisMaxValue,
        sAxisMinValue,
        sAxisConf,
        pAxisObj,
        sMin,
        sMax;

        /**
         * configure x axis
         */

        //add xaxisTitle
        xAxisObj.title.text = parseUnsafeString(FCchartObj.xaxisname);

        /**
         * configure y axis
         */

        yaxisvaluesstep = pluckNumber(parseInt(FCchartObj.yaxisvaluesstep, 10), parseInt(FCchartObj.yaxisvaluestep, 10), 1);
        yaxisvaluesstep = yaxisvaluesstep < 1 ? 1 : yaxisvaluesstep;


        yAxisObj = HCObj.yAxis[0], yAxisConf = conf[0];
        if (conf.isDual) {//Dual

            yAxisMaxValue = numberFormatter.getCleanValue(FCchartObj.pyaxismaxvalue);
            yAxisMinValue = numberFormatter.getCleanValue(FCchartObj.pyaxisminvalue);

            // add axis Names
            yAxisObj.title.text = parseUnsafeString(FCchartObj.pyaxisname);

            //fix for #FCXT-169
            if (syncAxisLimits && !yAxisConf.stacking100Percent) {
                sAxisConf = conf[1];
                sMax = pluckNumber(sAxisConf.max);
                sMin = pluckNumber(sAxisConf.min);
                //set max data range
                if (sMax !== undefined && sMin !== undefined) {
                    yAxisConf.min = mathMin(yAxisConf.min, sMin);
                    yAxisConf.max = mathMax(yAxisConf.max, sMax);
                }
                sAxisMaxValue = numberFormatter.getCleanValue(FCchartObj.syaxismaxvalue);
                sAxisMinValue = numberFormatter.getCleanValue(FCchartObj.syaxisminvalue);
                if (sAxisMinValue !== null) {
                    yAxisMinValue = yAxisMinValue !== null ? mathMin(yAxisMinValue, sAxisMinValue) : sAxisMinValue;
                }
                if (sAxisMaxValue !== null) {
                    yAxisMaxValue = yAxisMaxValue !== null ? mathMax(yAxisMaxValue, sAxisMaxValue) : sAxisMaxValue;
                }
            }
            else {
                syncAxisLimits = 0;//catch the case of stacking100Percent
            }
        }
        else {//single
            yAxisMaxValue = numberFormatter.getCleanValue(FCchartObj.yaxismaxvalue);
            yAxisMinValue = numberFormatter.getCleanValue(FCchartObj.yaxisminvalue);

            // add axis Names
            yAxisObj.title.text = parseUnsafeString(FCchartObj.yaxisname);
        }

        // adaptiveymin is available for non-stack charts
        setadaptiveymin = pluckNumber(this.isStacked ? 0 : this.setAdaptiveYMin, FCchartObj.setadaptiveymin, 0);

        setMinAsZero = stopMaxAtZero = !setadaptiveymin;
        numDivLines = pluckNumber(conf.numdivlines, FCchartObj.numdivlines, this.numdivlines, 4);
        adjustDiv = FCchartObj.adjustdiv !== ZEROSTRING;
        showYAxisValues = pluckNumber(this.showYAxisValues, FCchartObj.showyaxisvalues,
            FCchartObj.showyaxisvalue, 1);
        showLimits = pluckNumber(FCchartObj.showlimits, showYAxisValues);
        showDivLineValues = pluckNumber(FCchartObj.showdivlinevalue, FCchartObj.showdivlinevalues,
            showYAxisValues);

        //check whether to show lines for the axis.
        //Only for the non-3D charts.
        if(!is3D){
            showAxisLines = pluckNumber(FCchartObj.showaxislines, FCchartObj.drawAxisLines, 0);
            showYAxisLine = yAxisObj.showLine = pluckNumber(FCchartObj.showyaxisline, showAxisLines);
            showXAxisLine = xAxisObj.showLine = pluckNumber(FCchartObj.showxaxisline, showAxisLines);
            axisLineColor = convertColor(pluck(FCchartObj.axislinecolor, '#000000'));
            xAxisLineColor = xAxisObj.lineColor = convertColor(pluck(FCchartObj.xaxislinecolor, axisLineColor));
            yAxisLineColor = yAxisObj.lineColor = convertColor(pluck(FCchartObj.yaxislinecolor, axisLineColor));
            axisLineThickness = pluckNumber(FCchartObj.axislinethickness, 1);
            xAxisLineThickness = xAxisObj.lineThickness =
                        pluckNumber(FCchartObj.xaxislinethickness, axisLineThickness);
            yAxisLineThickness = yAxisObj.lineThickness =
                        pluckNumber(FCchartObj.yaxislinethickness, axisLineThickness);
        }

        //////////////////////calculate the axis min max and the div interval for y axis ///////////////////
        this.axisMinMaxSetter (yAxisObj, yAxisConf, yAxisMaxValue, yAxisMinValue, stopMaxAtZero,
            setMinAsZero, numDivLines, adjustDiv);

        // create label category and remove trend obj if out side limit
        this.configurePlotLines(FCchartObj, HCObj, yAxisObj, yAxisConf, showLimits, showDivLineValues,
            yaxisvaluesstep, conf.numberFormatter, false);

        if (yAxisObj.reversed && yAxisObj.min >= 0) {
            HCObj.plotOptions.series.threshold = yAxisObj.max;
        }


        //manage secondary axis ////////
        if (conf.isDual) {
            yAxisObj = HCObj.yAxis[1];
            yAxisConf = conf[1];
            showLimits = pluckNumber(FCchartObj.showsecondarylimits, showLimits);
            showDivLineValues = pluckNumber(FCchartObj.showdivlinesecondaryvalue, showYAxisValues);

            if (syncAxisLimits) {
                pAxisObj = HCObj.yAxis[0];
                yAxisObj.min = pAxisObj.min;
                yAxisObj.max = pAxisObj.max;
                yAxisObj.tickInterval = pAxisObj.tickInterval;

                // Delete the min max.
                delete yAxisConf.max;
                delete yAxisConf.min;
            }
            else {
                yAxisMaxValue = numberFormatter.getCleanValue(FCchartObj.syaxismaxvalue);
                yAxisMinValue = numberFormatter.getCleanValue(FCchartObj.syaxisminvalue);
                setadaptiveymin = pluckNumber(FCchartObj.setadaptivesymin, setadaptiveymin);
                setMinAsZero = stopMaxAtZero = !setadaptiveymin;
                //////////////////////calculate the axis min max and the div interval for y axis ///////////////////
                this.axisMinMaxSetter (yAxisObj, yAxisConf, yAxisMaxValue, yAxisMinValue, stopMaxAtZero,
                    setMinAsZero, numDivLines, adjustDiv);
            }

            //check whether secondary axis line needs to be shown (non-3D charts)
            if(!is3D){
                showSYAxisLine = yAxisObj.showLine = pluckNumber(FCchartObj.showsyaxisline, showAxisLines);
                sYAxisLineColor = yAxisObj.lineColor =
                        convertColor(pluck(FCchartObj.syaxislinethickness, axisLineColor));
                sYAxisLineThickness = yAxisObj.lineThickness =
                        pluckNumber(FCchartObj.syaxislinethickness, axisLineThickness);
            }

            // create label category and remove trend obj if out side limit
            this.configurePlotLines(FCchartObj, HCObj, yAxisObj, yAxisConf, showLimits, showDivLineValues,
                yaxisvaluesstep, conf.numberFormatter, true);

            // add axis Names
            yAxisObj.title.text = parseUnsafeString(FCchartObj.syaxisname);
        }

    },

    pointValueWatcher = function (HCObj, value, yAxisIndex, isStacked, index,
        stackIndex, seriesName) {


        if ( value !== null) {
            var obj, stackObj, FCconf = HCObj[FC_CONFIG_STRING],
                oldStackReturn;
            yAxisIndex = pluckNumber(yAxisIndex, 0);

            if (!FCconf[yAxisIndex]) {
                FCconf[yAxisIndex] = {};
            }
            obj = FCconf[yAxisIndex];
            if (isStacked) {
                if (this.distributedColumns) {
                    FCconf.marimekkoTotal += value;
                }

                stackObj = obj.stack;
                var seriesArr, seriesStackArr, pointIndexObj;
                index = pluckNumber(index, 0);
                stackIndex = pluckNumber(stackIndex, 0);
                seriesName = pluck(seriesName, STRINGUNDEFINED);
                if (!stackObj[seriesName]) {
                    stackObj[seriesName] = [];
                }
                seriesArr = stackObj[seriesName];

                if (!seriesArr[stackIndex]) {
                    seriesArr[stackIndex] = [];
                }
                seriesStackArr = seriesArr[stackIndex];
                if (!seriesStackArr[index]) {
                    seriesStackArr[index] = {};
                }
                pointIndexObj = seriesStackArr[index];

                if (value >= 0) {
                    if (pointIndexObj.p) {
                        oldStackReturn = pointIndexObj.p;
                        value =  pointIndexObj.p += value;
                    }
                    else {
                        pointIndexObj.p = value;
                    }
                }
                else {
                    if (pointIndexObj.n) {
                        oldStackReturn = pointIndexObj.n;
                        value =  pointIndexObj.n += value;
                    }
                    else {
                        pointIndexObj.n = value;
                    }
                }


            }
            obj.max = obj.max > value ? obj.max : value;
            obj.min = obj.min < value ? obj.min : value;

            return oldStackReturn;
        }
    },

    /*
     *this function will place a vertical axis
     *this function will return the used width
     */
    placeVerticalAxis = lib.placeVerticalAxis = function (axisObj, axisConf,
        hcJSON, fcJSON, axisHeight, maxWidthCanUse, isOnRight, isDual, chartWidth, marginUsed) {

        var conf = hcJSON[FC_CONFIG_STRING],
            fcJSONChart = fcJSON.chart,

        SmartLabel = conf.smartLabel, smartifiedTextObj,

        titleWidth, titleHeight, titleText, titleLineHeight, titleMinWidth,
        titleWidthUsed = 0, minTextWidth = 20,

        marginRightExtraSpace = conf.marginRightExtraSpace,
        marginLeftExtraSpace = conf.marginLeftExtraSpace,
        setBorderWidth = conf.plotBorderThickness,

        pSameSideGridText = {}, pSameSideNonGridText = {}, pOppSideText = {},
        plotLines = axisObj.plotLines,
        plotBands = axisObj.plotBands,

        verticalAxisValuesPadding = axisConf.verticalAxisValuesPadding,
        fixedValuesPadding = (!isNaN(axisConf.fixedValuesPadding) ?
            axisConf.fixedValuesPadding : 0),
        flexibleValuesPadding = verticalAxisValuesPadding - fixedValuesPadding,
        verticalAxisOppValuesPadding = axisConf.verticalAxisValuesPadding,
        verticalAxisNamePadding = axisConf.verticalAxisNamePadding,
        verticalAxisNameWidth = axisConf.verticalAxisNameWidth,

        isTitleRotate = axisConf.rotateVerticalAxisName,
        axisOffset = (axisObj.offset ? axisObj.offset : 0),

        axisSameSideWidth = 0, axisOppSideWidth = 0, surplusWidth = 0,
        labelTotal = 0, samesideText = 0, oppText = 0, samesideLabelWidth = 0,

        index, length, lastUsedStyle, plotObj, labelObj, tempRight,
        tempLeft, difference, temp, lessPadding, heightCorrection = 2, unit,
        titleCorrection = (isOnRight ? marginRightExtraSpace + 8 : marginLeftExtraSpace + 4),

        analyseAxisElements = function (plotObj, index) {
            var textActualWidth, textWidthWithPadding;
            if (plotObj && plotObj.label && getValidValue(plotObj.label.text) !== undefined) {
                labelObj = plotObj.label;
                //if the style not implemented then implement it
                if (labelObj.style && labelObj.style !== lastUsedStyle) {
                    lastUsedStyle = labelObj.style;
                    SmartLabel.setStyle(lastUsedStyle);
                }
                //get the text Size
                smartifiedTextObj = SmartLabel.getOriSize(plotObj.label.text);
                textActualWidth = smartifiedTextObj.width;
                textWidthWithPadding = textActualWidth ? (textActualWidth + 2) : 0;
                if (plotObj.isGrid) {
                    pSameSideGridText[index] = {
                        width : textActualWidth,
                        height: smartifiedTextObj.height,
                        label : labelObj
                    };
                    if (labelTotal <= textWidthWithPadding) {
                        labelTotal = textWidthWithPadding;
                        axisConf.lYLblIdx = index;
                    }

                } else if (plotObj.isTrend) {
                    if ((isOnRight && labelObj.textAlign === POSITION_LEFT) ||
                        (labelObj.textAlign === POSITION_RIGHT)) {
                        pSameSideNonGridText[index] = {
                            width : textActualWidth,
                            height: smartifiedTextObj.height,
                            label : labelObj
                        };
                        samesideText = mathMax(samesideText, textWidthWithPadding);
                    } else {
                        pOppSideText[index] = {
                            width : textActualWidth,
                            height: smartifiedTextObj.height,
                            label : labelObj
                        };
                        oppText = mathMax(oppText, textWidthWithPadding);
                    }
                }
            }
        },

        checkAndReallocateSpace = function () {
            // There has not sufficient space
            if (axisOppSideWidth + axisSameSideWidth > maxWidthCanUse) {
                difference = axisOppSideWidth + axisSameSideWidth - maxWidthCanUse;

                if (axisOppSideWidth) {
                    if (verticalAxisOppValuesPadding >= difference) {
                        verticalAxisOppValuesPadding -= difference
                        return;
                    } else {
                        difference -= verticalAxisOppValuesPadding;
                        verticalAxisOppValuesPadding = 0;
                    }
                }

                if ((flexibleValuesPadding + verticalAxisNamePadding) >= difference) {
                    if (verticalAxisNamePadding >= difference) {
                        verticalAxisNamePadding -= difference;
                        return;
                    } else {
                        flexibleValuesPadding -= (difference - verticalAxisNamePadding);
                        verticalAxisNamePadding = 0;
                        return
                    }
                } else {
                    difference -= (flexibleValuesPadding + verticalAxisNamePadding);
                    flexibleValuesPadding = 0;
                    verticalAxisNamePadding = 0;

                    if (oppText > minTextWidth) {
                        if (samesideText > labelTotal) {
                            if ((oppText - samesideText) >= difference) {
                                oppText -= difference;
                                return;
                            } else if ((samesideText - oppText) >= difference) {
                                samesideText -= difference;
                                return;
                            } else {
                                if (samesideText > oppText) {
                                    difference -= (samesideText - oppText);
                                    samesideText = oppText;
                                } else {
                                    difference -= (oppText - samesideText);
                                    oppText = samesideText;
                                }

                                if (2 * (samesideText - labelTotal) >= difference) {
                                    oppText -= (difference / 2);
                                    samesideText -= (difference / 2);
                                    return;
                                } else {
                                    difference -= 2 * (samesideText - labelTotal);
                                    samesideText = labelTotal;
                                    oppText = labelTotal;
                                }
                            }
                        } else if ((oppText - minTextWidth) >= difference) {
                            oppText -= difference;
                            return;
                        } else {
                            difference -= (oppText - minTextWidth);
                            oppText = minTextWidth;
                        }
                    }

                    if (samesideText > labelTotal) {
                        if ((samesideText - labelTotal) >= difference) {
                            samesideText -= difference;
                            return;
                        } else {
                            difference -= (samesideText - labelTotal);
                            samesideText = labelTotal;
                        }
                    }

                    if (titleWidthUsed - titleMinWidth >= difference) {
                        titleWidthUsed -= difference;
                        return;
                    } else {
                        difference -= (titleWidthUsed - titleMinWidth);
                        titleWidthUsed = titleMinWidth;

                        if (oppText >= difference) {
                            oppText = 0;
                            return;
                        } else {
                            difference -= oppText;
                            oppText = 0;
                        }

                        if (titleWidthUsed >= difference) {
                            titleWidthUsed = 0;
                            return;
                        } else {
                            difference -= titleWidthUsed;
                            titleWidthUsed = 0;
                        }

                        if (labelTotal >= difference) {
                            labelTotal -= difference;
                            samesideText = labelTotal;
                            return;
                        }
                    }
                }
            }
            return;
        },

        renderOppSideText = function (surplusWidth, isBubble) {
            //place the axis labels
            var tempSmartLabel, maxActualWidth = 0,
            workingWidth = isBubble ? (oppText - 2) : (oppText + surplusWidth - 2);

            if (oppText > 0) {
                for (index in pOppSideText) {
                    labelObj = pOppSideText[index].label;
                    if (pOppSideText[index].width > workingWidth) {
                        if (labelObj.style && labelObj.style !== lastUsedStyle) {
                            lastUsedStyle = labelObj.style;
                            SmartLabel.setStyle(lastUsedStyle);
                        }
                        tempSmartLabel = SmartLabel.getSmartText(labelObj.text,
                            workingWidth, axisHeight, true);
                        labelObj.text = tempSmartLabel.text;
                        tempSmartLabel.tooltext && (labelObj.originalText = tempSmartLabel.tooltext);

                        pOppSideText[index].height = tempSmartLabel.height;
                        maxActualWidth = Math.max(maxActualWidth, tempSmartLabel.width);
                    } else {
                        maxActualWidth = Math.max(maxActualWidth, pOppSideText[index].width);
                    }
                }
                return (isBubble ? (workingWidth - maxActualWidth) + surplusWidth
                    : (workingWidth - maxActualWidth));

            } else {
                for (index in pOppSideText) {
                    pOppSideText[index].label.text = BLANKSTRING;
                }
                return 0;
            }
        },

        renderTitle = function (surplusWidth, isBubble) {

            var actualWidth, workingWidth = isBubble ? titleWidthUsed
            : (titleWidthUsed + surplusWidth);

            // Fix for issue #FCXT-329
            titleText = titleText || {};

            if (workingWidth > 0) {
                if (isTitleRotate){
                    if (workingWidth < titleText.height) {
                        //now get the title space
                        titleText = SmartLabel.getSmartText(axisObj.title.text, axisHeight, workingWidth);
                    }
                    actualWidth = titleText.height;
                }
                else {
                    if (workingWidth < titleText.width) {
                        titleText = SmartLabel.getSmartText(axisObj.title.text, workingWidth, axisHeight);
                    }
                    actualWidth = titleText.width;
                }
                axisObj.title.text = titleText.text;
                titleText.tooltext && (axisObj.title.originalText = titleText.tooltext);

                return (isBubble ? (workingWidth - actualWidth) + surplusWidth
                    : (workingWidth - actualWidth));
            } else {
                //remove the text
                axisObj.title.text = BLANKSTRING;
                return 0;
            }
        },

        renderSameSideText = function (surplusWidth) {
            //place the axis labels
            var tempSmartLabel, maxActualWidth = 0,
            workingWidth = (Math.max(labelTotal, samesideText) + surplusWidth - 2);

            if (workingWidth > 0) {
                for (index in pSameSideGridText) {
                    labelObj =  pSameSideGridText[index].label;
                    if (pSameSideGridText[index].width > workingWidth) {
                        if (labelObj.style && labelObj.style !== lastUsedStyle) {
                            lastUsedStyle = labelObj.style;
                            SmartLabel.setStyle(lastUsedStyle);
                        }
                        tempSmartLabel = SmartLabel.getSmartText(labelObj.text, workingWidth,
                            axisHeight, true);
                        labelObj.text = tempSmartLabel.text;
                        tempSmartLabel.tooltext && (labelObj.originalText = tempSmartLabel.tooltext);

                        pSameSideGridText[index].height = tempSmartLabel.height;
                        maxActualWidth = Math.max(maxActualWidth, tempSmartLabel.width);
                    } else {
                        maxActualWidth = Math.max(maxActualWidth, pSameSideGridText[index].width);
                    }
                }

                for (index in pSameSideNonGridText) {
                    labelObj =  pSameSideNonGridText[index].label;
                    if (pSameSideNonGridText[index].width > workingWidth) {
                        if (labelObj.style && labelObj.style !== lastUsedStyle) {
                            lastUsedStyle = labelObj.style;
                            SmartLabel.setStyle(lastUsedStyle);
                        }
                        tempSmartLabel = SmartLabel.getSmartText(labelObj.text, workingWidth,
                            axisHeight, true);
                        labelObj.text = tempSmartLabel.text;
                        tempSmartLabel.tooltext && (labelObj.originalText = tempSmartLabel.tooltext);

                        pSameSideNonGridText[index].height = tempSmartLabel.height;
                        maxActualWidth = Math.max(maxActualWidth, tempSmartLabel.width);
                    } else {
                        maxActualWidth = Math.max(maxActualWidth, pSameSideNonGridText[index].width);
                    }
                }

                return (workingWidth - maxActualWidth);
            } else {
                for (index in pSameSideGridText) {
                    pSameSideGridText[index].label.text = BLANKSTRING;
                }

                for (index in pSameSideNonGridText) {
                    pSameSideNonGridText[index].label.text = BLANKSTRING;
                }

                return 0;
            }
        },

        setLabelsXY = function (labelContainerObj, x, y) {
            var index;
            for (index in labelContainerObj) {
                labelContainerObj[index].label.x = x;
                labelContainerObj[index].label.y = y;
            }
        };

        //iterate through plotLines and find the divlines
        for (index = 0, length = plotBands.length; index < length; index += 1) {
            analyseAxisElements(plotBands[index], index);
        }

        //iterate through plotLines and find the divlines
        for (index = 0, length = plotLines.length; index < length; index += 1) {
            analyseAxisElements(plotLines[index], index);
        }

        if (axisObj.title && axisObj.title.text != BLANKSTRING) {
            lastUsedStyle = axisObj.title.style;
            SmartLabel.setStyle(lastUsedStyle);
            //now get the title space
            titleLineHeight = SmartLabel.getOriSize(TESTSTR).height;
            if (isTitleRotate) {
                titleWidth = axisHeight;
                titleHeight = maxWidthCanUse;
                titleText = SmartLabel.getSmartText(axisObj.title.text, titleWidth, titleHeight);
                titleWidthUsed = titleText.height;
                titleMinWidth = titleLineHeight;
            } else {
                axisObj.title.rotation = 0;
                titleWidth = verticalAxisNameWidth !== undefined ?
                    verticalAxisNameWidth : maxWidthCanUse;
                titleHeight = axisHeight;
                titleText = SmartLabel.getSmartText(axisObj.title.text, titleWidth, titleHeight);
                titleWidthUsed = titleText.width;
                titleMinWidth = minTextWidth;
            }
        }

        if (oppText > 0) {
            axisOppSideWidth = oppText + verticalAxisOppValuesPadding;
        }

        if (chartWidth) { // is a bar chart
            var maxLabelWidth, mlwp = pluckNumber(fcJSON.chart.maxlabelwidthpercent, 0);
            if (mlwp >= 1 && mlwp <= 100) {
                maxLabelWidth = (mlwp * chartWidth / 100);
                if (labelTotal > maxLabelWidth) {
                    labelTotal = maxLabelWidth;
                }
            }
        }

        axisSameSideWidth = mathMax(samesideText, labelTotal);
        axisSameSideWidth += (axisSameSideWidth ? (flexibleValuesPadding + fixedValuesPadding) : 0);

        if (titleWidthUsed > 0) {
            axisSameSideWidth += (titleWidthUsed + verticalAxisNamePadding + titleCorrection);
        }

        checkAndReallocateSpace();

        surplusWidth = renderOppSideText(0, true);
        surplusWidth = renderTitle(surplusWidth, true);
        surplusWidth = renderSameSideText(surplusWidth);
        surplusWidth = renderTitle(surplusWidth);

        lessPadding = axisConf.verticalAxisNamePadding - verticalAxisNamePadding;
        if (surplusWidth && lessPadding) {
            if (surplusWidth > lessPadding) {
                verticalAxisNamePadding += lessPadding;
                surplusWidth -= lessPadding;
            } else {
                verticalAxisNamePadding += surplusWidth;
                surplusWidth = 0;
            }
        }

        lessPadding = axisConf.verticalAxisValuesPadding - (flexibleValuesPadding + fixedValuesPadding);
        if ( surplusWidth && lessPadding) {
            if (surplusWidth > lessPadding) {
                flexibleValuesPadding += lessPadding;
                surplusWidth -= lessPadding;
            } else {
                flexibleValuesPadding += surplusWidth;
                surplusWidth = 0;
            }
        }

        lessPadding = axisConf.verticalAxisValuesPadding - verticalAxisOppValuesPadding;
        if ( surplusWidth && lessPadding) {
            if (surplusWidth > lessPadding) {
                verticalAxisOppValuesPadding += lessPadding;
                surplusWidth -= lessPadding;
            } else {
                verticalAxisOppValuesPadding += surplusWidth;
                surplusWidth = 0;
            }
        }

        if (oppText > 0) {
            axisOppSideWidth = oppText + verticalAxisOppValuesPadding;
        }

        axisSameSideWidth = mathMax(samesideText, labelTotal);
        axisSameSideWidth += (axisSameSideWidth ? (flexibleValuesPadding + fixedValuesPadding) : 0);

        if (titleWidthUsed > 0) {
            axisSameSideWidth += (titleWidthUsed + verticalAxisNamePadding + titleCorrection);
        }

        //all element's space is calculated now place them
        temp = mathMax(samesideText, labelTotal);
        temp += (temp > 0 ? (flexibleValuesPadding + fixedValuesPadding) : 0);

        //place title
        //**don't update the style as it is the last used style
        if (titleWidthUsed > 0) {

            if (isTitleRotate){
                if (titleWidthUsed < titleText.height) {
                    //now get the title space
                    titleText = SmartLabel.getSmartText(axisObj.title.text, axisHeight, titleWidthUsed);
                }

            }
            else {
                if (titleWidthUsed < titleText.width) {
                    titleText = SmartLabel.getSmartText(axisObj.title.text, titleWidthUsed, axisHeight);
                }
                axisObj.title.y = - ((titleText.height - titleLineHeight) / 2); // 4 is for <br/> correction
            }
            axisObj.title.text = titleText.text;
            titleText.tooltext && (axisObj.title.originalText = titleText.tooltext);

            // TitleCorrection: 8 is a correction factor that had to be introduced after migration to ex-renderer 2.1.9.
            axisObj.title.margin = temp + verticalAxisNamePadding + titleCorrection + (isTitleRotate ? titleWidthUsed -
                titleLineHeight : titleWidthUsed / 2);
        }
        else {
            //remove the text
            axisObj.title.text = BLANKSTRING;
        }

        /*
         *new logic: store only the text width of plotlines and the plot bands
         *during final sizing zust loop through the plotLined and the plot
         *Band then decide it is label/same text/ opp text
         *then configure it
         */
        tempLeft = -(flexibleValuesPadding + fixedValuesPadding + axisOffset + marginLeftExtraSpace + 2);//text padding 2px
        tempRight = marginRightExtraSpace + verticalAxisOppValuesPadding + axisOffset + 2;//text padding 2px
        samesideLabelWidth = mathMax(samesideText, labelTotal);
        if (axisObj.labels.style) {
            heightCorrection = parseInt(axisObj.labels.style.fontSize, 10) * 0.35;
        }

        //place the axis labels
        if (isOnRight) {
            if (oppText > 0) {
                setLabelsXY(pOppSideText, tempLeft, heightCorrection);
            }

            if (samesideLabelWidth > 0) {
                setLabelsXY(pSameSideGridText, tempRight, heightCorrection);
                setLabelsXY(pSameSideNonGridText, tempRight, heightCorrection);
            }
        } else {
            if (oppText > 0) {
                setLabelsXY(pOppSideText, tempRight, heightCorrection);
            }

            if (samesideLabelWidth > 0) {
                setLabelsXY(pSameSideGridText, tempLeft, heightCorrection);
                setLabelsXY(pSameSideNonGridText, tempLeft, heightCorrection);
            }
        }

        //fix for #FWXT-781
        axisObj.labels._textY = heightCorrection;
        axisObj.labels._righttX = tempRight;
        axisObj.labels._leftX = tempLeft;

        if (marginUsed) {
            hcJSON.chart.marginLeft += isOnRight ? axisOppSideWidth : (axisSameSideWidth - marginUsed);
            hcJSON.chart.marginRight += isOnRight ? (axisSameSideWidth - marginUsed) : axisOppSideWidth;
        } else {
            hcJSON.chart.marginLeft += isOnRight ? axisOppSideWidth : axisSameSideWidth;
            hcJSON.chart.marginRight += isOnRight ? axisSameSideWidth : axisOppSideWidth;
        }
        return axisOppSideWidth + axisSameSideWidth;

    },

    /*
     *This function willplace the title to a speciffied width & height
     */
    titleSpaceManager = lib.titleSpaceManager = function (hcJSON, fcJSON, canvasWidth,
        allowedHeight) {
        var fcChartObj = fcJSON.chart, titleText = parseUnsafeString(fcChartObj.caption),
        subTitleText = parseUnsafeString(fcChartObj.subcaption), captionPadding, oriCapPadding =
        captionPadding = pluckNumber(fcChartObj.captionpadding, 10), conf = hcJSON[FC_CONFIG_STRING],
        SmartLabel = conf.smartLabel, isPaddingReduced = false, captionObj,
        subcaptionObj, totalHeight = 0, capStyle, subCapStyle, difference = 0,
        extraSpace = 0, captionLineHeight = 0, subCaptionLineHeight = 0,
        subCaptionFontSize = 0, captionFontSize = 0,
        titleObj = hcJSON.title, subTitleObj = hcJSON.subtitle,
        canvasBorderThickness = pluckNumber(fcChartObj.canvasborderthickness, 1);

        if (captionPadding < canvasBorderThickness) {
            captionPadding = canvasBorderThickness;
        }

        if (titleText !== BLANKSTRING) {//calculatethe single line's height
            capStyle = titleObj.style;
            captionLineHeight = pluckNumber(parseInt(capStyle.fontHeight, 10), parseInt(capStyle.lineHeight, 10), 12);
            captionFontSize = pluckNumber(parseInt(capStyle.fontSize, 10), 10);
        }
        if (subTitleText !== BLANKSTRING) {
            subCapStyle = subTitleObj.style;
            subCaptionLineHeight = pluckNumber(parseInt(subCapStyle.fontHeight, 10), parseInt(subCapStyle.lineHeight, 10), 12);
            subCaptionFontSize = pluckNumber(parseInt(subCapStyle.fontSize, 10), 10);
        }

        if (captionLineHeight > 0 || subCaptionLineHeight > 0) {
            //calculate the min height requared

            totalHeight = captionLineHeight + subCaptionLineHeight + captionPadding;
            //now decide whether it has space shgaortfall or excess
            if (totalHeight > allowedHeight) {
                difference = totalHeight - allowedHeight;
                isPaddingReduced = true;
                //first reduce the padding
                if (difference < captionPadding) {
                    captionPadding -= difference;
                }
                else {//if the difference is more then padding then remove the subcap also
                    difference -= captionPadding;
                    captionPadding = 0;
                    //if the subcap is gretter then diff add the remaning space to the extraSpace
                    if (subCaptionLineHeight > difference) {
                        extraSpace = (subCaptionLineHeight - difference) + 10;
                        subCaptionLineHeight = 0;
                    }
                    else {
                        difference -= subCaptionLineHeight;
                        subCaptionLineHeight = 0;
                        //now remove the caption also
                        if (captionLineHeight > difference) {
                            extraSpace = captionLineHeight - difference;
                        }
                        captionLineHeight = 0;
                        difference = 0;
                    }
                }
            }
            else {
                extraSpace = allowedHeight - totalHeight;
            }

            ////// now place the elements

            if (captionLineHeight > 0) {
                //set the caption style and get the caption's requared space
                SmartLabel.setStyle(capStyle);
                captionLineHeight += extraSpace;
                captionObj = SmartLabel.getSmartText(titleText, canvasWidth, captionLineHeight);
                extraSpace = captionLineHeight - captionObj.height;
                captionLineHeight = captionObj.height;
                titleObj.text = captionObj.text;
                titleObj.height = captionObj.height;
                captionObj.tooltext && (titleObj.originalText = captionObj.tooltext);

                //titleObj.y = (captionLineHeight / 2) + hcJSON.chart.marginTop;
            }
            if (subCaptionLineHeight > 0) {
                //set the caption style and get the caption's requared space
                SmartLabel.setStyle(subCapStyle);
                subCaptionLineHeight += extraSpace;
                subcaptionObj = SmartLabel.getSmartText(subTitleText, canvasWidth, subCaptionLineHeight);
                extraSpace = subCaptionLineHeight - subcaptionObj.height;
                subCaptionLineHeight = subcaptionObj.height;
                subTitleObj.text = subcaptionObj.text;
                subTitleObj.height = subcaptionObj.height;
                subcaptionObj.tooltext && (titleObj.originalText = captionObj.tooltext);

                //subTitleObj.y = (subCaptionLineHeight / 2) + captionLineHeight + hcJSON.chart.marginTop;
            }
            if (isPaddingReduced && extraSpace > 0) {
                captionPadding += mathMin(oriCapPadding - captionPadding, extraSpace);
            }
            ////now add the top margin
            totalHeight = captionLineHeight + subCaptionLineHeight + captionPadding;
            hcJSON.chart.marginTop += totalHeight;
        }
        return totalHeight;
    },

    

    stepYAxisNames = lib.stepYAxisNames = function (canvasHeight, hcJSON, fcJSONChart, axisObj, labelIdx, isBar) {
        var i = 0, plotLines = axisObj.plotLines, gridLines = [], startIdx, marker,
        length = axisObj.plotLines.length, plotObj, stepValue, perLabelHeight,
        testStr = 'W', SmartLabel = hcJSON[FC_CONFIG_STRING].smartLabel, lineHeight,
        fontSize = parseFloat(pluckFontSize(fcJSONChart.basefontsize, 10)), prevPlot;

        for (; i < length; i += 1) {
            plotObj = plotLines[i];
            if (plotObj.isGrid && plotObj.label && plotObj.label.text) {
                gridLines.push(plotObj);
                if (plotObj.value === 0) {
                    startIdx = gridLines.length - 1;
                }
            }
        }

        length = gridLines.length;

        if (length) {
            if (axisObj.labels.style) {
                SmartLabel.setStyle(axisObj.labels.style);
            } else if (gridLines[0].label && gridLines[0].label.style) {
                SmartLabel.setStyle(axisObj.labels.style);
            }


            lineHeight = SmartLabel.getOriSize(testStr).height;

            if (!isBar) {
                lineHeight += (fontSize * 0.4); // padding in case of non bar charts to make the labels look visiually aesthetic
            }

            perLabelHeight = canvasHeight / (length - 1);

            if (perLabelHeight < lineHeight) {
                stepValue = Math.max(1, Math.ceil(lineHeight / perLabelHeight));

                marker = startIdx;
                for (i = startIdx; i < length; i += 1) {
                    plotObj = gridLines[i];
                    if (i === labelIdx) {
                        if (((i - marker) % stepValue) && prevPlot) {
                            prevPlot.label.text = "";
                        }
                        marker = labelIdx;
                    }
                    if (plotObj && plotObj.label) {
                        if ((i - marker) % stepValue) {
                            plotObj.label.text = BLANKSTRING;
                        } else {
                            prevPlot = plotObj;
                        }
                    }
                }

                marker = startIdx;
                for (i = startIdx; i >= 0; i -= 1) {
                    plotObj = gridLines[i];
                    if (i === labelIdx) {
                        if (((marker - i) % stepValue) && prevPlot) {
                            prevPlot.label.text = "";
                        }
                        marker = labelIdx;
                    }
                    if (plotObj && plotObj.label) {
                        if ((marker - i) % stepValue) {
                            plotObj.label.text = BLANKSTRING;
                        } else {
                            prevPlot = plotObj;
                        }
                    }
                }
            }
        }
    },

    placeHorizontalAxis = lib.placeHorizontalAxis =  function (axisObj, axisConf, hcJSON,
        fcJSON, width, maxHeight, minCanWidth) {

        var conf = hcJSON[FC_CONFIG_STRING],
        FCChartObj = fcJSON && fcJSON.chart || {},
        textObj, plotObj, index, titleText, labelObj,
        lastUsedStyle, minWidth, temp, maxStaggerLines, tempLabelWidth,
        labelTextWidth, labelTextPadding = 4, autoWrapLimit,

        rotation = 0, titleHeightUsed = 0, labelHeight = 10, stepValue = 1,
        labelY = 0, nameLineHeight = 0, catCount = 0, testStr = 'W',
        titleHeight = 0,

        noWrap = false, isStagger = false, isNone = false,

        isStepped = pluckNumber(FCChartObj.labelstep, 0),
        minUserWidth = pluckNumber(FCChartObj.xaxisminlabelwidth, 0),

        labelDisplay = axisConf.labelDisplay,
        rotateLabels = axisConf.rotateLabels,
        labelPadding = axisConf.horizontalLabelPadding,

        marginBottomExtraSpace = conf.marginBottomExtraSpace,
        availableSpaceLeft = hcJSON.chart.marginLeft,
        availableSpaceRight = hcJSON.chart.marginRight,

        SmartLabel = conf.smartLabel,
        setBorderWidth = conf.plotBorderThickness,
        catLen = axisConf.catCount,
        slantLabels = axisConf.slantLabels,
        unitWidth = width / (axisObj.max - axisObj.min),

        

        tedendHeight = 0, oppTrendHeight = 0, labelSize = {
            w: 0,
            h: 0
        },

        options = (fcJSON && fcJSON.chart) || {},
        refresh = pluckNumber(options.updateinterval, options.refreshinterval) * 1000,
        dataUrl = options.datastreamurl,
        realtimeEnabled = Boolean(this.realtimeEnabled && refresh && (dataUrl !== undefined));

        if (axisObj.labels.style) {
            lastUsedStyle = axisObj.labels.style;
            SmartLabel.setStyle(lastUsedStyle);
            temp = SmartLabel.getOriSize(testStr);
            labelHeight = SmartLabel.lineHeight;
            minWidth = temp.width + labelTextPadding;
            autoWrapLimit = SmartLabel.getOriSize("WWW").width + labelTextPadding;
        }

        var axisMin, axisMax, labelEdge, leftModify, rightModify, excessWidth, i,
        plotLinesArr, plotBandsArr, gridLinesArr = [], nonGridLinesArr = [],
        chartPlotWidth, firstDifference = 0, lastDifference = 0, lastGridIndex,
        gridLinesLen, perCatWidth, canvasLeftSpace, canvasRightSpace,
        totalDifference, length, xAxisNamePadding = axisConf.horizontalAxisNamePadding, labelSpace = 0,
        staggerLines = axisConf.staggerLines, bottomSpace = tedendHeight, isXYPlot = false,
        widthToAdd, padWidth, nCWidth, paddingGiven = false;

        if (axisObj.title && axisObj.title.text != BLANKSTRING) {
            lastUsedStyle = axisObj.title.style;
            SmartLabel.setStyle(lastUsedStyle);
            nameLineHeight = SmartLabel.getOriSize(testStr).height;
            //now get the title space
            axisObj.title.rotation = 0;
            titleText = SmartLabel.getSmartText(axisObj.title.text, width, maxHeight);
            titleHeightUsed = titleText.height;
        }

        if (availableSpaceLeft != parseInt(FCChartObj.chartleftmargin, 10)) {
            leftModify = true;
        }
        if (availableSpaceRight != parseInt(FCChartObj.chartrightmargin, 10)) {
            rightModify = true;
        }
        if (FCChartObj.canvaspadding !== undefined && FCChartObj.canvaspadding !== '') {
            paddingGiven = true;
        }
        // if the chartmargin is to be changed to accomodate the first and last labels
        // then excessWidth is the limit upto which the total chartmargins can be changed.
        excessWidth = width - minCanWidth;

        switch (labelDisplay) {
            case 'none':
                isNone = true;
                noWrap = true;
                if (rotateLabels) {
                    if (slantLabels) {
                        rotation = 300;
                    } else {
                        rotation = 270;
                    }
                    temp = labelHeight;
                    labelHeight = minWidth;
                    minWidth = temp;
                }
                break;
            case 'rotate':
                if (slantLabels) {
                    rotation = 300;
                } else {
                    rotation = 270;
                }
                temp = labelHeight;
                labelHeight = minWidth;
                minWidth = temp;
                noWrap = true;
                break;
            case 'stagger':
                noWrap = true;
                isStagger = true;
                maxStaggerLines = Math.floor((maxHeight - nameLineHeight) / labelHeight);
                if (maxStaggerLines < staggerLines) {
                    staggerLines = maxStaggerLines;
                }
                break;
            default: //auto
                if (rotateLabels) {
                    if (slantLabels) {
                        rotation = 300;
                    } else {
                        rotation = 270;
                    }
                    temp = labelHeight;
                    labelHeight = minWidth;
                    minWidth = temp;
                }
        }

        if (conf.isBar) {
            noWrap = true;
        }
        // if the chart is not scatter chart
        i = 0;
        plotLinesArr = axisObj.plotLines;

        if (typeof hcJSON._FCconf.isXYPlot === STRINGUNDEFINED && !conf.isBar) {

            // 1. segregate the grid plot lines from the non grid plot lines
            for (length = plotLinesArr.length; i < length; i += 1) {
                plotObj = plotLinesArr[i];
                if (plotObj) {
                    if (plotObj.isGrid) {
                        gridLinesArr.push(plotObj);
                    } else if (plotObj.isTrend) {
                        nonGridLinesArr.push(plotObj);
                    }
                }
            }

            plotBandsArr = axisObj.plotBands;

            for (i = 0, length = plotBandsArr.length; i < length; i += 1) {
                plotObj = plotBandsArr[i];
                if (plotObj) {
                    nonGridLinesArr.push(plotObj);
                }
            }

            lastGridIndex = gridLinesArr.length - 1;
            gridLinesLen = gridLinesArr.length;

            if (isStagger) {
                if (staggerLines > gridLinesLen) {
                    staggerLines = gridLinesLen;
                } else if (staggerLines < 2) {
                    staggerLines = 2;
                }
            }

            if (gridLinesLen) {
                if (axisObj.scroll && axisObj.scroll.viewPortMin && axisObj.scroll.viewPortMax) {
                    axisMin = axisObj.scroll.viewPortMin;
                    axisMax = axisObj.scroll.viewPortMax;
                    leftModify = false;
                    rightModify = false;
                } else {
                    axisMin = axisObj.min;
                    axisMax = axisObj.max;
                }
                // 2. calculate width for each label

                chartPlotWidth = (gridLinesArr[lastGridIndex].value - gridLinesArr[0].value) * unitWidth;
                perCatWidth = chartPlotWidth / (catLen - 1);
                canvasLeftSpace = (gridLinesArr[0].value - axisMin) * unitWidth;
                canvasRightSpace = (axisMax - gridLinesArr[lastGridIndex].value) * unitWidth;

                if (labelDisplay === 'auto') {
                    if (perCatWidth < autoWrapLimit) {
                        if (slantLabels) {
                            rotation = 300;
                        } else {
                            rotation = 270;
                        }
                        temp = labelHeight;
                        labelHeight = minWidth;
                        minWidth = temp;
                        noWrap = true;
                    }
                } else if (labelDisplay === 'stagger') {
                    perCatWidth *= staggerLines;
                }

                if (this.defaultSeriesType !== "line") {
                    

                    if (this.defaultSeriesType === 'area') {
                        if (conf.drawFullAreaBorder) {
                            if (setBorderWidth > canvasLeftSpace) {
                                axisMin = axisObj.min -= (setBorderWidth / (2 * unitWidth));
                                canvasLeftSpace += (gridLinesArr[0].value - axisMin) * unitWidth;
                            }

                            if (setBorderWidth > canvasRightSpace) {
                                axisMax = axisObj.max += (setBorderWidth /  (2 * unitWidth));
                                canvasRightSpace += (axisMax - gridLinesArr[lastGridIndex].value) * unitWidth;
                            }
                        }
                    }
                    else {
                        if (setBorderWidth > canvasLeftSpace) {
                            axisMin = axisObj.min -= (setBorderWidth / (2 * unitWidth));
                            canvasLeftSpace += (gridLinesArr[0].value - axisMin) * unitWidth;
                        }

                        if (setBorderWidth > canvasRightSpace) {
                            axisMax = axisObj.max += (setBorderWidth /  (2 * unitWidth));
                            canvasRightSpace += (axisMax - gridLinesArr[lastGridIndex].value) * unitWidth;
                        }
                    }
                }

                if (minWidth < minUserWidth) {
                    minWidth = minUserWidth;
                }

                if (!isStagger && !isNone) {
                    stepValue = Math.max(1, isStepped, Math.ceil(minWidth / perCatWidth));
                }
                else {
                    stepValue = Math.max(1, isStepped);
                }

                if (conf.x) {
                    conf.x.stepValue = stepValue;
                }
                perCatWidth *= stepValue;

                // 4. calculate width for first label
                tempLabelWidth = (canvasLeftSpace + availableSpaceLeft) * 2;

                // if the distance b/w the first data point and min is greater than the distace between two adjacent data points
                labelObj = plotLinesArr[0].label;
                if (labelObj && labelObj.text) {
                    if (labelObj.style) {
                        SmartLabel.setStyle(labelObj.style);
                    }
                    if (rotation === 270) {
                        labelTextWidth = Math.min(perCatWidth, SmartLabel.getOriSize(labelObj.text).height + labelTextPadding);
                    }
                    else {
                        labelTextWidth = Math.min(perCatWidth, SmartLabel.getOriSize(labelObj.text).width + labelTextPadding);
                    }
                    // if the label doesnt fit in the given space
                    if (labelTextWidth > tempLabelWidth) {
                        if (!isNone) {
                            firstDifference = (labelTextWidth - tempLabelWidth) / 2;
                        }

                        if (!leftModify) {
                            if (paddingGiven) {
                                firstDifference = 0;
                            }
                            perCatWidth -= (firstDifference / (catLen - 1));
                            nCWidth = perCatWidth * (catLen - 1);
                            unitWidth = perCatWidth;
                            widthToAdd = (chartPlotWidth - nCWidth) / unitWidth;
                            axisMax = axisObj.max += widthToAdd;
                            axisMin = axisObj.min -= widthToAdd;
                            firstDifference = 0;
                            chartPlotWidth = nCWidth;
                            canvasLeftSpace = (gridLinesArr[0].value - axisMin) * unitWidth;
                            canvasRightSpace = (axisMax - gridLinesArr[lastGridIndex].value) * unitWidth;
                        }
                    }
                }

                // 5. calculate width for the last label
                tempLabelWidth = (canvasRightSpace + availableSpaceRight) * 2;

                // if the distance b/w the first data point and min is greater than the distace between two adjacent data points
                labelObj = plotLinesArr[lastGridIndex].label;
                if (labelObj && labelObj.text) {
                    if (labelObj.style) {
                        SmartLabel.setStyle(labelObj.style);
                    }
                    if (rotation === 270) {
                        labelTextWidth = Math.min(perCatWidth, SmartLabel.getOriSize(labelObj.text).height + labelTextPadding);
                    }
                    else {
                        labelTextWidth = Math.min(perCatWidth, SmartLabel.getOriSize(labelObj.text).width + labelTextPadding);
                    }
                    // if the label doesnt fit in the given space
                    if (labelTextWidth > tempLabelWidth) {
                        if (!isNone) {
                            lastDifference = (labelTextWidth - tempLabelWidth) / 2;
                        }

                        if (!rightModify) {
                            if (paddingGiven) {
                                lastDifference = 0;
                            }
                            perCatWidth -= (lastDifference / (catLen - 1));
                            nCWidth = perCatWidth * (catLen - 1);
                            unitWidth = perCatWidth;
                            widthToAdd = (chartPlotWidth - nCWidth) / unitWidth;
                            //fix for RED-327 which is a replicated issue of
                            //FCXTCOMMON-311.same fix applied.
                            //axisMax = axisObj.max += widthToAdd;
                            //axisMin = axisObj.min -= widthToAdd;
                            lastDifference = 0;
                            chartPlotWidth = nCWidth;
                            canvasLeftSpace = (gridLinesArr[0].value - axisMin) * unitWidth;
                            canvasRightSpace = (axisMax - gridLinesArr[lastGridIndex].value) * unitWidth;
                        }
                    }
                }

                // 6. do we need to change chart margin or canvas padding?
                totalDifference = firstDifference + lastDifference;
                if (totalDifference > 0) {
                    if (excessWidth > totalDifference) { // change the chart margins
                        reductionFactor =  (lastDifference * width)/(lastDifference + width);
                        reductionFactor = reductionFactor ? reductionFactor + 4 : 0; // for label padding;
                        hcJSON.chart.marginRight += reductionFactor;
                        width -= reductionFactor;

                        reductionFactor =  (firstDifference * width)/(firstDifference + width);
                        reductionFactor = reductionFactor ? reductionFactor + 4 : 0; // for label padding;
                        hcJSON.chart.marginLeft += reductionFactor;
                        width -= reductionFactor;

                        unitWidth = width / (axisObj.max - axisObj.min);
                    } else { //change the padding
                        if (firstDifference < lastDifference) {
                            // try and remove the greater of the two from chart margin
                            if ((excessWidth >= lastDifference) && rightModify) {
                                reductionFactor =  (lastDifference * width)/(lastDifference + width);
                                reductionFactor = reductionFactor ? reductionFactor + 4 : 0; // for label padding;
                                hcJSON.chart.marginRight += reductionFactor;
                                width -= reductionFactor;
                                unitWidth = width / (axisObj.max - axisObj.min);

                            } else if (leftModify) {
                                reductionFactor =  (firstDifference * width)/(firstDifference + width);
                                reductionFactor = reductionFactor ? reductionFactor + 4 : 0; // for label padding;
                                hcJSON.chart.marginLeft += reductionFactor;
                                width -= reductionFactor;
                                unitWidth = width / (axisObj.max - axisObj.min);
                            }
                        } else {
                            if ((excessWidth >= firstDifference) && leftModify) {
                                reductionFactor =  (firstDifference * width)/(firstDifference + width);
                                reductionFactor = reductionFactor ? reductionFactor + 4 : 0; // for label padding;
                                hcJSON.chart.marginLeft += reductionFactor;
                                width -= reductionFactor;
                                unitWidth = width / (axisObj.max - axisObj.min);

                            } else if (rightModify) {
                                reductionFactor =  (lastDifference * width)/(lastDifference + width);
                                reductionFactor = reductionFactor ? reductionFactor + 4 : 0; // for label padding;
                                hcJSON.chart.marginRight += reductionFactor;
                                width -= reductionFactor;
                                unitWidth = width / (axisObj.max - axisObj.min);
                            }
                        }
                    }
                    chartPlotWidth = (gridLinesArr[lastGridIndex].value - gridLinesArr[0].value) * unitWidth;
                    perCatWidth = chartPlotWidth / (catLen - 1);

                    if (isStagger) {
                        perCatWidth *= staggerLines;
                    }

                    if (!isStagger && !isNone) {
                        if (rotation) {
                            stepValue = Math.max(1, isStepped, Math.ceil(labelHeight / perCatWidth));
                        }
                        else {
                            stepValue = Math.max(1, isStepped, Math.ceil(minWidth / perCatWidth));
                        }
                    }
                    else {
                        stepValue = Math.max(1, isStepped);
                    }

                    if (conf.x) {
                        conf.x.stepValue = stepValue;
                    }
                    perCatWidth *= stepValue;
                }

                // start setting the label dimensions
                for(index = 0; index < gridLinesLen; index += 1) {

                    plotObj = gridLinesArr[index];

                    if ((index % stepValue) && plotObj.label) {
                        plotObj.stepped = true;
                        plotObj.label.style = axisObj.steppedLabels.style;
                        if (!realtimeEnabled) {
                            continue;
                        }
                    }
                    else {
                        plotObj.stepped = false;
                        plotObj.label.style = axisObj.labels.style;
                    }

                    if (plotObj && plotObj.label && getValidValue(plotObj.label.text) !== undefined) {

                        labelObj = plotObj.label;
                        //if the style not implemented then implement it
                        if (labelObj.style && labelObj.style !== lastUsedStyle) {
                            lastUsedStyle = labelObj.style;
                            SmartLabel.setStyle(lastUsedStyle);
                        }

                        if (rotation && isNone) {
                            textObj = SmartLabel.getOriSize(labelObj.text);
                            labelSize.w = mathMax(labelSize.w, textObj.width + labelTextPadding);
                            labelSize.h = mathMax(labelSize.h, textObj.height);
                        }
                        else if (!isNone) {
                            if (rotation || isStagger) {
                                textObj = SmartLabel.getOriSize(labelObj.text);
                            }
                            else {//wrap
                                textObj = SmartLabel.getSmartText(labelObj.text, (perCatWidth - labelTextPadding), // 4px is removed for label padding
                                    maxHeight, noWrap);
                            }
                            labelSize.w = mathMax(labelSize.w, textObj.width + labelTextPadding);
                            labelSize.h = mathMax(labelSize.h, textObj.height);
                        }
                    }
                }
            }

            for(index = 0, length = nonGridLinesArr.length; index < length; index += 1) {

                plotObj = nonGridLinesArr[index];

                if (plotObj && plotObj.label && getValidValue(plotObj.label.text) !== undefined) {

                    labelObj = plotObj.label;
                    //if the style not implemented then implement it
                    if (labelObj.style && labelObj.style !== lastUsedStyle) {
                        lastUsedStyle = labelObj.style;
                        SmartLabel.setStyle(lastUsedStyle);
                    }

                    textObj = SmartLabel.getOriSize(labelObj.text);
                    if (labelObj.verticalAlign === POSITION_BOTTOM) {
                        tedendHeight= mathMax(tedendHeight, textObj.height);
                    }
                    else {
                        oppTrendHeight = mathMax(oppTrendHeight, textObj.height);
                    }
                }
            }

            if (axisObj.scroll && axisObj.scroll.enabled && !rotation && !isNone) {
                widthToAdd = labelSize.w / 2;
                if (hcJSON.chart.marginLeft < widthToAdd) {
                    padWidth = widthToAdd - hcJSON.chart.marginLeft;
                    if (excessWidth > padWidth) {
                        width -= padWidth;
                        excessWidth -= padWidth;
                        hcJSON.chart.marginLeft += padWidth;
                    }
                }
                if (hcJSON.chart.marginRight < widthToAdd) {
                    padWidth = widthToAdd - hcJSON.chart.marginRight;
                    if (excessWidth > padWidth) {
                        width -= padWidth;
                        excessWidth -= padWidth;
                        hcJSON.chart.marginRight += padWidth;
                    }
                }
            }
        } else {

            // Variables for scatter and bar charts
            var catLinesArr = {}, lowerThreshold, upperThreshold, newObj,
            leadingEdge = 0, trailingEdge = 0, nextItem, rem, firstCat = null, lastCat = null, nextCat, prevCat,
            plotPx, len, reductionFactor, gridLineObj, lineIndex,
            prevCatMap = {}, prevGrid, leftSpace, rightSpace, nextGrid, lastEdge,
            nextEdge, labelWidth;

            isXYPlot = true;

            unitWidth = width / (axisObj.max - axisObj.min);

            var setSuccessiveCategoryWidths = function (categoryObj1, categoryObj2, isStrict) {

                var px1, le1, te2, px2, labelWidth1, labelWidth2,
                edgeDiff, plotDiff, plotObj1, plotObj2;

                plotObj1 = categoryObj1.plotObj;
                labelWidth1 = categoryObj1.labelTextWidth;

                if (!labelWidth1) { // first label;
                    labelObj = plotObj1.label;
                    if (labelObj.style && labelObj.style !== lastUsedStyle) {
                        lastUsedStyle = labelObj.style;
                        SmartLabel.setStyle(lastUsedStyle);
                    }

                    labelWidth1 = SmartLabel.getOriSize(labelObj.text).width + labelTextPadding;
                    categoryObj1.oriWidth = labelWidth1;

                    if (labelWidth1 > lowerThreshold) {
                        labelWidth1 = lowerThreshold;
                    }

                    categoryObj1.labelTextWidth = labelWidth1;
                    categoryObj1.leftEdge = (plotObj1.value * unitWidth) - (labelWidth1 / 2);
                    categoryObj1.rightEdge = (plotObj1.value * unitWidth) + (labelWidth1 / 2);

                    if (isStrict) {
                        labelWidth1 = Math.min(labelWidth1, 2 * ((plotObj.value - axisObj.min) * unitWidth) + hcJSON.chart.marginLeft);
                        categoryObj1.labelTextWidth = labelWidth1;
                    }
                }

                if (typeof categoryObj2 !== STRINGUNDEFINED) {

                    plotObj2 = categoryObj2.plotObj;

                    labelObj = plotObj2.label;

                    if (labelObj.style && labelObj.style !== lastUsedStyle) {
                        lastUsedStyle = labelObj.style;
                        SmartLabel.setStyle(lastUsedStyle);
                    }

                    if (categoryObj2.oriWidth) {
                        labelWidth2 = categoryObj2.oriWidth;
                    } else {
                        labelWidth2 = SmartLabel.getOriSize(labelObj.text).width + labelTextPadding;
                        categoryObj2.oriWidth = labelWidth2;
                    }

                    if (labelWidth2 > lowerThreshold) {
                        labelWidth2 = lowerThreshold;
                    }

                    categoryObj2.labelTextWidth = labelWidth2;
                    categoryObj2.leftEdge = (plotObj2.value * unitWidth) - (labelWidth2 / 2);
                    categoryObj2.rightEdge = (plotObj2.value * unitWidth) + (labelWidth2 / 2);

                    px1 = plotObj1.value * unitWidth;
                    le1 = px1 + (labelWidth1 / 2);

                    px2 = plotObj2.value * unitWidth;
                    te2 = px2 - (labelWidth2 / 2);

                    if (te2 < le1) {
                        if ((px1 + minWidth) < ( px2 - minWidth)) {
                            edgeDiff = le1 - te2;
                            plotDiff = px2 - px1;
                            if (edgeDiff > plotDiff) {
                                categoryObj1.labelTextWidth = Math.min(labelWidth1, plotDiff);
                            } else {
                                categoryObj1.labelTextWidth = Math.max(minWidth, (labelWidth1 - (edgeDiff / 2)));
                            }
                            categoryObj2.labelTextWidth = 2 * (plotDiff - (categoryObj1.labelTextWidth / 2));

                            categoryObj1.leftEdge = (plotObj1.value * unitWidth) - (categoryObj1.labelTextWidth / 2);
                            categoryObj1.rightEdge = (plotObj1.value * unitWidth) + (categoryObj1.labelTextWidth / 2);

                            categoryObj2.leftEdge = (plotObj2.value * unitWidth) - (categoryObj2.labelTextWidth / 2);
                            categoryObj2.rightEdge = (plotObj2.value * unitWidth) + (categoryObj2.labelTextWidth / 2);

                        } else {
                            categoryObj2.labelTextWidth = 0;
                            plotObj2.label.text = BLANKSTRING;
                            return false;
                        }
                    }
                } else if (isStrict){ // is lastLabel
                    labelWidth1 = Math.min(labelWidth1, 2 * ((axisObj.max - plotObj.value) * unitWidth) + hcJSON.chart.marginRight);
                    categoryObj1.labelTextWidth = labelWidth1;
                    categoryObj1.leftEdge = (plotObj1.value * unitWidth) - (labelWidth1 / 2);
                    categoryObj1.rightEdge = (plotObj1.value * unitWidth) + (labelWidth1 / 2);
                }

                categoryObj1.nextCat = categoryObj2;
                return true;
            };

            // wrap or stagger
            if (isStagger) {
                if (staggerLines > gridLinesLen) {
                    staggerLines = gridLinesLen;
                } else if (staggerLines < 2) {
                    staggerLines = 2;
                }
            } else {
                staggerLines = 1;
            }

            for (length = plotLinesArr.length; i < length; i += 1) {
                plotObj = plotLinesArr[i];
                if (plotObj && plotObj.label && (typeof plotObj.label.text !== STRINGUNDEFINED)) {
                    if (plotObj.isGrid) {
                        newObj = {
                            plotObj: plotObj
                        };
                        if (plotObj.isCat) {
                            rem = i % staggerLines;
                            if (!catLinesArr[rem]) {
                                catLinesArr[rem] = [];
                            }
                            if (!firstCat) {
                                firstCat = newObj;
                                lastCat = newObj; // in case there is only one category label first and last are the same.
                                catLinesArr[rem].push(firstCat);
                            } else {
                                lastCat = newObj;
                                catLinesArr[rem].push(lastCat);
                            }
                        }
                        gridLinesArr.push(newObj);
                    } else if (plotObj.isTrend) {
                        nonGridLinesArr.push({
                            plotObj: plotObj
                        });
                    }
                }
            }

            plotBandsArr = axisObj.plotBands;
            for (i = 0, length = plotBandsArr.length; i < length; i += 1) {
                plotObj = plotBandsArr[i];
                if (plotObj && plotObj.isTrend && plotObj.label && (typeof plotObj.label.text !== STRINGUNDEFINED)) {
                    nonGridLinesArr.push({
                        plotObj: plotObj
                    });
                }
            }

            if (gridLinesArr.length) {
                if (!isNone && !rotation) {
                    if (conf.distributedColumns) {
                        var plotRight, plotLeft;

                        for (i = 0, length = gridLinesArr.length; i < length; i += 1) {

                            gridLineObj = gridLinesArr[i];
                            lineIndex = i % staggerLines;

                            plotObj = gridLineObj.plotObj;
                            if (!plotObj.label) {
                                continue;
                            }

                            if (plotObj.isCat) {
                                if (i - staggerLines >= 0) {
                                    prevCat = gridLinesArr[i - staggerLines];
                                    lastEdge = prevCat.plotObj.value * unitWidth + prevCat.plotObj._weight * unitWidth / 2;
                                } else {
                                    prevCat = null;
                                    lastEdge = (axisObj.min * unitWidth) - availableSpaceLeft;
                                }

                                if (i + staggerLines < length) {
                                    nextCat = gridLinesArr[i + staggerLines];
                                    nextEdge = nextCat.plotObj.value * unitWidth - nextCat.plotObj._weight * unitWidth / 2;
                                } else {
                                    nextCat = null;
                                    nextEdge = (axisObj.max * unitWidth) + availableSpaceRight;
                                }

                                labelObj = plotObj.label;
                                if (labelObj.style && labelObj.style !== lastUsedStyle) {
                                    lastUsedStyle = labelObj.style;
                                    SmartLabel.setStyle(lastUsedStyle);
                                }

                                plotPx = plotObj.value * unitWidth;
                                plotLeft = plotPx - plotObj._weight * unitWidth / 2;
                                plotRight = plotPx + plotObj._weight * unitWidth / 2;

                                if (staggerLines > 1) {
                                    leftSpace = plotLeft - lastEdge;
                                    rightSpace = plotRight + nextEdge;
                                    labelWidth  = plotRight - plotLeft + Math.min(leftSpace, rightSpace);
                                } else {
                                    labelWidth = plotRight - plotLeft;
                                }

                                labelObj = plotObj.label;

                                if (labelObj.style && labelObj.style !== lastUsedStyle) {
                                    SmartLabel.setStyle(labelObj.style);
                                }

                                if (labelWidth < minWidth && minWidth < SmartLabel.getOriSize(labelObj.text).width) {
                                    plotObj.label.text = BLANKSTRING;
                                    gridLineObj.labelTextWidth = 0;
                                    continue;
                                }

                                gridLineObj.labelTextWidth = labelWidth;

                                textObj = SmartLabel.getSmartText(labelObj.text, (labelWidth - labelTextPadding), maxHeight, noWrap);
                                labelWidth = textObj.width + labelTextPadding;

                                gridLineObj.labelTextWidth = labelWidth;
                                labelSize.h = Math.max(labelSize.h, textObj.height);
                            }
                        }
                    } else {
                        gridLinesLen = gridLinesArr.length;
                        lastGridIndex = gridLinesArr.length - 1;

                        chartPlotWidth = (gridLinesArr[lastGridIndex].plotObj.value - gridLinesArr[0].plotObj.value) * unitWidth;
                        if (chartPlotWidth) {
                            lowerThreshold = chartPlotWidth * 0.1;
                            upperThreshold = Math.max(chartPlotWidth * 0.2, chartPlotWidth / gridLinesLen);

                        } else { // there is only one grid label.
                            lowerThreshold = width;
                            upperThreshold = width;
                        }
                        //1. start calulating the widths of the category labels as they have higher priority
                        for (index in catLinesArr) {
                            i = 0;
                            len = catLinesArr[index].length;

                            while (i < len) {
                                nextItem = i + 1;
                                while (!setSuccessiveCategoryWidths(catLinesArr[index][i], catLinesArr[index][nextItem])) {
                                    nextItem += 1;
                                }
                                i = nextItem;
                            }
                        }

                        //2. find the trailing edge of first category label.
                        if (firstCat) {
                            trailingEdge = ((firstCat.plotObj.value - axisObj.min) * unitWidth) + availableSpaceLeft - (firstCat.labelTextWidth / 2);
                        }

                        //3. if the first grid label is not a category, find trailing edge of first grid label
                        plotObj = gridLinesArr[0].plotObj;
                        if (!firstCat || plotObj !== firstCat.plotObj) {
                            labelObj = plotObj.label;
                            if (labelObj.style && labelObj.style !== lastUsedStyle) {
                                lastUsedStyle = labelObj.style;
                                SmartLabel.setStyle(lastUsedStyle);
                            }
                            labelTextWidth = SmartLabel.getOriSize(labelObj.text).width + labelTextPadding;

                            plotPx = ((plotObj.value - axisObj.min) * unitWidth) + availableSpaceLeft;

                            if (firstCat) {
                                difference = trailingEdge - plotPx;
                                if ((difference < labelTextWidth) && (difference > (minWidth / 2))) {
                                    labelTextWidth = difference * 2;
                                } else {
                                    labelTextWidth = 0;
                                }
                            }
                            gridLinesArr[0].labelTextWidth = labelTextWidth;

                            if (labelTextWidth > 0) {
                                temp = plotPx - (labelTextWidth / 2);
                            }

                            if (temp < trailingEdge) {
                                trailingEdge = temp;
                            }
                        }

                        //3. find the leading edge of last category label.
                        if (lastCat) {
                            labelTextWidth = lastCat.labelTextWidth;
                            leadingEdge = ((axisObj.max - lastCat.plotObj.value) * unitWidth) + availableSpaceRight - (labelTextWidth / 2);
                        }

                        //4. if the last grid label is not a category, find leading edge of last grid label
                        plotObj = gridLinesArr[lastGridIndex].plotObj;
                        if (!lastCat || plotObj !== lastCat.plotObj) {
                            labelObj = plotObj.label;
                            if (labelObj.style && labelObj.style !== lastUsedStyle) {
                                lastUsedStyle = labelObj.style;
                                SmartLabel.setStyle(lastUsedStyle);
                            }

                            labelTextWidth = SmartLabel.getOriSize(labelObj.text).width + labelTextPadding;

                            plotPx = ((axisObj.max - plotObj.value) * unitWidth) + availableSpaceRight;

                            if (lastCat) {
                                difference = plotPx - leadingEdge;
                                if ((difference < labelTextWidth) && (difference > (minWidth / 2))) {
                                    labelTextWidth = difference *  2;
                                } else {
                                    labelTextWidth = 0;
                                }
                            }

                            gridLinesArr[lastGridIndex].labelTextWidth = labelTextWidth;

                            if (labelTextWidth > 0) {
                                temp = plotPx - (labelTextWidth / 2);
                            }

                            if (temp < leadingEdge) {
                                leadingEdge = temp;
                            }
                        }

                        if (trailingEdge < 0) {
                            firstDifference = - trailingEdge;
                        } else {
                            firstDifference = 0
                        }

                        if (leadingEdge < 0) {
                            lastDifference = - leadingEdge;
                        } else {
                            lastDifference = 0;
                        }

                        // 6. do we need to change chart margin or canvas padding?
                        totalDifference = firstDifference + lastDifference;

                        if (totalDifference > 0) {
                            if (excessWidth > totalDifference) { // change the chart margins
                                reductionFactor =  (lastDifference * width)/(lastDifference + width);
                                reductionFactor = reductionFactor ? reductionFactor + 4 : 0; // for label padding;
                                hcJSON.chart.marginRight += reductionFactor;
                                width -= reductionFactor;

                                reductionFactor =  (firstDifference * width)/(firstDifference + width);
                                reductionFactor = reductionFactor ? reductionFactor + 4 : 0; // for label padding;
                                hcJSON.chart.marginLeft += reductionFactor;
                                width -= reductionFactor;

                                unitWidth = width / (axisObj.max - axisObj.min);
                            } else { //change the padding
                                if (firstDifference < lastDifference) {
                                    // try and remove the greater of the two from chart margin
                                    if ((excessWidth >= lastDifference) && rightModify) {
                                        reductionFactor =  (lastDifference * width)/(lastDifference + width);
                                        reductionFactor = reductionFactor ? reductionFactor + 4 : 0; // for label padding;
                                        hcJSON.chart.marginRight += reductionFactor;
                                        width -= reductionFactor;
                                        unitWidth = width / (axisObj.max - axisObj.min);

                                    } else if (leftModify) {
                                        reductionFactor =  (firstDifference * width)/(firstDifference + width);
                                        reductionFactor = reductionFactor ? reductionFactor + 4 : 0; // for label padding;
                                        hcJSON.chart.marginLeft += reductionFactor;
                                        width -= reductionFactor;
                                        unitWidth = width / (axisObj.max - axisObj.min);
                                    }
                                } else {
                                    if ((excessWidth >= firstDifference) && leftModify) {
                                        reductionFactor =  (firstDifference * width)/(firstDifference + width);
                                        reductionFactor = reductionFactor ? reductionFactor + 4 : 0; // for label padding;
                                        hcJSON.chart.marginLeft += reductionFactor;
                                        width -= reductionFactor;
                                        unitWidth = width / (axisObj.max - axisObj.min);

                                    } else if (rightModify) {
                                        reductionFactor =  (lastDifference * width)/(lastDifference + width);
                                        reductionFactor = reductionFactor ? reductionFactor + 4 : 0; // for label padding;
                                        hcJSON.chart.marginRight += reductionFactor;
                                        width -= reductionFactor;
                                        unitWidth = width / (axisObj.max - axisObj.min);
                                    }
                                }
                            }
                            availableSpaceRight = hcJSON.chart.marginRight;
                            availableSpaceLeft = hcJSON.chart.marginLeft;
                            chartPlotWidth = (gridLinesArr[lastGridIndex].plotObj.value - gridLinesArr[0].plotObj.value) * unitWidth;
                            lowerThreshold = chartPlotWidth * 0.1;
                            upperThreshold = Math.max(chartPlotWidth * 0.2, chartPlotWidth / gridLinesLen);

                            for(index in catLinesArr) {
                                i = 0;
                                len = catLinesArr[index].length;

                                while (i < len) {
                                    nextItem = i + 1;

                                    while (!setSuccessiveCategoryWidths(catLinesArr[index][i], catLinesArr[index][nextItem], true)) {
                                        nextItem += 1;
                                    }
                                    i = nextItem;
                                }
                                index += 1;
                            }
                        }


                        // setting the grid labels between the category labels that are currently occupying at most lowerThreshold width.
                        for (i = 0, length = gridLinesArr.length; i < length; i += 1) {

                            gridLineObj = gridLinesArr[i];
                            lineIndex = i % staggerLines;

                            plotObj = gridLineObj.plotObj;
                            if (!plotObj.label) {
                                continue;
                            }

                            if (plotObj.isCat) {
                                if (gridLineObj.labelTextWidth) {
                                    prevCatMap[lineIndex] = gridLineObj;
                                }
                            } else {

                                prevCat = prevCatMap[lineIndex];
                                if (prevCat) {
                                    nextCat = prevCat.nextCat;
                                } else if (catLinesArr[lineIndex]) {
                                    nextCat = catLinesArr[lineIndex][0];
                                } else {
                                    nextCat = null;
                                }

                                prevGrid = null;

                                // get the previous visible label
                                if (i >= staggerLines) {
                                    prevIdx = i - staggerLines;
                                    prevGrid = gridLinesArr[prevIdx];
                                    while (!prevGrid.labelTextWidth) {
                                        if (prevIdx >= staggerLines) {
                                            prevIdx -= staggerLines;
                                            prevGrid = gridLinesArr[prevIdx];
                                        } else {
                                            prevGrid = null;
                                            break;
                                        }
                                    }
                                }

                                if (prevGrid) {
                                    lastEdge = prevGrid.rightEdge;
                                } else {
                                    lastEdge = (axisObj.min * unitWidth) - availableSpaceLeft;
                                }

                                if (nextCat) {
                                    nextEdge = nextCat.leftEdge;
                                } else {
                                    nextEdge = (axisObj.max * unitWidth) + availableSpaceRight;
                                }

                                labelObj = plotObj.label;
                                if (labelObj.style && labelObj.style !== lastUsedStyle) {
                                    lastUsedStyle = labelObj.style;
                                    SmartLabel.setStyle(lastUsedStyle);
                                }

                                labelTextWidth = SmartLabel.getOriSize(labelObj.text).width + labelTextPadding;
                                labelEdge = (plotObj.value * unitWidth) - (labelTextWidth / 2);

                                if (conf.isBar && (i == length - 1) && prevGrid) {
                                    if (lastEdge > labelEdge) {
                                        prevGrid.plotObj.label.text = BLANKSTRING;
                                        prevGrid.labelTextWidth = 0;
                                        lastEdge = prevGrid.leftEdge;
                                    }
                                } else {
                                    if ((lastEdge > labelEdge) || (nextEdge < (labelEdge + labelTextWidth))) {
                                        plotObj.label.text = BLANKSTRING;
                                        gridLineObj.labelTextWidth = 0;
                                        continue;
                                    }
                                }

                                lastEdge = Math.max(lastEdge, labelEdge);

                                plotPx = plotObj.value * unitWidth;
                                labelWidth = 2 * Math.min((plotPx - lastEdge), (nextEdge - plotPx));
                                // hack to work around the javascript floating
                                // point operations bug.
                                if (labelWidth.toFixed) {
                                    labelWidth = (labelWidth.toFixed(2));
                                }

                                labelObj = plotObj.label;

                                if (labelObj.style && labelObj.style !== lastUsedStyle) {
                                    SmartLabel.setStyle(labelObj.style);
                                }

                                if (labelWidth < minWidth && minWidth < SmartLabel.getOriSize(labelObj.text).width) {
                                    plotObj.label.text = BLANKSTRING;
                                    gridLineObj.labelTextWidth = 0;
                                    continue;
                                }

                                gridLineObj.labelTextWidth = labelWidth;

                                textObj = SmartLabel.getSmartText(labelObj.text, (labelWidth - labelTextPadding), maxHeight, noWrap);
                                labelWidth = textObj.width + labelTextPadding;

                                gridLineObj.labelTextWidth = labelWidth;
                                gridLineObj.leftEdge = plotPx - (labelWidth / 2);
                                gridLineObj.rightEdge = plotPx + (labelWidth / 2);

                                labelSize.h = Math.max(labelSize.h, textObj.height);
                            }
                        }

                        // after setting the grid labels we expand the category labels to occupying upto upperThreshold width.
                        var nextIdx = null, prevIdx = null;
                        nextGrid = null, prevGrid = null;
                        for (i = 0, length = gridLinesArr.length; i < length; i += 1) {

                            gridLineObj = gridLinesArr[i];
                            plotObj = gridLineObj.plotObj;
                            lineIndex = i % staggerLines;

                            if (plotObj.isCat && gridLineObj.labelTextWidth) {
                                nextGrid = null, prevGrid = null;
                                plotPx = plotObj.value * unitWidth;
                                // get the previous visible label
                                if (i >= staggerLines) {
                                    prevIdx = i - staggerLines;
                                    prevGrid = gridLinesArr[prevIdx];
                                    while (!prevGrid.labelTextWidth) {
                                        if (prevIdx > staggerLines) {
                                            prevIdx -= staggerLines;
                                            prevGrid = gridLinesArr[prevIdx];
                                        } else {
                                            prevGrid = null;
                                            break;
                                        }
                                    }
                                }

                                if (prevGrid) {
                                    leftSpace = plotPx - prevGrid.rightEdge;
                                } else {
                                    leftSpace = plotPx - (axisObj.min * unitWidth) + hcJSON.chart.marginLeft;
                                }

                                // get the next visible label
                                if ((i + staggerLines) < length) {
                                    nextIdx = i + staggerLines;
                                    nextGrid = gridLinesArr[nextIdx];
                                    while (!nextGrid.labelTextWidth) {
                                        if ((nextIdx + staggerLines) < (length - 1)) {
                                            nextIdx += staggerLines;
                                            nextGrid = gridLinesArr[nextIdx];
                                        } else {
                                            nextGrid = null;
                                            break;
                                        }
                                    }
                                }

                                if (nextGrid) {
                                    rightSpace = nextGrid.leftEdge - plotPx;
                                } else {
                                    rightSpace = (axisObj.max * unitWidth) + hcJSON.chart.marginRight - plotPx;
                                }


                                labelWidth = Math.min(leftSpace, rightSpace) * 2;

                                if (labelWidth > upperThreshold) {
                                    labelWidth = upperThreshold;
                                }

                                if (labelWidth > gridLineObj.oriWidth) {
                                    labelWidth = gridLineObj.oriWidth;
                                }

                                gridLineObj.labelTextWidth = labelWidth;

                                labelObj = plotObj.label;
                                if (labelObj.style && labelObj.style !== lastUsedStyle) {
                                    SmartLabel.setStyle(labelObj.style);
                                }

                                textObj = SmartLabel.getSmartText(labelObj.text, labelWidth - labelTextPadding, maxHeight, noWrap);
                                gridLineObj.labelTextWidth = textObj.width + labelTextPadding;
                                labelSize.h = Math.max(labelSize.h, textObj.height);

                                gridLineObj.rightEdge = plotPx + (gridLineObj.labelTextWidth / 2);
                            }
                        }
                    }

                // setting the widths of non grid labels.
                } else if (rotation) {
                    for (i = 0, length = gridLinesArr.length; i < length; i += 1) {
                        plotObj = gridLinesArr[i].plotObj;
                        if (plotObj && plotObj.label && plotObj.label.text) {
                            labelObj = plotObj.label;
                            if (labelObj.style && labelObj.style !== lastUsedStyle) {
                                lastUsedStyle = labelObj.style;
                                SmartLabel.setStyle(lastUsedStyle);
                            }
                            index = 1;
                            if ((i + index) < length) {
                                var nextPlot = gridLinesArr[index + i].plotObj;
                                while (nextPlot && ((nextPlot.value - plotObj.value) * unitWidth) < minWidth) {
                                    if (plotObj.isCat) {
                                        if (nextPlot.label) {
                                            nextPlot.label.text = BLANKSTRING;
                                            index += 1;
                                            if ((index + i) >= (length - 1)) {
                                                break;
                                            }
                                            nextPlot = plotLinesArr[index + i].plotObj;
                                        }
                                    } else if (nextPlot.isCat) {
                                        plotObj.label.text = BLANKSTRING;
                                        plotObj = nextPlot;
                                        i += (index - 1);
                                        labelObj = plotObj.label;
                                        //if the style not implemented then implement it
                                        if (labelObj.style && labelObj.style !== lastUsedStyle) {
                                            lastUsedStyle = labelObj.style;
                                            SmartLabel.setStyle(lastUsedStyle);
                                        }
                                        break;
                                    }
                                }
                            }
                            labelSize.w = Math.max(labelSize.w, (SmartLabel.getOriSize(labelObj.text).width + labelTextPadding));
                        }
                    }
                }
            }

            for (index = 0, length = nonGridLinesArr.length; index < length; index += 1) {

                plotObj = nonGridLinesArr[index].plotObj;

                if (plotObj && plotObj.label && getValidValue(plotObj.label.text) !== undefined) {

                    labelObj = plotObj.label;
                    //if the style not implemented then implement it
                    if (labelObj.style && labelObj.style !== lastUsedStyle) {
                        lastUsedStyle = labelObj.style;
                        SmartLabel.setStyle(lastUsedStyle);
                    }

                    textObj = SmartLabel.getOriSize(labelObj.text);
                    if (labelObj.verticalAlign === POSITION_BOTTOM) {
                        tedendHeight = mathMax(tedendHeight, textObj.height);
                    } else {
                        oppTrendHeight = mathMax(oppTrendHeight, textObj.height);
                    }
                }
            }
        }

        //now calculate the required space height
        if (isNone) {
            labelSpace = labelHeight;
            if (rotation) { // special rotation when labelDisplay=='none'
                labelSpace = labelSize.w;
            }
        }
        else if (rotation) {
            labelSpace = labelSize.w;
        } else if (isStagger){
            labelSpace = staggerLines * labelHeight;
        } else {
            labelSpace = labelSize.h;
        }

        if (labelSpace > 0) {
            bottomSpace += labelPadding + labelSpace;
        }

        if (titleHeightUsed > 0) {
            bottomSpace += titleHeightUsed + xAxisNamePadding;
        }

        var difference,
            reducePadding = (labelPadding - 4), // the padding shud not go below 4px
            totalSpace = oppTrendHeight + bottomSpace + 2; 


        temp = 0;

        /// Reduce the element size if required
        if (totalSpace > maxHeight) {
            difference = totalSpace - maxHeight;
            if (xAxisNamePadding > difference) {
                xAxisNamePadding -= difference;
                difference = 0;
            } else {
                difference -= xAxisNamePadding;
                xAxisNamePadding = 0;
                if (reducePadding > difference) {
                    reducePadding -= difference;
                    differnece = 0;
                } else {
                    difference -= reducePadding;
                    reducePadding = 0;
                }
                labelPadding = reducePadding + 4;
            }

            // reduce the opposite side text or canvas text
            if (oppTrendHeight > difference) {
                oppTrendHeight -= difference;
                difference = 0;
            } else {
                if (oppTrendHeight > 0) {
                    difference -= oppTrendHeight;
                    oppTrendHeight = 0;
                }
                if (difference > 0) {
                    if (tedendHeight > difference) {
                        tedendHeight -= difference;
                        difference = 0;
                    }
                    else {
                        if (tedendHeight > 0) {
                            difference -= tedendHeight;
                            tedendHeight = 0;
                        }
                        if (difference > 0) {
                            if ((temp = titleHeightUsed - nameLineHeight) > difference) {
                                titleHeightUsed -= difference;
                                difference = 0;
                            }
                            else {
                                difference -= temp;
                                titleHeightUsed = nameLineHeight;
                                if (difference > 0) {
                                    if ((temp = labelSpace - labelHeight) > difference) {
                                        labelSpace -= difference;
                                        difference = 0
                                    }
                                    else {
                                        difference -= temp;
                                        labelSpace = labelHeight;
                                        if (difference > 0) {
                                            difference -= titleHeightUsed + xAxisNamePadding;
                                            titleHeightUsed = 0;
                                            if (difference > 0) {
                                                difference -= labelSpace
                                                labelSpace = 0
                                                if (difference > 0) {
                                                    labelPadding -= difference;
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }

        // Place the elements
        //add extraspace if any
        labelPadding += marginBottomExtraSpace;

        var labelX = conf.is3d ? - hcJSON.chart.xDepth : 0, trendTextY = labelSpace + labelPadding,
        textAlign, yShipment, perLabelH, perLabelW, xShipment = labelX, adjustedPx = labelHeight * 0.5;
        labelY = labelHeight + labelPadding, length = gridLinesArr.length;
        catCount = 0;

        if (!isXYPlot) {
            if (rotation) {
                perLabelH = perCatWidth;
                perLabelW = labelSpace - labelTextPadding;
                textAlign = POSITION_RIGHT;
                if (slantLabels) {
                    yShipment = labelPadding + 8; // in case of slant labels an extra charaters width has to be added to the yShipment
                } else {
                    yShipment = labelPadding + 4;//4px to looks poper like FC as there has a padding
                }
            }
            else if (isStagger) {
                perLabelH = labelHeight;
                perLabelW = perCatWidth - labelTextPadding;
                textAlign = POSITION_CENTER;

            }
            else {
                perLabelH = labelSpace;
                perLabelW = perCatWidth - labelTextPadding;
                //xShipment += 0;
                textAlign = POSITION_CENTER;
                yShipment = labelY;//4px to looks poper like FC as there has a padding
            }

            for(index = 0; index < length; index += stepValue) {
                plotObj = gridLinesArr[index];
                if (plotObj && plotObj.label && getValidValue(plotObj.label.text) !== undefined) {

                    labelObj = plotObj.label;
                    //if the style not implemented then implement it
                    if (labelObj.style && labelObj.style !== lastUsedStyle) {
                        lastUsedStyle = labelObj.style;
                        SmartLabel.setStyle(lastUsedStyle);
                    }

                    if (!isNone) {
                        textObj = SmartLabel.getSmartText(labelObj.text, perLabelW, perLabelH, noWrap);
                        labelObj.text = textObj.text;
                        textObj.tooltext && (labelObj.originalText = textObj.tooltext);

                        if (isStagger) {
                            yShipment = labelY + ((catCount % staggerLines) * labelHeight);
                        }
                        if (rotation) {
                            //px adjustment to looks same as FC
                            xShipment = labelX + (adjustedPx / 2);
                        }

                    }
                    labelObj.y = yShipment;
                    labelObj.x = xShipment;
                    labelObj.rotation = rotation;
                    labelObj.textAlign = textAlign;
                    catCount += 1
                }
            }

            //if realtime store few conf for latter use
            axisConf._labelY = labelY;
            axisConf._labelX = labelX;
            axisConf._yShipment = yShipment;
            axisConf._isStagger = isStagger;
            axisConf._rotation = rotation;
            axisConf._textAlign = textAlign;
            axisConf._adjustedPx = adjustedPx / 2;
            axisConf._staggerLines = staggerLines;
            axisConf._labelHeight = labelHeight;

        } else {
            // for scatter and bar charts
            if (rotation) {

                textAlign = POSITION_RIGHT;
                if (slantLabels) {
                    yShipment = labelPadding + 8; // in case of slant labels an extra charaters width has to be added to the yShipment
                } else {
                    yShipment = labelPadding + 4;//4px to looks poper like FC as there has a padding
                }

                length = gridLinesArr.length;
                for(index = 0; index < length; index += 1) {
                    plotObj = gridLinesArr[index].plotObj;
                    if (plotObj && plotObj.label && getValidValue(plotObj.label.text) !== undefined) {

                        labelObj = plotObj.label;
                        //if the style not implemented then implement it
                        if (labelObj.style && labelObj.style !== lastUsedStyle) {
                            lastUsedStyle = labelObj.style;
                            SmartLabel.setStyle(lastUsedStyle);
                        }

                        i = 1;
                        textObj = SmartLabel.getSmartText(labelObj.text, labelSpace - 4, minWidth, noWrap);
                        labelObj.text = textObj.text;
                        textObj.tooltext && (labelObj.originalText = textObj.tooltext);

                        //px adjustment to looks same as FC
                        xShipment = labelX + (adjustedPx / 2);

                        labelObj.y = yShipment;
                        labelObj.x = xShipment;
                        labelObj.rotation = rotation;
                        labelObj.textAlign = textAlign;
                        catCount += 1
                    }
                }
            } else {
                perLabelH = labelSpace;
                textAlign = POSITION_CENTER;
                yShipment = labelY;

                for(index = 0; index < length; index += stepValue) {
                    plotObj = gridLinesArr[index].plotObj;
                    if (plotObj && plotObj.label && getValidValue(plotObj.label.text) !== undefined) {

                        labelObj = plotObj.label;
                        //if the style not implemented then implement it
                        if (labelObj.style && labelObj.style !== lastUsedStyle) {
                            lastUsedStyle = labelObj.style;
                            SmartLabel.setStyle(lastUsedStyle);
                        }

                        if (!isNone) {
                            textObj = SmartLabel.getSmartText(labelObj.text, gridLinesArr[index].labelTextWidth - 4, perLabelH, noWrap);
                            labelObj.text = textObj.text;
                            textObj.tooltext && (labelObj.originalText = textObj.tooltext);

                            if (isStagger) {
                                yShipment = labelY + ((catCount % staggerLines) * labelHeight);
                            }
                        }
                        labelObj.y = yShipment;
                        labelObj.x = xShipment;
                        labelObj.rotation = rotation;
                        labelObj.textAlign = textAlign;
                        catCount += 1
                    }
                }
            }
        }

        length = nonGridLinesArr.length;
        var aoppTrendHeight = 0, atedendHeight = 0;
        for(index = 0; index < length; index += 1) {
            plotObj = nonGridLinesArr[index].plotObj ? nonGridLinesArr[index].plotObj : nonGridLinesArr[index];
            if (plotObj && plotObj.label && getValidValue(plotObj.label.text) !== undefined) {

                labelObj = plotObj.label;
                //if the style not implemented then implement it
                if (labelObj.style && labelObj.style !== lastUsedStyle) {
                    lastUsedStyle = labelObj.style;
                    SmartLabel.setStyle(lastUsedStyle);
                }
                if (labelObj.verticalAlign === POSITION_BOTTOM) {
                    textObj = SmartLabel.getSmartText(labelObj.text, width, tedendHeight, true);
                    atedendHeight = Math.max(atedendHeight, textObj.height);
                    labelObj.text = textObj.text;
                    textObj.tooltext && (labelObj.originalText = textObj.tooltext);

                    labelObj.y = trendTextY + SmartLabel.getOriSize(labelObj.text).height;
                    labelObj.x = xShipment;
                } else {
                    textObj = SmartLabel.getSmartText(labelObj.text, width, oppTrendHeight, true);
                    aoppTrendHeight = Math.max(aoppTrendHeight, textObj.height);
                    labelObj.text = textObj.text;
                    textObj.tooltext && (labelObj.originalText = textObj.tooltext);

                    labelObj.y = - ((oppTrendHeight - SmartLabel.getOriSize(testStr).height) + labelPadding + 2); 

                }
            }
        }

        if (titleHeightUsed > 0) {
            SmartLabel.setStyle(axisObj.title.style);
            //now get the title space
            titleText = SmartLabel.getSmartText(axisObj.title.text, width, titleHeightUsed);
            axisObj.title.text = titleText.text;
            titleText.tooltext && (axisObj.title.originalText = titleText.tooltext);

            axisObj.title.margin = trendTextY + atedendHeight + xAxisNamePadding;
        }

        bottomSpace = atedendHeight;

        if (labelSpace > 0) {
            conf.horizontalAxisHeight = labelPadding + labelSpace - marginBottomExtraSpace;
            bottomSpace += conf.horizontalAxisHeight;
        }

        if (titleHeightUsed > 0) {
            bottomSpace += titleHeight = titleHeightUsed + xAxisNamePadding;
        }
        //
        hcJSON.chart.marginBottom += bottomSpace;

        if (aoppTrendHeight > 0) {
            hcJSON.chart.marginTop += aoppTrendHeight;
            bottomSpace += aoppTrendHeight;
        }

        if (axisObj.opposite) {
            // Fix for xAxis name showing always at bottom
            axisObj.title.margin -= labelSpace -
                    (titleText && titleText.height || 0) + labelPadding;
            bottomSpace -= titleHeight;

            hcJSON.chart.marginTop += bottomSpace;
            hcJSON.chart.marginBottom -= bottomSpace;
            hcJSON.xAxis.opposite = 1;
            for (length = plotLinesArr.length, i = 0; i < length; i += 1) {
                plotObj = plotLinesArr[i];
                if (plotObj && plotObj.isGrid && (labelObj = plotObj.label) &&
                        labelObj.text !== undefined) {
                    labelObj.textAlign = POSITION_LEFT;
                    labelObj.y -= yShipment + labelPadding + 4;
                }
            }
        }
        return bottomSpace;
    },

    configureLegendOptions = lib.configureLegendOptions = function (hcJSON, fcJSONChartObj, isONRight, isPointItem, availableWidth) {

        var legendObj = hcJSON.legend,
        hcJSONChart = hcJSON.chart,
        paletteIndex = hcJSONChart.paletteIndex,
        is3d = hcJSONChart.is3D,
        borderColor, palleteString = is3d ? chartPaletteStr.chart3D :
        chartPaletteStr.chart2D,
        interactiveLegend,
        borderAlpha,
        backgroundAlpha,
        roundEdges = hcJSONChart.useRoundEdges,
        padding = 4,
        legendHeight,
        padding2 = 2 * padding,
        legendScale = pluckNumber(fcJSONChartObj.legendiconscale, 1),
        frontHeight = parseInt(legendObj.itemStyle.fontSize, 10) || 10,
        symbolWidthSpace = frontHeight + 1,
        defaultSeries = hcJSON.chart.defaultSeriesType,
        symbolPadding = 3;

        if (legendScale <= 0 || legendScale > 5) {
            legendScale = 1;
        }

        legendObj.padding = padding;

        if (symbolWidthSpace <= 0) {
            symbolWidthSpace = 1;
        }
        availableWidth -= padding2;

        symbolWidthSpace *= legendScale;
        symbolPadding *= legendScale;
        symbolWidthSpace = Math.min(symbolWidthSpace, availableWidth);

        if (symbolWidthSpace <= 0) {
            symbolPadding = symbolWidthSpace = 0;
        }
        legendObj.symbolWidth = symbolWidthSpace;

        legendObj.symbolPadding = symbolPadding;
        legendObj.textPadding = 4;
        legendObj.legendHeight = legendHeight = symbolWidthSpace + (2 * symbolPadding);
        legendObj.rowHeight = Math.max(parseInt(legendObj.itemStyle.lineHeight, 10) || 12, legendHeight);

        if (isONRight) {//else pert is the default options
            //basic configuration for the legend box to show in right
            legendObj.align = POSITION_RIGHT;
            legendObj.verticalAlign = 'middle';
            legendObj.layout = 'vertical';
        }
        else {
            legendObj.x = (hcJSONChart.marginLeft - hcJSONChart.spacingLeft -
                hcJSONChart.marginRight + hcJSONChart.spacingRight) / 2;
        }


        borderColor = pluck(fcJSONChartObj.legendbordercolor,
            defaultPaletteOptions[palleteString.legendBorderColor][paletteIndex]);
        borderAlpha = pluckNumber(fcJSONChartObj.legendborderalpha, 100);
        backgroundAlpha = pluckNumber(fcJSONChartObj.legendbgalpha, 100);

        legendObj.backgroundColor  = convertColor(pluck(fcJSONChartObj.legendbgcolor,
            defaultPaletteOptions[palleteString.legendBgColor][paletteIndex]),
        backgroundAlpha);

        legendObj.borderColor = convertColor(borderColor, borderAlpha);
        legendObj.borderWidth = pluckNumber(fcJSONChartObj.legendborderthickness,
            !roundEdges || fcJSONChartObj.legendbordercolor ? 1 : 0);
        legendObj.shadow = Boolean(pluckNumber(fcJSONChartObj.legendshadow, 1));
        if (legendObj.shadow) {
            legendObj.shadow = {
                enabled: legendObj.shadow,
                opacity: mathMax(borderAlpha, backgroundAlpha) / 100
            };
        }
        legendObj.reversed = Boolean(pluckNumber(fcJSONChartObj.reverselegend, 0));
        //ispointItem means it is a pie or doughnut
        //then the data is alreadi reversed
        if (/^pie|pie3d$/.test(defaultSeries)) {
            legendObj.reversed = !legendObj.reversed;
        }
        legendObj.style = {
            padding : padding
        };

        interactiveLegend = Boolean(pluckNumber(fcJSONChartObj.interactivelegend, 1));
        if (!interactiveLegend) {
            hcJSON.legend.interactiveLegend = false;
            legendObj.itemStyle.cursor = 'default';
            legendObj.itemHoverStyle = {
                cursor : 'inherit'
            };
        }
        else {
            legendObj.symbolStyle = {
                '_cursor': 'hand',
                'cursor': 'pointer'
            };
        }

        legendObj.borderRadius = pluckNumber(fcJSONChartObj.legendborderradius,
            roundEdges ? 3 : 0);

        //extra attr on hc JSON added for fc attr support
        legendObj.legendAllowDrag = Boolean(pluckNumber(fcJSONChartObj.legendallowdrag, 0));
        legendObj.title.text = parseUnsafeString(getFirstValue(fcJSONChartObj.legendcaption, BLANKSTRING));
        legendObj.legendScrollBgColor = getFirstColor(pluck(fcJSONChartObj.legendscrollbgcolor,
            defaultPaletteOptions.altHGridColor[hcJSON.chart.paletteIndex]));
        legendObj.legendScrollBarColor = pluck(fcJSONChartObj.legendscrollbarcolor, borderColor);
        legendObj.legendScrollBtnColor = pluck(fcJSONChartObj.legendscrollbtncolor, borderColor);
        legendObj.title.style = extend2({
            fontWeight:"bold"
        }, legendObj.itemStyle);


    },

    /**
     *  Used to compute the space required to place the legend block when the
     *  legend block display is turned on.
     *
     *  @param hcJSON {Object}, is the JSON that is to be
     *
     */
    //Note: no text are allowed to be more in height then allowed (availableHeight) then there will be ellipses
    placeLegendBlockRight = lib.placeLegendBlockRight = function (hcJSON, fcJSON,
        availableWidth, availableHeight, isPointItem) {

        // configure LegendOptions
        configureLegendOptions(hcJSON, fcJSON.chart, true, isPointItem, availableWidth);

        var i = 0, legendData = hcJSON.series, len, item,
        conf = hcJSON[FC_CONFIG_STRING],
        SmartLabel = conf.smartLabel,
        legendObj =  hcJSON.legend,  smartText, textWidth,
        textPadding = legendObj.textPadding,
        captionPadding = legendObj.title.padding,
        captionWidth,
        symbolWidthSpace = legendObj.symbolWidth,
        symbolPadding = legendObj.symbolPadding,//6 px legend symbol fixed padding
        legendHeight = symbolWidthSpace + (2 * symbolPadding),
        allowedMaxHeight = availableHeight * 2,
        legendPadding = 2,
        textWidthUsed = 0,
        usedWidth = pluckNumber(fcJSON.chart.legendpadding, 7) +
                (legendObj.borderWidth / 2) + pluckNumber(fcJSON.chart.canvasborderthickness, 1),
        padding = legendObj.padding,
        padding2 = 2 * padding,
        blockDimensions = {
            width: padding2,
            height: padding2
        },
        validLegendItem = false,
        itemArr = [],
        lItem;

        availableWidth -= padding2;//5 pixel padding from canvas border

        if (isPointItem) {
            legendData = legendData && legendData[0] && legendData[0].data;
        }

        //return incase of no series
        if (typeof legendData === STRINGUNDEFINED || typeof legendData.length === STRINGUNDEFINED) {
            return 0;
        } else {
            len = legendData.length;
            for (i = 0; i < len; i += 1) {
                lItem = legendData[i];
                if (lItem && lItem.showInLegend !== false) {
                    //add temp index so that we can sort properly
                    lItem.__i = i;
                    itemArr.push(lItem);
                }
            }
            itemArr.sort(function (a, b) {
                return (a.legendIndex - b.legendIndex) || (a.__i - b.__i);
            });
            len = itemArr.length;
        }

        textWidth = availableWidth - legendHeight - legendPadding - textPadding;
        if (textWidth < 0) {
            textWidth = 0;
        }
        //blockDimensions.width = Math.max(legendHeight, blockDimensions.width);
        SmartLabel.setStyle(legendObj.itemStyle);
        if (legendObj.reversed) {
            itemArr.reverse();
        }
        for (i = 0; i < len; i += 1) {
            item = itemArr[i];
            validLegendItem = true;
            item._legendX = 0;
            item._legendY = blockDimensions.height;
            if (textWidth === 0) {
                blockDimensions.height += (item._legendH = legendHeight);
                item.name = BLANKSTRING;
            }
            else {
                smartText = SmartLabel.getSmartText(item.name, textWidth, allowedMaxHeight);
                item.name = smartText.text;
                smartText.tooltext && (item.originalText = smartText.tooltext);
                if (smartText.height < legendHeight) {
                    item._legendTestY = (legendHeight - smartText.height) / 2;
                }
                blockDimensions.height += (item._legendH = Math.max(smartText.height, legendHeight));
                textWidthUsed = Math.max(smartText.width, textWidthUsed);
            }
        }
        if (validLegendItem) {
            legendObj.itemWidth = textWidthUsed  + legendHeight + legendPadding + textPadding;
            legendObj.width = legendObj.itemWidth + padding2;
            if (legendObj.title.text !== BLANKSTRING) {
                SmartLabel.setStyle(legendObj.title.style);
                smartText = SmartLabel.getSmartText(legendObj.title.text, availableWidth, allowedMaxHeight);
                legendObj.title.text = smartText.text;
                smartText.tooltext && (legendObj.title.originalText = smartText.tooltext);

                captionWidth = smartText.width + padding2;
                //if the caption width has gretter width
                if (legendObj.width < captionWidth) {
                    legendObj.initialItemX = (captionWidth - legendObj.width) / 2;
                    legendObj.width = captionWidth;
                }
                legendObj.initialItemY = smartText.height + captionPadding;
                blockDimensions.height += legendObj.initialItemY ;
            }

            legendObj.height = legendObj.totalHeight = blockDimensions.height;

            if (legendObj.height > availableHeight) {
                legendObj.height = availableHeight;
                legendObj.scroll.enabled = true;
                legendObj.scroll.flatScrollBars = conf.flatScrollBars;
                legendObj.scroll.scrollBar3DLighting = conf.scrollBar3DLighting;
                legendObj.width += (legendObj.scroll.scrollBarWidth = 10) + (legendObj.scroll.scrollBarPadding = 2);
            }
            usedWidth = Math.min(legendObj.width + usedWidth, availableWidth);
            hcJSON.chart.marginRight +=  usedWidth;
            return usedWidth;
        }
        else {
            legendObj.enabled = false;
            return 0;
        }
    },

    //Note: no text are allowed to be more in height then 2 * allowed (availableHeight) then there will be ellipses
    placeLegendBlockBottom = lib.placeLegendBlockBottom = function (hcJSON, fcJSON,
        availableWidth, availableHeight, isPointItem) {

        //configure LegendOptions
        configureLegendOptions(hcJSON, fcJSON.chart, false, isPointItem, availableWidth);


        var i = 0, legendData = hcJSON.series, len, item,
        conf = hcJSON[FC_CONFIG_STRING],
        SmartLabel = conf.smartLabel,
        legendObj =  hcJSON.legend,  smartText, textWidth,
        textPadding = legendObj.textPadding,
        captionPadding = legendObj.title.padding,
        captionWidth,
        symbolPadding = legendObj.symbolPadding,//6 px legend symbol fixed padding
        legendHeight = legendObj.legendHeight,
        fcJSONChart = fcJSON.chart,
        legendCaptionHeight = 0,
        allowedMaxHeight = availableHeight * 2,
        legendPadding = 2,
        rowHeight = legendObj.rowHeight,
        tempTableStructure = [],
        minimiseWrappingInLegend = pluckNumber(fcJSONChart.minimisewrappinginlegend, 0),
        legendNumColumns = pluckNumber(parseInt(fcJSONChart.legendnumcolumns, 10), 0),
        maxWidth = 0, totalWidth = 0, totalNumber = 0, averageWidth = 0, perItemWidth = 0,
        padding = legendObj.padding,
        padding2 = 2 * padding,
        usedHeight = pluckNumber(fcJSON.chart.legendpadding, 7) +
                (legendObj.borderWidth / 2) + 1,
        blockDimensions = {
            width: padding2,
            height: padding2
        },
        validLegendItem = false,
        lItem,
        itemArr = [],
        rowIndex,
        colIndex;

        if (legendNumColumns < 0) {
            legendNumColumns = 0;
        }

        availableWidth -= padding2;//deduct the legend Box padding 2 * 6Px

        SmartLabel.setStyle(legendObj.itemStyle);
        var legendLineHeight = SmartLabel.getOriSize(TESTSTR).height;
        usedHeight = Math.min(usedHeight, availableHeight - legendLineHeight - 8); // 8px padding for the legend text.
        availableHeight -= usedHeight;

        if (isPointItem) {
            legendData = legendData && legendData[0] && legendData[0].data;
        }

        //return incase of no series
        if (typeof legendData === STRINGUNDEFINED || typeof legendData.length === STRINGUNDEFINED) {
            return 0;
        } else {
            len = legendData.length;
            for (i = 0; i < len; i += 1) {
                lItem = legendData[i];
                if (lItem && lItem.showInLegend !== false) {
                    //add temp index so that we can sort properly
                    lItem.__i = i;
                    itemArr.push(lItem);
                }
            }
            itemArr.sort(function (a, b) {
                return (a.legendIndex - b.legendIndex) || (a.__i - b.__i);
            });
            len = itemArr.length;
        }


        //set the legend text style
        SmartLabel.setStyle(legendObj.itemStyle);
        //retrive average and total width
        for (i = 0;i < len; i += 1) {
            validLegendItem = true;
            smartText = SmartLabel.getOriSize(itemArr[i].name);
            maxWidth = Math.max(maxWidth, smartText.width);
            totalWidth += smartText.width;
            totalNumber += 1;
        }
        averageWidth = totalWidth / totalNumber;

        if (validLegendItem) {
            averageWidth += legendHeight + legendPadding + textPadding;
            maxWidth += legendHeight + legendPadding + textPadding;

            if (legendNumColumns > 0 && totalNumber < legendNumColumns) {
                legendNumColumns = totalNumber;
            }

            //if valid numcolumn[there has enough item for legendNumColumns, every item getting minimum space]
            if (legendNumColumns > 0 && (perItemWidth = availableWidth / legendNumColumns) > averageWidth) {
                if(perItemWidth > maxWidth){
                    perItemWidth = maxWidth;
                }
            }
            else if (availableWidth > maxWidth && (minimiseWrappingInLegend || averageWidth * 1.5 > maxWidth)) {
                legendNumColumns = Math.floor(availableWidth / maxWidth);
                if (totalNumber < legendNumColumns) {
                    legendNumColumns = totalNumber;
                }
                perItemWidth = maxWidth;

            }
            else if(availableWidth >= 2 * averageWidth){
                //The number of columns each of width as the averageWidth
                legendNumColumns = Math.floor(availableWidth / averageWidth);

                if (totalNumber < legendNumColumns) {
                    legendNumColumns = totalNumber;
                }


                //Provide best width space, which is greater than average width, generally (for numColumns is found above via Math.floor())
                perItemWidth = Math.floor(availableWidth / legendNumColumns);

                if(perItemWidth > maxWidth){
                    perItemWidth = maxWidth;
                }
            } else {
                legendNumColumns = 1;
                perItemWidth = availableWidth;
            }


            legendObj.itemWidth = perItemWidth;

            textWidth = perItemWidth - legendHeight - legendPadding - textPadding;
            if (textWidth < 0) {
                symbolPadding = textWidth = textPadding = 0;
            }
            legendObj.symbolPadding = symbolPadding;
            legendObj.textPadding = textPadding;


            legendObj.width = (perItemWidth * legendNumColumns) + padding2;

            if (legendObj.title.text !== BLANKSTRING) {
                SmartLabel.setStyle(legendObj.title.style);
                smartText = SmartLabel.getSmartText(legendObj.title.text, availableWidth, allowedMaxHeight);
                legendObj.title.text = smartText.text;
                smartText.tooltext && (legendObj.title.originalText = smartText.tooltext);

                captionWidth = smartText.width + padding2;
                //if the caption width has gretter width
                if (legendObj.width < captionWidth) {
                    legendObj.initialItemX = (captionWidth - legendObj.width) / 2;
                    legendObj.width = captionWidth;
                }
                legendObj.initialItemY = legendCaptionHeight = smartText.height + captionPadding ;
            }

            SmartLabel.setStyle(legendObj.itemStyle);
            var numRows, numberOfCell, j, current = 0, tempCurrent;

            if (legendObj.reversed) {
                itemArr.reverse();
            }

            //blockDimensions.width = Math.max(legendHeight, blockDimensions.width);
            for (i = 0 ;i < len; i += 1) {
                item = itemArr[i];
                if (textWidth === 0) {
                    tempTableStructure[current] = true;
                    item.name = BLANKSTRING;
                    j = 1;
                }
                else {
                    smartText = SmartLabel.getSmartText(item.name, textWidth, allowedMaxHeight);
                    item.name = smartText.text;
                    smartText.tooltext && (item.originalText = smartText.tooltext);

                    while (tempTableStructure[current] === true) {
                        current += 1;
                    }
                    numberOfCell = smartText.height / rowHeight;
                    tempCurrent = current;
                    for (j = 0; j < numberOfCell; j += 1, tempCurrent += legendNumColumns) {
                        tempTableStructure[tempCurrent] = true;
                    }
                    if (smartText.height < rowHeight) {
                        item._legendTestY = (rowHeight - smartText.height) / 2;
                    }
                }
                    rowIndex = parseInt(current / legendNumColumns, 10);
                    colIndex = current % legendNumColumns;
                    item._legendX = colIndex * perItemWidth;
                    item._legendY = (rowIndex * rowHeight) + padding2;
                    item._legendH = j * rowHeight;
                current += 1;
            }

            numRows = Math.ceil(tempTableStructure.length / legendNumColumns);
            blockDimensions.height += (numRows * rowHeight) + legendCaptionHeight;
            legendObj.height = legendObj.totalHeight = blockDimensions.height;
            legendObj.rowHeight = rowHeight;
            legendObj.legendNumColumns = legendNumColumns;

            if (legendObj.height > availableHeight) { // for padding
                legendObj.height = availableHeight;
                legendObj.scroll.enabled = true;
                legendObj.scroll.flatScrollBars = conf.flatScrollBars;
                legendObj.scroll.scrollBar3DLighting = conf.scrollBar3DLighting;
                legendObj.width += (legendObj.scroll.scrollBarWidth = 10) + (legendObj.scroll.scrollBarPadding = 2);
            }

            usedHeight += legendObj.height;
            hcJSON.chart.marginBottom += usedHeight;
            return usedHeight;
        }
        else {//in case of no visible item disable legend
            legendObj.enabled = false;
            return 0;
        }
    },

    /*
     *This Function set the x axis min max to prodice space for canvasPadding
     */
    plotLineSortFN = function(a, b) {
        return a.value - b.value;
    },

    /*
     * Function to manage the space for a single X and single Y type normal type charts
     */
    nonBarXYSpaceManager = function (hcJSON, fcJSON, width, height) {
        var conf = hcJSON[FC_CONFIG_STRING], axisConf, toAddV, isOnRight = true,
        titleHeight = 0, difference = 0, canvasWidth, fcJSONChart = fcJSON.chart,
        isDual = false, yAxisNamePadding, yAxisValuesPadding, rotateYAxisName,
        showPlotBorder, setBorderWidth, canvasBorderThickness,

        marginLeftExtraSpace = conf.marginLeftExtraSpace,
        marginTopExtraSpace = conf.marginTopExtraSpace,
        marginBottomExtraSpace = conf.marginBottomExtraSpace,
        marginRightExtraSpace = conf.marginRightExtraSpace,
        workingWidth = width - (marginLeftExtraSpace + marginRightExtraSpace +
            hcJSON.chart.marginRight + hcJSON.chart.marginLeft),
        workingHeight = height - (marginBottomExtraSpace + hcJSON.chart.marginBottom +
            hcJSON.chart.marginTop),

        //calculate the min width, height for canvas
        

        minCanWidth = workingWidth * 0.3,
        minCanHeight = workingHeight * 0.3,

        // calculate the space remaining
        avaiableWidth = workingWidth - minCanWidth,
        avaiableHeight = workingHeight - minCanHeight,

        //if the legend is at the right then place it and deduct the width
        //if at bottom calculate the space for legend after the vertical axis placed
        drawFullAreaBorder = conf.drawFullAreaBorder = pluckNumber(fcJSONChart.drawfullareaborder, 1),
        legendPos = pluck(fcJSONChart.legendposition, POSITION_BOTTOM).toLowerCase();

        /*
         * place the vertical axis
         */
        //add all axis margin pading
        yAxisNamePadding = pluckNumber(fcJSONChart.yaxisnamepadding, 5);
        yAxisValuesPadding = pluckNumber(fcJSONChart.yaxisvaluespadding, fcJSONChart.labelypadding, 2);

        showPlotBorder = (pluck(fcJSONChart.showplotborder,
            (conf.is3d ? ZEROSTRING : ONESTRING)) === ONESTRING);
            // 3D column chart doesn't show the plotborder by default
            // until we set showplotborder true

        setBorderWidth = conf.plotBorderThickness = (showPlotBorder ?
            (conf.is3d ? 1 : pluckNumber(fcJSONChart.plotborderthickness, 1)) : 0);

        canvasBorderThickness = mathMax(pluckNumber(fcJSONChart.canvasborderthickness, 1), 0);

        toAddV = mathMax(canvasBorderThickness, setBorderWidth / 2);

        

        if (this.defaultSeriesType === 'area' && !drawFullAreaBorder) {
            toAddV = canvasBorderThickness;
        }

        if (yAxisValuesPadding < canvasBorderThickness) {
            yAxisValuesPadding = canvasBorderThickness;
        }

        if (!conf.isDual && hcJSON.chart.marginRight < canvasBorderThickness &&
            fcJSONChart.chartrightmargin === undefined) {
            difference = canvasBorderThickness - hcJSON.chart.marginRight;

            if (workingWidth > minCanWidth + difference) {
                hcJSON.chart.marginRight = canvasBorderThickness;
                workingWidth -= difference;
                minCanWidth = workingWidth * 0.3;
                avaiableWidth = workingWidth - minCanWidth;
            }
        }

        if (hcJSON.legend.enabled && legendPos === POSITION_RIGHT) {
            avaiableWidth -= this.placeLegendBlockRight(hcJSON, fcJSON, avaiableWidth / 2, workingHeight);
        }

        rotateYAxisName = fcJSONChart.rotateyaxisname !== ZEROSTRING;
        if (conf.isDual) {
            isDual = true;
            axisConf = conf[1];
            axisConf.verticalAxisNamePadding = yAxisNamePadding;
            axisConf.verticalAxisValuesPadding = yAxisValuesPadding;
            axisConf.rotateVerticalAxisName = rotateYAxisName;
            axisConf.verticalAxisNameWidth = pluckNumber(fcJSONChart.syaxisnamewidth);
            //now configure the axis
            

            isOnRight = hcJSON.yAxis[1].opposite;
            avaiableWidth -= placeVerticalAxis(hcJSON.yAxis[1], axisConf, hcJSON,
                fcJSON, workingHeight, avaiableWidth / 2, isOnRight, isDual);
        }


        axisConf = conf[0];
        axisConf.verticalAxisNamePadding = yAxisNamePadding;
        axisConf.verticalAxisValuesPadding = yAxisValuesPadding;
        axisConf.rotateVerticalAxisName = rotateYAxisName;
        axisConf.verticalAxisNameWidth = pluckNumber(isDual ? fcJSONChart.pyaxisnamewidth :
            fcJSONChart.yaxisnamewidth);
        //now configure the axis
        avaiableWidth -= placeVerticalAxis(hcJSON.yAxis[0], axisConf, hcJSON, fcJSON,
            workingHeight, avaiableWidth, !isOnRight, isDual);

        // adjust left and right canvas margins
        avaiableWidth -= adjustHorizontalCanvasMargin(hcJSON, fcJSON, avaiableWidth, hcJSON.yAxis[0], hcJSON.yAxis[1]);

        


        //now thw canvas width is fixed(no element to reduce the width
        canvasWidth = avaiableWidth + minCanWidth;

        if (hcJSON.legend.enabled && legendPos !== POSITION_RIGHT) {
            avaiableHeight -= this.placeLegendBlockBottom(hcJSON, fcJSON, canvasWidth,
                avaiableHeight/2);
        }

        /*
         * Now place the Title
         */
        //allowed height may

        avaiableHeight -= titleHeight = titleSpaceManager(hcJSON, fcJSON, canvasWidth,
            avaiableHeight/2);

        /*
         * Now place the horizontal axis
         */
        //add all axis margin pading
        axisConf = conf.x;
        axisConf.horizontalAxisNamePadding = pluckNumber(fcJSONChart.xaxisnamepadding, 5);
        axisConf.horizontalLabelPadding = pluckNumber(fcJSONChart.labelpadding, fcJSONChart.labelxpadding, 2);
        axisConf.labelDisplay = pluck(fcJSONChart.labeldisplay, "auto").toLowerCase();
        axisConf.rotateLabels = pluckNumber(fcJSONChart.rotatelabels, fcJSONChart.rotatexaxislabels, 0);
        axisConf.staggerLines = pluckNumber(fcJSONChart.staggerlines, 2);
        axisConf.slantLabels = pluckNumber(fcJSONChart.slantlabels, fcJSONChart.slantlabel, 0);

        if (axisConf.horizontalLabelPadding < toAddV) {
            axisConf.horizontalLabelPadding = toAddV;
        }
        //set x axis min max
        this.xAxisMinMaxSetter(hcJSON, fcJSON, canvasWidth);

        avaiableHeight -= this.placeHorizontalAxis(hcJSON.xAxis, axisConf, hcJSON, fcJSON,
            canvasWidth, avaiableHeight, minCanWidth);

        // adjust top and bottom the canvas margins here
        avaiableHeight -= adjustVerticalCanvasMargin(hcJSON, fcJSON, avaiableHeight, hcJSON.xAxis);

        // checking after the finalizing of the canvas height whether, and to what extent should we
        // step them.
        if (isDual) {
            stepYAxisNames((minCanHeight + avaiableHeight), hcJSON, fcJSONChart, hcJSON.yAxis[1], conf[1].lYLblIdx);
            adjustVerticalAxisTitle(hcJSON, hcJSON.yAxis[1].title, avaiableHeight);
        }
        stepYAxisNames((minCanHeight + avaiableHeight), hcJSON, fcJSONChart, hcJSON.yAxis[0], conf[0].lYLblIdx);
        adjustVerticalAxisTitle(hcJSON, hcJSON.yAxis[0].title, avaiableHeight);

        if (hcJSON.legend.enabled && legendPos === POSITION_RIGHT) {
            var legendObj = hcJSON.legend, extraWidth,
            maxHeight = minCanHeight + avaiableHeight;
            //no scroll for gradient legend
            if (legendObj.height > maxHeight) {
                if (legendObj.type === 'gradient') {
                    

                }
                else {
                    legendObj.height = maxHeight;
                    legendObj.scroll.enabled = true;
                    extraWidth = (legendObj.scroll.scrollBarWidth = 10) + (legendObj.scroll.scrollBarPadding = 2);
                    legendObj.width += extraWidth;
                    hcJSON.chart.marginRight += extraWidth;
                }
            }
        }

        /*
         * @todo: After porting to RedRaphael is complete we need to check if,
         * this piece of code where the title.x is being set is redundant or not.
         *
        var xc = ((hcJSON.chart.marginLeft - pluckNumber(hcJSON.chart.spacingLeft, 0)) - (hcJSON.chart.marginRight - pluckNumber(hcJSON.chart.spacingRight, 0))) / 2,
        xl = hcJSON.chart.marginLeft - pluckNumber(hcJSON.chart.spacingLeft, 0),
        xr = - (hcJSON.chart.marginRight - pluckNumber(hcJSON.chart.spacingRight, 0));
        switch (hcJSON.title.align) {
            case 'left' :
                hcJSON.title.x = xl;
                break;
            case 'right':
                hcJSON.title.x = xr;
                break;
            default:
                hcJSON.title.x = xc;
        }
        switch (hcJSON.subtitle.align) {
            case 'left' :
                hcJSON.subtitle.x = xl;
                break;
            case 'right':
                hcJSON.subtitle.x = xr;
                break;
            default:
                hcJSON.subtitle.x = xc;
        }*/

        /*
         * if the titles requared space and there has avaleble space the re-alocatethe title space
         */

        



        hcJSON.chart.marginLeft += marginLeftExtraSpace;
        hcJSON.chart.marginTop += marginTopExtraSpace;
        hcJSON.chart.marginBottom += marginBottomExtraSpace;
        hcJSON.chart.marginRight += marginRightExtraSpace;
    },

    /*
     * Bar chart spage management
     */
    barXYSpaceManager = function (hcJSON, fcJSON, width, height) {
        var conf = hcJSON[FC_CONFIG_STRING], avaiableWidth, avaiableHeight, axisConf, axisObj,
        titleHeight = 0, usedWidth = 0, canvasWidth, fcJSONChart = fcJSON.chart, legendPos,
        showPlotBorder, setBorderWidth, canvasBorderThickness, toAddH, difference,
        isDual = false, verticalAxisNamePadding, verticalAxisValuesPadding, rotateVerticalAxisName,

        marginLeftExtraSpace = conf.marginLeftExtraSpace,
        marginTopExtraSpace = conf.marginTopExtraSpace,
        marginBottomExtraSpace = conf.marginBottomExtraSpace,
        marginRightExtraSpace = conf.marginRightExtraSpace,
        workingWidth = width - (marginLeftExtraSpace + marginRightExtraSpace +
            hcJSON.chart.marginRight + hcJSON.chart.marginLeft),
        workingHeight = height - (marginBottomExtraSpace + hcJSON.chart.marginBottom +
            hcJSON.chart.marginTop),

        //calculate the min width, height for canvas
        

        minCanWidth = workingWidth * 0.3,
        minCanHeight = workingHeight * 0.3;

        // calculate the space remaining
        avaiableWidth = workingWidth - minCanWidth;
        avaiableHeight = workingHeight - minCanHeight;

        

        legendPos = pluck(fcJSONChart.legendposition, POSITION_BOTTOM).toLowerCase();

        //if the legend is at the right then place it and deduct the width
        //if at bottom calculate the space for legend after the vertical axis placed
        if (hcJSON.legend.enabled && legendPos === POSITION_RIGHT) {
            avaiableWidth -= this.placeLegendBlockRight(hcJSON, fcJSON, avaiableWidth / 2, workingHeight);
        }
        /*
         * place the vertical axis
         */
        //add all axis margin pading
        //yAxisNamePadding = pluckNumber(fcJSONChart.xaxisnamepadding, 5);
        verticalAxisNamePadding = pluckNumber(fcJSONChart.xaxisnamepadding, 5);
        //yAxisValuesPadding = pluckNumber(fcJSONChart.labelpadding, 2);
        verticalAxisValuesPadding = pluckNumber(fcJSONChart.labelpadding, 2);
        //rotateYAxisName = fcJSONChart.rotatexaxisname !== ZEROSTRING;
        rotateVerticalAxisName = fcJSONChart.rotatexaxisname !== ZEROSTRING;

        showPlotBorder = (pluck(fcJSONChart.showplotborder,
            (conf.is3d ? ZEROSTRING : ONESTRING)) === ONESTRING);
            // 3D column chart doesn't show the plotborder by default
            // until we set showplotborder true

        setBorderWidth = conf.plotBorderThickness = showPlotBorder ?
            (conf.is3d ? 1 : pluckNumber(fcJSONChart.plotborderthickness, 1)) : 0;

        canvasBorderThickness = mathMax(pluckNumber(fcJSONChart.canvasborderthickness, 1), 0);

        

        toAddH = mathMax(canvasBorderThickness, setBorderWidth / 2);

        if (verticalAxisValuesPadding < toAddH) {
            verticalAxisValuesPadding = toAddH;
        }

        if (!conf.isDual && hcJSON.chart.marginRight < canvasBorderThickness &&
            fcJSONChart.chartrightmargin === undefined) {
            difference = canvasBorderThickness - hcJSON.chart.marginRight;
            if (workingWidth > minCanWidth + difference) {
                hcJSON.chart.marginRight = canvasBorderThickness;
                workingWidth -= difference;
                minCanWidth = workingWidth * 0.3;
                avaiableWidth = workingWidth - minCanWidth;
            }
        }

        axisConf = conf.x;
        axisConf.verticalAxisNamePadding = verticalAxisNamePadding;
        axisConf.verticalAxisValuesPadding = verticalAxisValuesPadding;
        axisConf.rotateVerticalAxisName = rotateVerticalAxisName;
        axisConf.verticalAxisNameWidth = pluckNumber(isDual ? fcJSONChart.pxaxisnamewidth :
            fcJSONChart.xaxisnamewidth);

        //now configure the axis
        avaiableWidth -= placeVerticalAxis(hcJSON.xAxis, axisConf, hcJSON, fcJSON,
            workingHeight, avaiableWidth, false, false, workingWidth);

        // adjust left and right canvas margins
        avaiableWidth -= adjustHorizontalCanvasMargin(hcJSON, fcJSON, avaiableWidth, hcJSON.xAxis);

        //now thw canvas width is fixed(no element to reduce the width
        canvasWidth = avaiableWidth + minCanWidth;

        if (hcJSON.legend.enabled && legendPos !== POSITION_RIGHT) {
            avaiableHeight -= this.placeLegendBlockBottom(hcJSON, fcJSON, canvasWidth,
                avaiableHeight/2);
        }

        /*
         * Now place the Title
         */
        //allowed height may

        avaiableHeight -= titleHeight = titleSpaceManager(hcJSON, fcJSON, canvasWidth,
            avaiableHeight/2);

        /*
         * Now place the horizontal axis
         */
        //add all axis margin pading
        axisConf = conf[0];
        axisConf.horizontalAxisNamePadding = pluckNumber(fcJSONChart.yaxisnamepadding, 5);
        axisConf.horizontalLabelPadding = pluckNumber(fcJSONChart.yaxisvaluespadding, 2);
        // Set the labelDisplay as auto for bar charts
        axisConf.labelDisplay = "auto";
        axisConf.staggerLines = pluckNumber(fcJSONChart.staggerlines, 2);
        axisConf.slantLabels = pluckNumber(fcJSONChart.slantlabels, 0);

        axisConf.horizontalLabelPadding = (axisConf.horizontalLabelPadding < canvasBorderThickness ?
            canvasBorderThickness : axisConf.horizontalLabelPadding);

        this.xAxisMinMaxSetter(hcJSON, fcJSON, canvasWidth);

        axisObj = hcJSON.xAxis;

        var plotLines = axisObj.plotLines,
            unitHeight = avaiableHeight / (axisObj.max - axisObj.min),
            canvasTopSpace,
            canvasBottomSpace;

        if (plotLines && plotLines.length) {

            canvasTopSpace = ((plotLines[0].value - axisObj.min) * unitHeight),
            canvasBottomSpace = ((axisObj.max - plotLines[plotLines.length - 1].value) * unitHeight);

            if (conf.isBar) {
                if (setBorderWidth > canvasTopSpace) {
                    axisObj.min -= ((setBorderWidth - canvasTopSpace) / (2 * unitHeight));
                }

                if (setBorderWidth > canvasBottomSpace) {
                    axisObj.max += ((setBorderWidth - canvasBottomSpace) /  (2 * unitHeight));
                }
            }
        }

        // function (axisObj, axisConf, hcJSON, fcJSON, width, maxHeight)
        avaiableHeight -= this.placeHorizontalAxis(hcJSON.yAxis[0], axisConf, hcJSON,
            fcJSON, canvasWidth, avaiableHeight, minCanWidth);

        // adjust top and bottom the canvas margins here
        avaiableHeight -= adjustVerticalCanvasMargin(hcJSON, fcJSON, avaiableHeight, hcJSON.yAxis[0]);

        stepYAxisNames((minCanHeight + avaiableHeight), hcJSON, fcJSONChart, hcJSON.xAxis, conf.x.lYLblIdx, true);
        adjustVerticalAxisTitle(hcJSON, hcJSON.xAxis.title, avaiableHeight);

        if (hcJSON.legend.enabled && legendPos === POSITION_RIGHT) {
            var legendObj = hcJSON.legend, extraWidth,
            maxHeight = minCanHeight + avaiableHeight;

            if (legendObj.height > maxHeight) {
                legendObj.height = maxHeight;
                legendObj.scroll.enabled = true;
                extraWidth = (legendObj.scroll.scrollBarWidth = 10) + (legendObj.scroll.scrollBarPadding = 2);
                legendObj.width += extraWidth;
                hcJSON.chart.marginRight += extraWidth;
            }
            legendObj.y = 20;
        }

        


        /*
         * if the titles requared space and there has avaleble space the re-alocatethe title space
         */
        


        hcJSON.chart.marginLeft += marginLeftExtraSpace;
        hcJSON.chart.marginTop += marginTopExtraSpace;
        hcJSON.chart.marginBottom += marginBottomExtraSpace;
        hcJSON.chart.marginRight += marginRightExtraSpace;
    },

    adjustVerticalAxisTitle = lib.adjustVerticalAxisTitle = function (hcJSON, titleObj, availableHeight) {
        if (!titleObj || !titleObj.text) {
            return;
        }

        var titleText = titleObj.text, conf = hcJSON[FC_CONFIG_STRING], SmartLabel = conf.smartLabel, smartTitle,
        heightMax = 2 * Math.min(hcJSON.chart.marginTop, hcJSON.chart.marginBottom) + availableHeight,
        totalHeight = availableHeight + hcJSON.chart.marginTop + hcJSON.chart.marginBottom;

        if (titleObj.style) {
            SmartLabel.setStyle(titleObj.style)
        }

        smartTitle = SmartLabel.getOriSize(titleText);
        if (titleObj.centerYAxisName === undefined) {
            titleObj.centerYAxisName = true;
        }

        if (titleObj.rotation == "0") {
            if (smartTitle.height > heightMax) {
                titleObj.y = ((totalHeight / 2) - ((availableHeight / 2) + hcJSON.chart.marginTop)) / 2;
                titleObj.centerYAxisName = false;
            }
        } else if (smartTitle.width > heightMax) {
            titleObj.y = ((totalHeight / 2) - ((availableHeight / 2) + hcJSON.chart.marginTop));
            titleObj.centerYAxisName = false;
        }
    },

    adjustVerticalCanvasMargin = lib.adjustVerticalCanvasMargin = function (hcJSON, fcJSON, avaiableHeight, xAxis) {

        var fcJSONChart = fcJSON.chart, extraMargin = 0, topChange = 0, bottomChange = 0,
        canvasTopMargin = pluckNumber(fcJSONChart.canvastopmargin, 0),
        canvasBottomMargin = pluckNumber(fcJSONChart.canvasbottommargin, 0),
        totalVerticalMargin = canvasTopMargin + canvasBottomMargin,
        topMarginPercent = canvasTopMargin / totalVerticalMargin,
        bottomMarginPercent = 1 - topMarginPercent,
        actualTopMargin = hcJSON.chart.marginTop,
        actualBottomMargin = hcJSON.chart.marginBottom;

        if (canvasBottomMargin > actualBottomMargin) {
            extraMargin += (canvasBottomMargin - actualBottomMargin);
        }
        if (canvasTopMargin > actualTopMargin) {
            extraMargin += (canvasTopMargin - actualTopMargin);
        }
        if (extraMargin > avaiableHeight) {
            if (canvasTopMargin > actualTopMargin && canvasBottomMargin > actualBottomMargin) {
                topChange = (avaiableHeight * topMarginPercent);
                bottomChange = (avaiableHeight * bottomMarginPercent);
            } else {
                if (canvasTopMargin > actualTopMargin) {
                    topChange = avaiableHeight;
                } else {
                    bottomChange = avaiableHeight;
                }
            }
        } else if (extraMargin > 0) {
            if (canvasBottomMargin > actualBottomMargin) {
                bottomChange = (canvasBottomMargin - actualBottomMargin);
            }
            if (canvasTopMargin > actualTopMargin) {
                topChange = (canvasTopMargin - actualTopMargin);
            }
        }

        if (topChange) {
            hcJSON.chart.marginTop += topChange;
        }

        if (bottomChange) {
            hcJSON.chart.marginBottom += bottomChange;
            if (xAxis && xAxis.title) {
                xAxis.title.margin += bottomChange;
            }
        }

        return (topChange + bottomChange);
    },

    adjustHorizontalCanvasMargin = lib.adjustHorizontalCanvasMargin = function (hcJSON, fcJSON, avaiableWidth,
        leftYAxis, rightYAxis) {

        var fcJSONChart = fcJSON.chart,
        canvasLeftMargin = pluckNumber(fcJSONChart.canvasleftmargin, 0),
        canvasRightMargin = pluckNumber(fcJSONChart.canvasrightmargin, 0),
        totalHorizontalMargin = canvasLeftMargin + canvasRightMargin,
        leftMarginPercent = canvasLeftMargin / totalHorizontalMargin,
        rightMarginPercent = 1 - leftMarginPercent, extraMargin = 0,
        actualLeftMargin = hcJSON.chart.marginLeft, actualRightMargin = hcJSON.chart.marginRight,
        leftChange = 0, rightChange = 0;

        if (canvasLeftMargin > actualLeftMargin) {
            extraMargin += (canvasLeftMargin - actualLeftMargin);
        }
        if (canvasRightMargin > actualRightMargin) {
            extraMargin += (canvasRightMargin - actualRightMargin);
        }
        if (extraMargin > avaiableWidth) {
            if (canvasLeftMargin > actualLeftMargin && canvasRightMargin > actualRightMargin) {
                leftChange = (avaiableWidth * leftMarginPercent);
                rightChange = (avaiableWidth * rightMarginPercent);
            } else {
                if (canvasRightMargin > actualRightMargin) {
                    rightChange = avaiableWidth;
                } else {
                    leftChange = avaiableWidth;
                }
            }
        } else if (extraMargin > 0) {
            if (canvasLeftMargin > actualLeftMargin) {
                leftChange = (canvasLeftMargin - actualLeftMargin);
            }

            if (canvasRightMargin > actualRightMargin) {
                rightChange = (canvasRightMargin - actualRightMargin);
            }
        }

        if (leftChange) {
            hcJSON.chart.marginLeft += leftChange;
            if (leftYAxis && leftYAxis.title) {
                leftYAxis.title.margin += leftChange;
            }
        }

        if (rightChange) {
            hcJSON.chart.marginRight += rightChange;
            if (rightYAxis && rightYAxis.title) {
                rightYAxis.title.margin += rightChange;
            }
        }

        return (rightChange + leftChange);
    },

    //post Series Adition Function
    postSeriesAddition = function (hcObj, fcObj, width, height) {
        var conf = hcObj[FC_CONFIG_STRING],
                isBar = conf.isBar,
                is3d = conf.is3d,
                rotateValues = hcObj.chart.rotateValues && !isBar ? 270 : 0,
                //for the first y axis
                axisStack = conf[0],
                stacking100Percent = axisStack && axisStack.stacking100Percent,
                showPercetValue = conf.showPercentValues || conf.showPercentInToolTip;

        //show the stack total if requared
        if (this.isStacked && (conf.showStackTotal || stacking100Percent || showPercetValue)) {
            var plotSpacePercent = conf.plotSpacePercent,
                    defaultSeriesType = hcObj.chart.defaultSeriesType,
                    seriesType,
                    totalStacks,
                    axisConfStack,
                    groupWidthPercent = 1 - plotSpacePercent,
                    groupWidthPercent = 1 - (2 * plotSpacePercent),
                    perStackWidth,
                    stackIndex,
                    startStackIndex,
                    position,
                    length,
                    catPosition,
                    stackArr,
                    stack,
                    value,
                    seriesArr,
                    stackedDataArr,
                    series = hcObj.series,
                    seri,
                    i,
                    ln,
                    point,
                    pointValue,
                    labelPosition,
                    style = extend2({}, hcObj.plotOptions.series.dataLabels.style),
                    labelFontSize = parseFloat(style.fontSize),
                    labeloffsetScale,
                    labelInsidePlot = !axisStack.stacking100Percent;
            style.color = hcObj.plotOptions.series.dataLabels.color;

            axisConfStack = axisStack.stack;

            for (seriesType in axisConfStack) {
                totalStacks = axisConfStack[seriesType].length;
                perStackWidth = groupWidthPercent / totalStacks;
                startStackIndex = -(groupWidthPercent - perStackWidth) / 2;
                if (stacking100Percent || showPercetValue) {
                    //get all series tht has same series type and belongs to 0th y-axis
                    seriesArr = [];
                    for (i = 0, ln = series.length; i < ln; i += 1) {
                        seri = series[i];
                        if (!seri.yAxis && pluck(seri.type, defaultSeriesType) === seriesType) {
                            seriesArr.push(seri);
                        }
                    }
                }

                for (stackIndex = 0; stackIndex < totalStacks; stackIndex += 1,
                        startStackIndex += perStackWidth) {
                    stackArr = axisConfStack[seriesType][stackIndex];
                    if (stacking100Percent || showPercetValue) {
                        //get all series tht has same startStackIndex from seriesArr
                        stackedDataArr = [];
                        for (i = 0, ln = seriesArr.length; i < ln; i += 1) {
                            seri = seriesArr[i];
                            if (pluckNumber(seri.columnPosition, 0) === stackIndex) {
                                stackedDataArr.push(seri.data);
                            }
                        }
                    }
                    if (stackArr && stackArr.length) {
                        for (catPosition = 0, length = stackArr.length;
                                catPosition < length; catPosition += 1) {
                            stack = stackArr[catPosition];
                            //if there has valid data por this stach index
                            if (stack) {
                                value = (stack.n || 0) + (stack.p || 0);
                                if (conf.showStackTotal) {
                                    position = catPosition;
                                    labelPosition = position + startStackIndex;
                                    labeloffsetScale = value < 0 ? stack.n : stack.p;

                                    //add the total value
                                    hcObj.xAxis.plotLines.push({
                                        value: labelPosition,
                                        width: 0,
                                        isVline: labelInsidePlot,
                                        isTrend: !labelInsidePlot,
                                        zIndex: 4,
                                        _isStackSum: 1,
                                        _catPosition: catPosition,
                                        _stackIndex: stackIndex,
                                        label: {
                                            align: POSITION_CENTER,
                                            textAlign: !is3d && rotateValues === 270 ?
                                                    (value < 0 ? POSITION_RIGHT : POSITION_LEFT) :
                                                    (isBar ? value < 0 ? POSITION_RIGHT : POSITION_LEFT : POSITION_CENTER),
                                            offsetScale: labelInsidePlot ? labeloffsetScale : undefined,
                                            offsetScaleIndex: 0,
                                            rotation: rotateValues,
                                            style: style,
                                            verticalAlign: POSITION_TOP,
                                            y: isBar ? 0 : (value < 0 ?
                                                    (rotateValues === 270 ? 4 : labelFontSize) : -4),
                                            x: 0,
                                            text: conf.numberFormatter.yAxis(value)
                                        }
                                    });
                                }
                                //manipulate values for 100percent stack
                                if (stacking100Percent || showPercetValue) {
                                    for (i = 0, ln = stackedDataArr.length; i < ln; i += 1) {
                                        point = stackedDataArr[i][catPosition];
                                        if (point.y || point.y === 0) {
                                            pointValue = point.y / value * 100;
                                            if (stacking100Percent) {
                                                point.y = pointValue;
                                                if (point.previousY || point.previousY === 0) {
                                                    point.previousY = point.previousY / value * 100;
                                                }
                                            }
                                            //set display value
                                            if (point.showPercentValues) {
                                                point.displayValue = this.numberFormatter.percentValue(pointValue);
                                            }
                                            //set tooltip
                                            if (point.showPercentInToolTip) {
                                                point.toolText = point.toolText + (parseInt(pointValue * 100, 10) / 100) + '%';
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
    };

    //// add the base
    chartAPI('base', {
        useScaleRecursively: true,
        tooltipConstraint : 'chart',
        rendererId: 'root',

        draw: function (options, callback) {
            var iapi = this,
                renderer = iapi.renderer,
                vars = iapi.chartInstance.jsVars,
                action = 'reinit',
                drawingStartTime = new Date();
                iapi.drawingLatency = iapi.drawingLatency || 0;

            if (!renderer) {
                vars._lastpaper && (vars._lastpaper = vars._lastpaper.dispose());
                action = 'init';
                renderer = iapi.renderer = new chartAPI('renderer.' + iapi.rendererId);
            }

            return renderer[action](iapi, options, function () {
                vars._lastpaper = renderer;
                iapi.drawingLatency = (new Date()) - drawingStartTime;
                callback && callback.apply(this, arguments);
            });
        },

        init: function (container, dataObj) {

            var iapi = this,
                chartObj = iapi.chartInstance || arguments[2], // legacy
                vars = chartObj.jsVars,
                reflowData = vars._reflowData || (vars._reflowData = {}),
                reflowClean = vars._reflowClean,
                reflowJSON,
                cleanedData,
                chartAttrs,
                hcJSON;

            //clone FC data so that any modiffication on it will not effect the original
            iapi.dataObj = dataObj = extend2({}, dataObj);

            // Clone the chart obj from graph or blank object
            chartAttrs = dataObj.chart = (dataObj.chart || dataObj.graph ||
                    dataObj.map || {});
            delete dataObj.graph;
            delete dataObj.map;

            // restore state data
            if (reflowData && !iapi.stateless) {
                reflowJSON = reflowData.hcJSON;
                delete reflowData.hcJSON;
                extend2(iapi, reflowData, true);
                iapi.preReflowAdjustments &&
                    iapi.preReflowAdjustments.call(this);
                reflowData.hcJSON = reflowJSON;
                reflowJSON = null;
            }


            iapi.containerElement = container;
            iapi.config = {};

            iapi.smartLabel = new SmartLabelManager(chartObj.id,
                    document.getElementsByTagName('body')[0] || container,
                    pluckNumber(chartAttrs.useellipseswhenoverflow,
                    chartAttrs.useellipsewhenoverflow, 1));

            iapi.linkClickFN = getLinkAction(dataObj, chartObj);

            iapi.numberFormatter = new NumberFormatter(dataObj.chart, iapi);

            if (!iapi.standaloneInit) {
                return new lib.createDialog(container, vars.msgStore.ChartNotSupported);
            }

            //call the chart conf function
            hcJSON = iapi.chart(container.offsetWidth || parseFloat(container.style.width),
                container.offsetHeight || parseFloat(container.style.height), chartObj);

            if (reflowData && !iapi.stateless) {
                if (reflowData.hcJSON) {
                    extend2(hcJSON, reflowData.hcJSON, true);
                }
                iapi.postReflowAdjustments &&
                        iapi.postReflowAdjustments.call(this);
                // delete cleaned data
                if (reflowClean && iapi.cleanedData) {
                    iapi.cleanedData(iapi, reflowClean);
                    iapi.cleanedData(reflowData, reflowClean);//delete all updates also
                }
            }

            return hcJSON;
        },


        chart: function (width, height) {
            var iapi = this,
                chartName = iapi.name,
                obj = iapi.dataObj,
                FCChartObj = obj.chart,
                hc,
                is3d,
                zeroPlaneColor,
                zeroPlaneAlpha,
                stack100percent,
                smartLabel,
                isPie,
                defaultSeries = iapi.defaultSeriesType,
                conf,
                isBar,
                plotOptions,
                showBorder,
                showCanvasBorder,
                palleteString,
                isRoundEdges,
                xAxis,
                HCChartObj;

            //set the default tooltip charecter seperator if not defined
            // We don't need to set "tooltipsepchar" here
            //obj.chart.tooltipsepchar = pluck(FCChartObj.tooltipsepchar, COMMASTRING);

            //creade defaule stub
            hc = HCstub(obj, width, height, this);
            // HighChart Chart object
            HCChartObj = hc.chart;
            //HighChart xAxis
            xAxis = hc.xAxis;
            //HighChart conf obj
            conf = hc[FC_CONFIG_STRING];

            if (iapi.postHCJSONCreation) {
                iapi.postHCJSONCreation.call(iapi, hc);
            }

            //create the smartLabel instance
            hc.labels.smartLabel = smartLabel = conf.smartLabel = this.smartLabel;
            //save the width and height
            conf.width = width;
            conf.height = height;
            plotOptions = hc.plotOptions;


            conf.isDual = this.isDual;
            //create the numberformatter instance
            conf.numberFormatter = this.numberFormatter;
            //create the numberformatter instance
            conf.axisGridManager = new axisLabelAdder (defaultSeries, FCChartObj);

            //is the chart 3d
            HCChartObj.is3D = is3d = conf.is3d = /3d$/.test(defaultSeries);
            HCChartObj.isBar = isBar = conf.isBar = this.isBar;
            isPie = /^pie/.test(defaultSeries);

            // If roundedges is enabled
            isRoundEdges = FCChartObj.useroundedges == 1,
            // Whether the cosmetics is to use 3D
            palleteString = is3d ? chartPaletteStr.chart3D : chartPaletteStr.chart2D;
            //save the FC Linkclick function
            HCChartObj.events.click = hc.plotOptions.series.point.events.click = this.linkClickFN;

            //fiend defaultseries type depemding upon chart's name
            HCChartObj.defaultSeriesType = defaultSeries;
            ////palette////
            var paletteIndex = FCChartObj.palette > 0 && FCChartObj.palette < 6 ?
            FCChartObj.palette : pluckNumber(this.paletteIndex, 1);
            ////reduce by 1 for array positining
            paletteIndex -= 1;
            //save the palette index for further reference
            HCChartObj.paletteIndex = paletteIndex;

            // Flag to use per-point datalabel color
            HCChartObj.usePerPointLabelColor = FCChartObj.colorlabelsfromplot == ONESTRING;

            // If we're plotting round edges, we necessarily apply shadow
            // To give the contrasting effect.
            HCChartObj.useRoundEdges = (isRoundEdges && !is3d && !this.distributedColumns &&
                this.defaultSeriesType !== 'pie');

            // Full Chart as a hotspot
            if (pluck(FCChartObj.clickurl) !== undefined) {
                HCChartObj.link = FCChartObj.clickurl;
                HCChartObj.style.cursor = 'pointer';
                //change the point Click event ot make similar as FC
                hc.plotOptions.series.point.events.click = function () {
                    HCChartObj.events.click.call({
                        link : FCChartObj.clickurl
                    });
                };
            }

            //////////Chart font style////////////////////
            var inCanfontFamily = pluck(FCChartObj.basefont, 'Verdana'),
            inCanfontSize =  pluckFontSize(FCChartObj.basefontsize, 10),
            inCancolor = pluck(FCChartObj.basefontcolor, defaultPaletteOptions[palleteString.
                baseFontColor][paletteIndex]),
            outCanfontFamily = pluck(FCChartObj.outcnvbasefont, inCanfontFamily),
            fontSize = pluckFontSize(FCChartObj.outcnvbasefontsize, inCanfontSize),
            outCanfontSize = fontSize + PXSTRING,
            outCancolor = pluck(FCChartObj.outcnvbasefontcolor, inCancolor).
            replace(/^#?([a-f0-9]+)/ig, '#$1'),
            outCanLineHeight, inCanLineHeight, axisTitleLineHeight,
            baseFontSize = inCanfontSize;


            inCanfontSize =  inCanfontSize + PXSTRING;
            inCancolor = inCancolor.replace(/^#?([a-f0-9]+)/ig, '#$1');

            //create style for tredn tendtext
            //save it in the hc JSON for ferther refrence
            

            conf.trendStyle = conf.outCanvasStyle = {
                fontFamily: outCanfontFamily,
                color: outCancolor,
                fontSize:  outCanfontSize
            };
            outCanLineHeight = setLineHeight(conf.trendStyle);

            conf.inCanvasStyle = {
                fontFamily: inCanfontFamily,
                fontSize:  inCanfontSize,
                color: inCancolor
            };

            inCanLineHeight = setLineHeight(conf.inCanvasStyle);
            conf.divlineStyle = {
                fontFamily: inCanfontFamily,
                fontSize:  inCanfontSize,
                color: inCancolor,
                lineHeight : inCanLineHeight
            };

            xAxis.labels.style = {//style for x axis
                fontFamily: outCanfontFamily,
                fontSize:  outCanfontSize,
                lineHeight : outCanLineHeight,
                color: outCancolor
            };
            xAxis.steppedLabels.style = {//style for x axis
                fontFamily: outCanfontFamily,
                fontSize:  outCanfontSize,
                lineHeight : outCanLineHeight,
                color: outCancolor,
                visibility: 'hidden'
            };
            //style for pyasis
            hc.yAxis[0].labels.style = {
                fontFamily: outCanfontFamily,
                fontSize:  outCanfontSize,
                lineHeight : outCanLineHeight,
                color: outCancolor
            };
            //style for syaxis
            hc.yAxis[1].labels.style = {
                fontFamily: outCanfontFamily,
                fontSize:  outCanfontSize,
                lineHeight : outCanLineHeight,
                color: outCancolor
            };
            //legend
            hc.legend.itemStyle = {
                fontFamily: outCanfontFamily,
                fontSize:  outCanfontSize,
                lineHeight : outCanLineHeight,
                color: outCancolor
            };
            hc.legend.itemHiddenStyle = {
                fontFamily: outCanfontFamily,
                fontSize:  outCanfontSize,
                lineHeight : outCanLineHeight
            };
            ///datalabels
            hc.plotOptions.series.dataLabels.style = {
                fontFamily: inCanfontFamily,
                fontSize:  inCanfontSize,
                lineHeight : inCanLineHeight,
                color: inCancolor
            };
            //special attr for datalabels color
            

            hc.plotOptions.series.dataLabels.color = hc.plotOptions.series.dataLabels.style.color;
            ///tooltip
            hc.tooltip.style = {
                fontFamily: inCanfontFamily,
                fontSize:  inCanfontSize,
                lineHeight : inCanLineHeight,
                color: inCancolor
            };
            ///set the caption font style
            hc.title.style = {
                fontFamily: outCanfontFamily,
                color: outCancolor,
                fontSize:  (fontSize + 3) + PXSTRING,
                fontWeight: pluckNumber(FCChartObj.captionfontbold) === 0 ? 'normal' : 'bold'
            };
            setLineHeight(hc.title.style);
            hc.subtitle.style = {
                fontFamily: outCanfontFamily,
                color: outCancolor,
                fontSize:  (fontSize + pluckNumber(this.subTitleFontSizeExtender, 1)) + PXSTRING,
                fontWeight: getValidValue(this.subTitleFontWeight, 'bold')
            };
            setLineHeight(hc.subtitle.style);
            //set the style for the xAxis name
            xAxis.title.style = {
                fontFamily: outCanfontFamily,
                color: outCancolor,
                fontSize:  outCanfontSize,
                fontWeight: pluckNumber(FCChartObj.subcaptionfontbold) === 0 ? 'normal' : 'bold'
            };
            axisTitleLineHeight = setLineHeight(xAxis.title.style);
            //set the style for the primary yAxis name
            hc.yAxis[0].title.style = {
                fontFamily: outCanfontFamily,
                color: outCancolor,
                fontSize:  outCanfontSize,
                lineHeight : axisTitleLineHeight,
                fontWeight: 'bold'
            };
            //set the style for the secinadry yAxis name
            hc.yAxis[1].title.style = {
                fontFamily: outCanfontFamily,
                color: outCancolor,
                fontSize:  outCanfontSize,
                lineHeight : axisTitleLineHeight,
                fontWeight: 'bold'
            };

            HCChartObj.overlapColumns = pluckNumber(FCChartObj[isBar && 'overlapbars' || 'overlapcolumns'],
                is3d ? 0 : 1);

            //Annotations default style
            hc.orphanStyles = {
                defaultStyle: {
                    style: extend2({}, conf.inCanvasStyle)
                },
                connectorlabels: {
                    style: extend2({}, hc.plotOptions.series.dataLabels)
                },
                vyaxisname: {//for candle stick chart's volume axis
                    style: extend2({}, hc.yAxis[0].title.style)
                }
            };

            ///Heat-Map extra label's style
            hc.plotOptions.series.dataLabels.tlLabelStyle = {
                fontFamily:	getValidValue(FCChartObj.tlfont, inCanfontFamily),
                color: getFirstColor(getValidValue(FCChartObj.tlfontcolor, inCancolor)),
                fontSize: pluckFontSize(FCChartObj.tlfontsize, baseFontSize) + PX
            };
            // calculate line height
            setLineHeight(hc.plotOptions.series.dataLabels.tlLabelStyle);
            
            hc.plotOptions.series.dataLabels.trLabelStyle = {
                fontFamily:	getValidValue(FCChartObj.trfont, inCanfontFamily),
                color: getFirstColor(getValidValue(FCChartObj.trfontcolor, inCancolor)),
                fontSize: pluckFontSize(FCChartObj.trfontsize, baseFontSize) + PX
            };
            // calculate line height
            setLineHeight(hc.plotOptions.series.dataLabels.trLabelStyle);
            
            hc.plotOptions.series.dataLabels.blLabelStyle = {
                fontFamily:	getValidValue(FCChartObj.blfont, inCanfontFamily),
                color: getFirstColor(getValidValue(FCChartObj.blfontcolor, inCancolor)),
                fontSize: pluckFontSize(FCChartObj.blfontsize, baseFontSize) + PX
            };
            // calculate line height
            setLineHeight(hc.plotOptions.series.dataLabels.blLabelStyle);
            
            hc.plotOptions.series.dataLabels.brLabelStyle = {
                fontFamily:	getValidValue(FCChartObj.brfont, inCanfontFamily),
                color: getFirstColor(getValidValue(FCChartObj.brfontcolor, inCancolor)),
                fontSize: pluckFontSize(FCChartObj.brfontsize, baseFontSize) + PX
            };
            // calculate line height
            setLineHeight(hc.plotOptions.series.dataLabels.brLabelStyle);
            
            //////set styles//////////
            this.parseStyles(hc);

            //after applying the style do the


            // Deleting background style for not to effect the background cosmetics
            // for 3.2.2 relelease.
            delete hc.xAxis.labels.style.backgroundColor;
            delete hc.xAxis.labels.style.borderColor;

            delete hc.yAxis[0].labels.style.backgroundColor;
            delete hc.yAxis[0].labels.style.borderColor;

            delete hc.yAxis[1].labels.style.backgroundColor;
            delete hc.yAxis[1].labels.style.borderColor;


            // Point configuration to show label tooltext and data values
            conf.showTooltip = pluckNumber(FCChartObj.showtooltip, this.showtooltip, 1);
            conf.tooltipSepChar = pluck(FCChartObj.tooltipsepchar, this.tooltipsepchar, COMMASPACE);
            conf.showValues = pluckNumber(FCChartObj.showvalues, this.showValues, 1);
            conf.seriesNameInToolTip = pluckNumber(FCChartObj.seriesnameintooltip, 1);

            conf.showVLines = pluckNumber(FCChartObj.showvlines, 1);
            conf.showVLinesOnTop = pluckNumber(FCChartObj.showvlinesontop, 0);
            conf.showVLineLabels = pluckNumber(FCChartObj.showvlinelabels, this.showVLineLabels, 1);
            conf.showVLineLabelBorder = pluckNumber(FCChartObj.showvlinelabelborder, 1);
            conf.rotateVLineLabels = pluckNumber(FCChartObj.rotatevlinelabels, 0);
            conf.vLineColor = pluck(FCChartObj.vlinecolor, "333333");
            conf.vLineThickness = pluck(FCChartObj.vlinethickness, 1);
            conf.vLineAlpha = pluckNumber(FCChartObj.vlinealpha, 80);
            conf.vLineLabelBgColor = pluck(FCChartObj.vlinelabelbgcolor, "ffffff");
            conf.vLineLabelBgAlpha = pluckNumber(FCChartObj.vlinelabelbgalpha, is3d ? 50 : 100);

            conf.trendlineColor = pluck(FCChartObj.trendlinecolor, "333333");
            conf.trendlineThickness = pluck(FCChartObj.trendlinethickness, 1);
            conf.trendlineAlpha = pluckNumber(FCChartObj.trendlinealpha);
            conf.showTrendlinesOnTop = pluck(FCChartObj.showtrendlinesontop, 0);
            conf.trendlineValuesOnOpp = pluck(FCChartObj.trendlinevaluesonopp, FCChartObj.trendlinevaluesonright, 0);
            conf.trendlinesAreDashed = pluckNumber(FCChartObj.trendlinesaredashed, 0);
            conf.trendlinesDashLen = pluckNumber(FCChartObj.trendlinedashlen, 5);
            conf.trendlinesDashGap = pluckNumber(FCChartObj.trendlinedashgap, 2);
            conf.showTrendlines = pluckNumber(FCChartObj.showtrendlines, 1);
            conf.showTrendlineLabels = pluckNumber(FCChartObj.showtrendlinelabels, this.showTrendlineLabels, 1);

            conf.flatScrollBars = pluckNumber(FCChartObj.flatscrollbars, 0);
            conf.scrollBar3DLighting = pluckNumber(FCChartObj.scrollbar3dlighting, 1);


            


            hc.plotOptions.series.connectNullData = pluckNumber(FCChartObj.connectnulldata, 0);
            // create the back-ground color
            ////Finaly Set the Plot and Background color[must be modifyed al last as margins may be changed any where]
            HCChartObj.backgroundColor = {
                FCcolor : {
                    color : pluck(FCChartObj.bgcolor, defaultPaletteOptions[palleteString.bgColor][paletteIndex]),
                    alpha : pluck(FCChartObj.bgalpha, defaultPaletteOptions[palleteString.bgAlpha][paletteIndex]),
                    angle : pluck(FCChartObj.bgangle, defaultPaletteOptions[palleteString.bgAngle][paletteIndex]),
                    ratio : pluck(FCChartObj.bgratio, defaultPaletteOptions[palleteString.bgRatio][paletteIndex])
                }
            };
            HCChartObj.borderRadius = pluckNumber(FCChartObj.borderradius, 0);

            // Whether to rotate the values
            HCChartObj.rotateValues = pluckNumber(FCChartObj.rotatevalues, 0);

            // placevaluesinside
            HCChartObj.placeValuesInside = pluckNumber(FCChartObj.placevaluesinside, 0);

            // valuePosition for line and area
            HCChartObj.valuePosition = pluck(FCChartObj.valueposition, 'auto');

            // valuePosition for line and area
            HCChartObj.valuePadding = pluckNumber(FCChartObj.valuepadding, 2);

            HCChartObj.borderColor = convertColor(pluck(FCChartObj.bordercolor, is3d ? '#666666' :
                defaultPaletteOptions.borderColor[paletteIndex]),
            pluck(FCChartObj.borderalpha, is3d ? '100' : defaultPaletteOptions.borderAlpha[paletteIndex]));

            showBorder = pluckNumber(FCChartObj.showborder, is3d ? 0 : 1);

            HCChartObj.borderWidth = showBorder ? pluckNumber(FCChartObj.borderthickness, 1) : 0;

            HCChartObj.plotBorderColor = convertColor(pluck(FCChartObj.canvasbordercolor,
                defaultPaletteOptions.canvasBorderColor[paletteIndex]),
            pluck(FCChartObj.canvasborderalpha, defaultPaletteOptions.canvasBorderAlpha[paletteIndex]));
            if (FCChartObj.showcanvasborder !== '0') {
                showCanvasBorder = Boolean(pluck(FCChartObj.canvasborderthickness, isRoundEdges ? 0 : 1));
                //if any axis has its own line drawing we force canvas without border
                if(FCChartObj.showaxislines === '1' || FCChartObj.showxaxisline === '1'
                                        || FCChartObj.showyaxisline === '1'){
                    //but we only force if user explicitly has not set border
                    (FCChartObj.showcanvasborder !== '1') &&  (showCanvasBorder = 0);
                }
            }

            HCChartObj.plotBorderWidth = is3d || !showCanvasBorder ? 0 : pluckNumber(FCChartObj.canvasborderthickness,
                                                                                     this.canvasborderthickness,
                                                                                     HCChartObj.useRoundEdges ? 1 : 2);

            // Chart background image
            /* Attributes for customize bg image
                bgImage (String)
                bgImageAlpha	(0-100)
                bgImageDisplayMode	(none, stretch, center, fill, fit, tile )
                bgImageVAlign	(top, middle, bottom)
                bgImageHAlign	(left, middle, right)
                bgImageScale	(0-300)
             */
            var bgImageDisplayMode, bgImageVAlign, bgImageHAlign,
            TILE = 'tile',
            FILL = 'fill',
            FIT = 'fit';
            HCChartObj.bgSWF = pluck(FCChartObj.bgimage, FCChartObj.bgswf);
            HCChartObj.bgSWFAlpha = pluckNumber(FCChartObj.bgimagealpha, FCChartObj.bgswfalpha, 100);
            // Set background swf param
            bgImageDisplayMode = pluck(FCChartObj.bgimagedisplaymode, "none").toLowerCase();
            bgImageVAlign = getValidValue(FCChartObj.bgimagevalign, BLANKSTRING).toLowerCase();
            bgImageHAlign = getValidValue(FCChartObj.bgimagehalign, BLANKSTRING).toLowerCase();
            //when background mode is tile, fill and fit then default value of vertical alignment and horizontal alignment will be middle and middle
            if (bgImageDisplayMode == TILE || bgImageDisplayMode == FILL || bgImageDisplayMode == FIT) {
                if (bgImageVAlign != POSITION_TOP && bgImageVAlign != POSITION_MIDDLE && bgImageVAlign != POSITION_BOTTOM) {
                    bgImageVAlign = POSITION_MIDDLE;
                }
                if (bgImageHAlign != POSITION_LEFT && bgImageHAlign != POSITION_MIDDLE && bgImageHAlign != POSITION_RIGHT) {
                    bgImageHAlign = POSITION_MIDDLE;
                }
            }
            else {
                if (bgImageVAlign != POSITION_TOP && bgImageVAlign != POSITION_MIDDLE && bgImageVAlign != POSITION_BOTTOM) {
                    bgImageVAlign = POSITION_TOP;
                }
                if (bgImageHAlign != POSITION_LEFT && bgImageHAlign != POSITION_MIDDLE && bgImageHAlign != POSITION_RIGHT) {
                    bgImageHAlign = POSITION_LEFT;
                }
            }
            HCChartObj.bgImageDisplayMode = bgImageDisplayMode;
            HCChartObj.bgImageVAlign = bgImageVAlign;
            HCChartObj.bgImageHAlign = bgImageHAlign;
            HCChartObj.bgImageScale = pluckNumber(FCChartObj.bgimagescale, 100);


            // LOGO URL (foreground) logo parameters
            HCChartObj.logoURL = getValidValue(FCChartObj.logourl);
            HCChartObj.logoPosition = pluck(FCChartObj.logoposition, 'tl').toLowerCase();
            HCChartObj.logoAlpha = pluckNumber(FCChartObj.logoalpha, 100);
            HCChartObj.logoLink = getValidValue(FCChartObj.logolink);
            HCChartObj.logoScale = pluckNumber(FCChartObj.logoscale, 100);
            HCChartObj.logoLeftMargin = pluckNumber(FCChartObj.logoleftmargin, 0);
            HCChartObj.logoTopMargin = pluckNumber(FCChartObj.logotopmargin, 0);

            //toolbar button parameters
            var toolbar = HCChartObj.toolbar = {button: {}},
                button = toolbar.button,
                bSymbolPadding,
                bPosition,
                bHAlign,
                bVAlign,
                vDirection,
                hDirection;

            button.scale = pluckNumber(FCChartObj.toolbarbuttonscale, 1.15);
            button.width = pluckNumber(FCChartObj.toolbarbuttonwidth, 15);
            button.height = pluckNumber(FCChartObj.toolbarbuttonheight, 15);
            button.radius = pluckNumber(FCChartObj.toolbarbuttonradius, 2);
            button.spacing = pluckNumber(FCChartObj.toolbarbuttonspacing, 5);

            button.fill = convertColor(pluck(FCChartObj.toolbarbuttoncolor, 'ffffff'));
            button.labelFill = convertColor(pluck(FCChartObj.toolbarlabelcolor, 'cccccc'));
            button.symbolFill = convertColor(pluck(FCChartObj.toolbarsymbolcolor, 'ffffff'));
            button.hoverFill = convertColor(pluck(FCChartObj.toolbarbuttonhovercolor, 'ffffff'));
            button.stroke = convertColor(pluck(FCChartObj.toolbarbuttonbordercolor, 'bbbbbb'));
            button.symbolStroke = convertColor(pluck(FCChartObj.toolbarsymbolbordercolor, '9a9a9a'));

            button.strokeWidth = pluckNumber(FCChartObj.toolbarbuttonborderthickness, 1);
            button.symbolStrokeWidth = pluckNumber(FCChartObj.toolbarsymbolborderthickness, 1);
            bSymbolPadding = button.symbolPadding = pluckNumber(FCChartObj.toolbarsymbolpadding, 5);
            button.symbolHPadding = pluckNumber(FCChartObj.toolbarsymbolhpadding, bSymbolPadding);
            button.symbolVPadding = pluckNumber(FCChartObj.toolbarsymbolvpadding, bSymbolPadding);

            bPosition = toolbar.position = pluck(FCChartObj.toolbarposition, 'tr').toLowerCase();
            switch(bPosition) {
                case "tr":
                case "tl":
                case "br":
                case "bl":
                    break;
                default:
                    bPosition = "tr";
            }
            bHAlign = toolbar.hAlign = (BLANKSTRING + FCChartObj.toolbarhalign).toLowerCase() === 'left' ? 'l': bPosition.charAt(1);
            bVAlign = toolbar.vAlign = (BLANKSTRING + FCChartObj.toolbarvalign).toLowerCase() === 'bottom' ? 'b' : bPosition.charAt(0);
            hDirection = toolbar.hDirection = pluckNumber(FCChartObj.toolbarhdirection, (bHAlign === 'r' ? -1 : 1));
            vDirection = toolbar.vDirection = pluckNumber(FCChartObj.toolbarvdirection, (bVAlign === 'b' ? -1 : 1));
            toolbar.vMargin = pluckNumber(FCChartObj.toolbarvmargin, 6);
            toolbar.hMargin = pluckNumber(FCChartObj.toolbarhmargin, 10);
            toolbar.x = pluckNumber(FCChartObj.toolbarx, bHAlign === 'l' ? 0: width);
            toolbar.y = pluckNumber(FCChartObj.toolbary, bVAlign === 't' ? 0: height);

            // Div lines and grid
            var
            divLineColor = pluck(FCChartObj.divlinecolor, defaultPaletteOptions[palleteString.divLineColor][paletteIndex]),
            divLineAlpha = pluck(FCChartObj.divlinealpha, is3d ?
                defaultPaletteOptions.divLineAlpha3D[paletteIndex] :
                defaultPaletteOptions.divLineAlpha[paletteIndex]),
            divLineThickness = pluckNumber(FCChartObj.divlinethickness, 1),
            divLineIsDashed = Boolean(pluckNumber(FCChartObj.divlineisdashed, this.divLineIsDashed, 0)),
            divLineDashLen = pluckNumber(FCChartObj.divlinedashlen, 4),
            divLineDashGap = pluckNumber(FCChartObj.divlinedashgap, 2);

            hc.yAxis[0].gridLineColor = convertColor(divLineColor, divLineAlpha);
            hc.yAxis[0].gridLineWidth = divLineThickness;
            hc.yAxis[0].gridLineDashStyle = divLineIsDashed ? getDashStyle(divLineDashLen,
                divLineDashGap, divLineThickness) : undefined;
            if (isBar) {
                hc.yAxis[0].alternateGridColor = convertColor(pluck(FCChartObj.alternatevgridcolor,
                    defaultPaletteOptions.altVGridColor[paletteIndex]),
                pluckNumber(FCChartObj.showalternatevgridcolor, 1) === 1 ?
                    pluck(FCChartObj.alternatevgridalpha, defaultPaletteOptions.altVGridAlpha[paletteIndex]) : ZEROSTRING);
            } else {
                hc.yAxis[0].alternateGridColor = convertColor(pluck(FCChartObj.alternatehgridcolor,
                    defaultPaletteOptions.altHGridColor[paletteIndex]),
                (FCChartObj.showalternatehgridcolor == 0) ? 0 : (pluck(FCChartObj.alternatehgridalpha,
                    defaultPaletteOptions.altHGridAlpha[paletteIndex])));
            }

            //create the x axis options scatter
            var vDivLineThickness = pluckNumber(FCChartObj.vdivlinethickness, 1),
            vDivLineIsDashed = Boolean(pluckNumber(FCChartObj.vdivlineisdashed, 0)),
            vDivLineDashLen = pluckNumber(FCChartObj.vdivlinedashlen, 4),
            vDivLineDashGap = pluckNumber(FCChartObj.vdivlinedashgap, 2);
            xAxis.gridLineColor = convertColor(pluck(FCChartObj.vdivlinecolor,
                defaultPaletteOptions[palleteString.divLineColor][paletteIndex]),
            pluck(FCChartObj.vdivlinealpha, defaultPaletteOptions.divLineAlpha[paletteIndex]));
            xAxis.gridLineWidth = vDivLineThickness;
            xAxis.gridLineDashStyle = vDivLineIsDashed ? getDashStyle(vDivLineDashLen,
                vDivLineDashGap, vDivLineThickness) : undefined;
            xAxis.alternateGridColor = convertColor(pluck(FCChartObj.alternatevgridcolor,
                defaultPaletteOptions.altVGridColor[paletteIndex]),
            (FCChartObj.showalternatehgridcolor === '1') ? (pluck(FCChartObj.alternatevgridalpha,
                defaultPaletteOptions.altVGridAlpha[paletteIndex])) : 0);

            var showPercentValues, canBGColor = pluck(FCChartObj.canvasbgcolor, defaultPaletteOptions[
                palleteString.canvasBgColor][paletteIndex]), showPercentInToolTip,
            canBGAlpha = pluck(FCChartObj.canvasbgalpha, defaultPaletteOptions.
                canvasBgAlpha[paletteIndex]),
            showCanvasBG = pluck(FCChartObj.showcanvasbg, ONESTRING);

            if (showCanvasBG == ZEROSTRING) {
                canBGAlpha = '0';
            }

            // Plot shadow effect. Note that this is overridden in the if-block
            // below.
            hc.plotOptions.series.shadow = pluckNumber(FCChartObj.showshadow,
                FCChartObj.showcolumnshadow,
                this.defaultPlotShadow,
                defaultPaletteOptions.showShadow[paletteIndex]);

            //if inversed chart then set the reverse attr for axis
            if (this.inversed) {
                hc.yAxis[0].reversed = true;
                hc.yAxis[1].reversed = true;
            }

            //if stacked chart
            if (this.isStacked) {
                if (this.distributedColumns) {
                    conf.showStackTotal = Boolean(pluckNumber(FCChartObj.showsum,  1));
                    stack100percent = pluckNumber(FCChartObj.usepercentdistribution, 1);
                    

                    showPercentValues = pluckNumber(FCChartObj.showpercentvalues, 0);
                    showPercentInToolTip = pluckNumber(FCChartObj.showpercentintooltip, stack100percent, 0);
                    conf.showXAxisPercentValues = pluckNumber(FCChartObj.showxaxispercentvalues, 1);
                }
                else {
                    conf.showStackTotal = Boolean(pluckNumber(this.showSum, FCChartObj.showsum,  0));
                    //combicharts dose not support stack100percent
                    stack100percent = pluckNumber(this.stack100percent, FCChartObj.stack100percent, 0);
                    showPercentValues = pluckNumber(FCChartObj.showpercentvalues, stack100percent, 0);
                    showPercentInToolTip = pluckNumber(FCChartObj.showpercentintooltip, showPercentValues);
                }
                //add the showPercentValues in conf
                conf.showPercentValues = showPercentValues;
                conf.showPercentInToolTip = showPercentInToolTip;

                //only default series get the stack property
                if (stack100percent) {
                    conf.isValueAbs = true;
                    plotOptions[defaultSeries].stacking = 'percent';
                    //first axis will be percent stacking
                    conf[0].stacking100Percent = true;
                }
                else {
                    plotOptions[defaultSeries].stacking = 'normal';
                }
            }

            //Issue #680 solved
            if(this.isDual) {
                if (FCChartObj.primaryaxisonleft === '0') {
                    hc.yAxis[0].opposite = true;
                    hc.yAxis[1].opposite = false;
                }
                hc.yAxis[0].showAlways = true;
                hc.yAxis[1].showAlways = true;
            }



            if (HCChartObj.useRoundEdges) {
                hc.plotOptions.series.shadow = pluckNumber(FCChartObj.showshadow,
                    FCChartObj.showcolumnshadow, 1);
                hc.plotOptions.series.borderRadius = 1;
                hc.tooltip.style.borderRadius = 2 + "px";
                // Manage canvas cosmetics
                HCChartObj.plotBorderRadius = 3;
                if (!showCanvasBorder) {
                    HCChartObj.plotBorderWidth = 0;
                }
                HCChartObj.plotShadow = hc.plotOptions.series.shadow ? {
                    enabled: true,
                    opacity: canBGAlpha / 100
                } : 0;

            }

            if (pluckNumber(FCChartObj.use3dlighting, 1) === 1) {
                hc.legend.lighting3d = true;
            }

            ///add the support for maxColWidth/maxBarHeight
            hc.plotOptions.series.userMaxColWidth = isBar ?
                        FCChartObj.maxbarheight :
                        pluckNumber(FCChartObj.maxcolwidth, this.maxColWidth);
            hc.plotOptions.series.maxColWidth = Math.abs(pluckNumber(
                    hc.plotOptions.series.userMaxColWidth, 50)) || 1;

            //Title
            hc.title.text = parseUnsafeString(FCChartObj.caption);

            //SubTitle
            hc.subtitle.text = parseUnsafeString(FCChartObj.subcaption);


            ///////// tooltip Options//////////////
            if (pluckNumber(FCChartObj.showtooltip, this.showtooltip) == 0) { //area/line ancor conflict
                hc.tooltip.enabled =  false;
            }

            var tooltipStyle = hc.tooltip.style;
            tooltipStyle.backgroundColor = convertColor(pluck(tooltipStyle.backgroundColor, FCChartObj.tooltipbgcolor,
                defaultPaletteOptions.toolTipBgColor[paletteIndex]), pluck(FCChartObj.tooltipbgalpha, 100));
            tooltipStyle.borderColor = convertColor(pluck(tooltipStyle.borderColor, FCChartObj.tooltipbordercolor,
                defaultPaletteOptions.toolTipBorderColor[paletteIndex]), pluck(FCChartObj.tooltipborderalpha, 100));

            hc.tooltip.shadow = pluckNumber(FCChartObj.showtooltipshadow, FCChartObj.showshadow, 1) ? {
                enabled: true,
                opacity: mathMax(pluckNumber(FCChartObj.tooltipbgalpha, 100),pluckNumber(FCChartObj.tooltipborderalpha,100)) / 100
            } : false;
            hc.tooltip.constrain = pluckNumber(FCChartObj.constraintooltip, 1);
            tooltipStyle.borderWidth = pluckNumber(FCChartObj.tooltipborderthickness, 1) + 'px';
            if (FCChartObj.tooltipborderradius) {
                tooltipStyle.borderRadius = pluckNumber(FCChartObj.tooltipborderradius, 1) + "px";
            }
            tooltipStyle.padding =
            pluckNumber(FCChartObj.tooltippadding, this.tooltippadding, 3) + 'px';
            if (FCChartObj.tooltipcolor) {
                tooltipStyle.color = getFirstColor(FCChartObj.tooltipcolor);
            }


            //set the plotspace ppercent has effecton column only
            conf.userPlotSpacePercent = hc.plotOptions.series.userPlotSpacePercent = FCChartObj.plotspacepercent;
            var plotSpacePercent = pluckNumber(FCChartObj.plotspacepercent, 20) % 100;

//            if (plotSpacePercent > 80 || plotSpacePercent < 0) {
//                plotSpacePercent = 20;
//            }
            //set the plot space percent
            conf.plotSpacePercent = hc.plotOptions.series.groupPadding = plotSpacePercent / 200;

            //if 3d chart then add 15 * 15 pixel space
            

            if (is3d && !isPie) {
                //combi chart add shift for 2d series
                //**set the speciffic 3dShift conf in chartApi(2d area in 3d chart issue)
                HCChartObj.series2D3Dshift = chartName === 'mscombi3d' ? true : Boolean(pluckNumber(
                    FCChartObj.use3dlineshift, 0));
                HCChartObj.canvasBaseColor3D = pluck(FCChartObj.canvasbasecolor, defaultPaletteOptions.
                    canvasBaseColor3D[paletteIndex]);
                HCChartObj.canvasBaseDepth = pluckNumber(FCChartObj.canvasbasedepth, 10);
                HCChartObj.canvasBgDepth = pluckNumber(FCChartObj.canvasbgdepth, 3);
                HCChartObj.showCanvasBg = Boolean(pluckNumber(FCChartObj.showcanvasbg, 1));
                HCChartObj.showCanvasBase = Boolean(pluckNumber(FCChartObj.showcanvasbase, 1));
                if (isBar) {
                    HCChartObj.xDepth = 5;
                    HCChartObj.yDepth = 5;

                    // adjust the space for canvasBgDepth
                    //Store it as marginRightExtraSpace
                    if (HCChartObj.showCanvasBg) {
                        conf.marginTopExtraSpace +=  HCChartObj.canvasBgDepth;
                    }
                    //adjust the space for canvasBaseDepth and yDepth
                    conf.marginLeftExtraSpace += HCChartObj.yDepth + (HCChartObj.showCanvasBase ?
                        HCChartObj.canvasBaseDepth : 0);
                    conf.marginBottomExtraSpace += 5;
                }
                else {
                    HCChartObj.xDepth = 10;
                    HCChartObj.yDepth = 10;

                    // adjust the space for canvasBgDepth
                    //Store it as marginRightExtraSpace
                    if (HCChartObj.showCanvasBg) {
                        conf.marginRightExtraSpace +=  HCChartObj.canvasBgDepth;
                    }
                    //adjust the space for canvasBaseDepth and yDepth
                    conf.marginBottomExtraSpace += HCChartObj.yDepth + (HCChartObj.showCanvasBase ?
                        HCChartObj.canvasBaseDepth : 0);
                }
                //build the 3d effect of the plotBackgroundColor
                canBGColor = canBGColor.split(COMMASTRING)[0];
                canBGAlpha = canBGAlpha.split(COMMASTRING)[0];
                HCChartObj.use3DLighting = Boolean(pluckNumber(FCChartObj.use3dlighting, 1));
                if (HCChartObj.use3DLighting) {
                    HCChartObj.plotBackgroundColor = {
                        FCcolor : {
                            color : getDarkColor (canBGColor, 85) + COMMASTRING + getLightColor (canBGColor, 55),
                            alpha : canBGAlpha + COMMASTRING + canBGAlpha,
                            ratio : BGRATIOSTRING,
                            angle : getAngle (width - (HCChartObj.marginLeft + HCChartObj.marginRight),
                                height - (HCChartObj.marginTop + HCChartObj.marginBottom), 1)
                        }
                    };
                }
                else {
                    HCChartObj.plotBackgroundColor =  convertColor(canBGColor, canBGAlpha);
                }


                //for bg depth
                HCChartObj.canvasBgColor = convertColor(getDarkColor(canBGColor, 80), canBGAlpha);
                zeroPlaneColor = pluck(FCChartObj.zeroplanecolor, FCChartObj.divlinecolor,
                    defaultPaletteOptions[palleteString.divLineColor][paletteIndex]);
                zeroPlaneAlpha = pluck(FCChartObj.zeroplanealpha, FCChartObj.divlinealpha,
                    defaultPaletteOptions.divLineAlpha[paletteIndex]);
                HCChartObj.zeroPlaneColor = convertColor(zeroPlaneColor, zeroPlaneAlpha);
                HCChartObj.zeroPlaneBorderColor = convertColor(pluck(FCChartObj.zeroplanebordercolor,
                    zeroPlaneColor), pluckNumber(FCChartObj.zeroplaneshowborder, 1) ? zeroPlaneAlpha : 0);
            }
            else {
                HCChartObj.is3D = false;//for pie 3d
                // Manage canvas cosmetics
                HCChartObj.plotBackgroundColor = {
                    FCcolor : {
                        color : canBGColor,
                        alpha : canBGAlpha,
                        angle : pluck(FCChartObj.canvasbgangle, defaultPaletteOptions.canvasBgAngle[paletteIndex]),
                        ratio : pluck(FCChartObj.canvasbgratio, defaultPaletteOptions.canvasBgRatio[paletteIndex])
                    }
                };
            }


            //
            //////Export Module/////
            this.parseExportOptions(hc);

            // preSeriesAddition function is to configure the charts (Modify Data)
            // before series function executes
            if (this.preSeriesAddition) {
                this.preSeriesAddition(hc, obj, width, height);
            }

            //create the Data serias first
            this.series && this.series(obj, hc, chartName, width, height);

            //this function do the after series addition works like:
            // showsum for stacking
            //marimekko conf
            this.postSeriesAddition(hc, obj, width, height);

            /*
             *Manage the space
             */
            this.spaceManager(hc, obj, width, height);

            // postSpaceManager function is to configure the charts (Modify Data)
            // after space manager function executes
            this.postSpaceManager && this.postSpaceManager(hc, obj, width, height);

            // Drawing Quadrant for XY plot Charts
            var drawQuadrant = pluckNumber(FCChartObj.drawquadrant, 0);
            if (conf.isXYPlot && drawQuadrant) {

                //Quadrant related properties
                var xMin = xAxis.min, xMax = xAxis.max,
                yMin = hc.yAxis[0].min, yMax = hc.yAxis[0].max,
                quadrantXVal = pluckNumber(FCChartObj.quadrantxval, (xMin + xMax)/2),
                quadrantYVal = pluckNumber(FCChartObj.quadrantyval, (yMin + yMax)/2);
                if (quadrantYVal >= yMin && quadrantYVal <= yMax && quadrantXVal >= xMin && quadrantXVal <= xMax) {
                    var quadrantLineColor = convertColor(pluck(FCChartObj.quadrantlinecolor, HCChartObj.plotBorderColor),
                        pluck(FCChartObj.quadrantlinealpha, HUNDREDSTRING)),
                    quadrantLineThickness = pluckNumber(FCChartObj.quadrantlinethickness, HCChartObj.plotBorderWidth),
                    quadrantLineIsDashed = pluckNumber(FCChartObj.quadrantlineisdashed, 0),
                    quadrantLineDashLen = pluckNumber(FCChartObj.quadrantlinedashLen, 4),
                    quadrantLineDashGap = pluckNumber(FCChartObj.quadrantlinedashgap, 2),
                    quadrantLabelTL = getValidValue(FCChartObj.quadrantlabeltl, BLANKSTRING),
                    quadrantLabelTR = getValidValue(FCChartObj.quadrantlabeltr, BLANKSTRING),
                    quadrantLabelBL = getValidValue(FCChartObj.quadrantlabelbl, BLANKSTRING),
                    quadrantLabelBR  = getValidValue(FCChartObj.quadrantlabelbr, BLANKSTRING),
                    //Padding of label from any side of canvase
                    quadrantLabelPadding = pluckNumber(FCChartObj.quadrantlabelpadding, 3),
                    dashStyle = quadrantLineIsDashed ? getDashStyle(quadrantLineDashLen,
                        quadrantLineDashGap, quadrantLineThickness) : undefined;


                    //Now check whether they're in range.
                    xAxis.plotLines.push({
                        color: quadrantLineColor,
                        value: quadrantXVal,
                        width: quadrantLineThickness,
                        dashStyle: dashStyle,
                        zIndex: 3
                    });

                    hc.yAxis[0].plotLines.push({
                        color: quadrantLineColor,
                        value: quadrantYVal,
                        width: quadrantLineThickness,
                        dashStyle: dashStyle,
                        zIndex: 3
                    });

                    var canvasWidth = width - HCChartObj.marginRight - HCChartObj.marginLeft,
                    canvasHeight = height - HCChartObj.marginTop - HCChartObj.marginBottom,
                    labelWidthPart1, labelWidthPart2, labelHeightPart1, labelHeightPart2, smartText,
                    inCanvasStyle = conf.inCanvasStyle, inCanvasFontSize =
                    parseInt(inCanvasStyle.fontSize, 10);

                    labelWidthPart1 = (canvasWidth / (xMax - xMin)) * (quadrantXVal - xMin);
                    labelWidthPart2 = canvasWidth - labelWidthPart1;

                    labelHeightPart2 = (canvasHeight / (yMax - yMin)) * (quadrantYVal - yMin);
                    labelHeightPart1 = canvasHeight - labelHeightPart2;

                    //remove the padding amount
                    labelWidthPart1 -= quadrantLabelPadding;
                    labelWidthPart2 -= quadrantLabelPadding;
                    labelHeightPart1 -= quadrantLabelPadding;
                    labelHeightPart2 -= quadrantLabelPadding;
                    /* Fix for raphael's bottom alignment.
                     * removed inCanvasFontSize from the calculation
                     * applied vAlign to top quadrant. - P.B
                     */
                    var top1 = quadrantLabelPadding + PXSTRING,// + inCanvasFontSize + PXSTRING,
                    top2 = (canvasHeight - quadrantLabelPadding) + PXSTRING,
                    left1 = quadrantLabelPadding + PXSTRING,
                    left2 = (canvasWidth - quadrantLabelPadding) + PXSTRING;

                    // Draw the quadrant labels.
                    smartLabel.setStyle(inCanvasStyle);

                    if (labelHeightPart1 > 0) {
                        if (quadrantLabelTL !== BLANKSTRING && labelWidthPart1 > 0) {
                            smartText = smartLabel.getSmartText(quadrantLabelTL, labelWidthPart1, labelHeightPart1)
                            hc.labels.items.push({
                                html: smartText.text,
                                zIndex : 3,
                                vAlign: POSITION_TOP,
                                style: {
                                    left: left1,
                                    top: top1,
                                    fontSize: inCanvasStyle.fontSize,
                                    lineHeight: inCanvasStyle.lineHeight,
                                    fontFamily: inCanvasStyle.fontFamily,
                                    color: inCanvasStyle.color
                                }
                            });
                        }

                        if (quadrantLabelTR !== BLANKSTRING && labelWidthPart2 > 0) {
                            smartText = smartLabel.getSmartText(quadrantLabelTR, labelWidthPart2, labelHeightPart1);
                            hc.labels.items.push({
                                html: smartText.text,
                                textAlign: POSITION_RIGHT,
                                vAlign: POSITION_TOP,
                                zIndex : 3,
                                style: {
                                    left: left2,
                                    top: top1,
                                    //textAlign: POSITION_RIGHT,
                                    fontSize: inCanvasStyle.fontSize,
                                    lineHeight: inCanvasStyle.lineHeight,
                                    fontFamily: inCanvasStyle.fontFamily,
                                    color: inCanvasStyle.color
                                }
                            });
                        }
                    }
                    if (labelHeightPart2 > 0) {
                        if (quadrantLabelBL !== BLANKSTRING && labelWidthPart1 > 0) {
                            smartText = smartLabel.getSmartText(quadrantLabelBL, labelWidthPart1, labelHeightPart2)
                            hc.labels.items.push({
                                html: smartText.text,
                                vAlign : POSITION_BOTTOM,
                                zIndex : 3,
                                style: {
                                    left: left1,
                                    top: top2,
                                    //vAlign : POSITION_BOTTOM,
                                    fontSize: inCanvasStyle.fontSize,
                                    lineHeight: inCanvasStyle.lineHeight,
                                    fontFamily: inCanvasStyle.fontFamily,
                                    color: inCanvasStyle.color
                                }
                            });
                        }

                        if (quadrantLabelBR !== BLANKSTRING && labelWidthPart2 > 0) {
                            smartText = smartLabel.getSmartText(quadrantLabelBR, labelWidthPart2, labelHeightPart2)
                            hc.labels.items.push({
                                html: smartText.text,
                                textAlign: POSITION_RIGHT,
                                vAlign : POSITION_BOTTOM,
                                zIndex : 3,
                                style: {
                                    left: left2,
                                    top: top2,
                                   // textAlign: POSITION_RIGHT,
                                    //vAlign : POSITION_BOTTOM,
                                    fontSize: inCanvasStyle.fontSize,
                                    lineHeight: inCanvasStyle.lineHeight,
                                    fontFamily: inCanvasStyle.fontFamily,
                                    color: inCanvasStyle.color
                                }
                            });
                        }
                    }
                }
            }


            //add the code for x axis num v div line for line area
            if (this.hasVDivLine) {
                var numVDivLines, vDivLineColor, vDivLineAlpha;

                numVDivLines = pluckNumber(FCChartObj.numvdivlines, 0) + 1;
                if (numVDivLines > 1) {
                    var min = xAxis.min, catLength = conf.x.catCount - 1, max = xAxis.max, value,
                    gridInterval = catLength / numVDivLines, drawAltGrid = true,
                    lastValue = min, alternateVGridColor, showAlternateVGridColor;

                    //for scroll charts this should be the scoll viewPort max not the
                    //intial axis end
                    xAxis.scroll && !isNaN(xAxis.scroll.viewPortMax) &&
                            (max = xAxis.scroll.viewPortMax)

                    vDivLineColor = pluck(FCChartObj.vdivlinecolor, divLineColor);
                    vDivLineAlpha = pluckNumber(FCChartObj.vdivlinealpha, divLineAlpha);
                    vDivLineThickness = pluckNumber(FCChartObj.vdivlinethickness, divLineThickness);
                    vDivLineIsDashed = pluckNumber(FCChartObj.vdivlineisdashed, divLineIsDashed);
                    vDivLineDashLen = pluckNumber(FCChartObj.vdivlinedashlen, divLineDashLen);
                    vDivLineDashGap = pluckNumber(FCChartObj.vdivlinedashgap, divLineDashGap);
                    showAlternateVGridColor = pluckNumber(FCChartObj.showalternatevgridcolor, 0);

                    if (showAlternateVGridColor) {
                        alternateVGridColor = convertColor(pluck(FCChartObj.alternatevgridcolor,
                            defaultPaletteOptions.altVGridColor[paletteIndex]),
                        pluck(FCChartObj.alternatevgridalpha,
                            defaultPaletteOptions.altVGridAlpha[paletteIndex]
                            ))
                    }

                    for (value = gridInterval; value < catLength; value += gridInterval,
                        drawAltGrid = !drawAltGrid) {
                        // Draw the alternate grid
                        if (drawAltGrid && showAlternateVGridColor) {
                            xAxis.plotBands.push({
                                isNumVDIV : true,//will not move during realtime update
                                color: alternateVGridColor,
                                from: lastValue,
                                to: value,
                                zIndex: 1
                            });
                        }
                        // Draw the Grid lines
                        xAxis.plotLines.push({
                            isNumVDIV : true,//will not move during realtime update
                            width: vDivLineThickness,
                            color: convertColor(vDivLineColor, vDivLineAlpha),
                            dashStyle : vDivLineIsDashed ? getDashStyle(vDivLineDashLen,
                                vDivLineDashGap, vDivLineThickness) : undefined,
                            value: value,
                            zIndex: 1
                        });
                        lastValue = value;
                    }
                    // Draw the alternate grid for last one
                    if (drawAltGrid && showAlternateVGridColor) {
                        xAxis.plotBands.push({
                            isNumVDIV : true,//will not move during realtime update
                            color: alternateVGridColor,
                            from: lastValue,
                            to: max,
                            zIndex: 1
                        });
                    }

                }
            }



            

            //special checking for axis Depth. if there dont have sufficiant space for x depth
            //then add it
            if (is3d && HCChartObj.xDepth > HCChartObj.marginLeft) {
                HCChartObj.marginLeft = HCChartObj.xDepth;
            }

            //if the axis has no negative value then set the thresold as max
            


            if (window.console && window.console.log && window.FC_DEV_ENVIRONMENT) {
                console.log(hc);
            }

            //return the converted object
            return hc;
        },

        parseExportOptions: function (hc) {
            var chart = this,
                exportAction_sentenceCase,
                FCChartObj = chart.dataObj.chart,
                conf = hc[FC_CONFIG_STRING],
                bgColor = chart.chartInstance.jsVars.transparent ? '' :
                    (chart.chartInstance.options.containerBackgroundColor || '#ffffff');

                hc.exporting.enabled = pluckNumber(FCChartObj.exportenabled, 0);
                hc.exporting.bgcolor = bgColor;
                hc.exporting.exporttargetwindow = pluck(FCChartObj.exporttargetwindow, '_self');
                hc.exporting.exportaction = FCChartObj.exportaction &&
                        FCChartObj.exportaction.toString().toLowerCase() === 'save'
                                && 'save' || 'download';
                exportAction_sentenceCase = getSentenceCase(hc.exporting.exportaction);
                hc.exporting.exportfilename = pluck(FCChartObj.exportfilename, 'FusionCharts');
                hc.exporting.exporthandler = pluck(FCChartObj.html5exporthandler,
                    FCChartObj.exporthandler, DEFAULT_EXPORT_URL);
                hc.exporting.exportparameters = pluck(FCChartObj.exportparameters, '');
                hc.exporting.exportformat = pluck(FCChartObj.exportformat, 'PNG');
                hc.exporting.exportatclient = pluckNumber(FCChartObj.exportatclient, 0);
                hc.exporting.exportformats = (function(strFormats) {
                var exportFormats = {
                        'JPG': exportAction_sentenceCase + ' as JPEG image',
                        'PNG': exportAction_sentenceCase + ' as PNG image',
                        'PDF': exportAction_sentenceCase + ' as PDF document',
                        'SVG': exportAction_sentenceCase + ' as SVG vector image'
                        },
                    finalFormats,
                    arrFormats,
                    item,
                    format,
                    label,
                    i = 0;

                if (strFormats) {
                    arrFormats = strFormats.split("|");

                    for (i = 0; i < arrFormats.length; i++) {
                        item = arrFormats[i].split("=");
                        format = item && item[0].toUpperCase() || "";
                        label = item && item[1] || "";

                        exportFormats[format] &&
                            (finalFormats || (finalFormats = {})) &&
                                (finalFormats[format] = label ||
                                                    exportFormats[format]);
                    }

                }

                return finalFormats || exportFormats;

            }(FCChartObj.exportformats));



            // hide/show print button
            hc.exporting.buttons.printButton.enabled =
                (FCChartObj.showprintmenuitem == '1');

            // showhide export button
            hc.exporting.buttons.exportButton.enabled =
                (FCChartObj.exportenabled == '1') ?
                    !(FCChartObj.exportshowmenuitem == '0') : false;

        },

        defaultSeriesType: BLANKSTRING,
        paletteIndex: 1,
        creditLabel: creditLabel,

        // Space Management Routines
        placeTitle: titleSpaceManager,
        placeLegendBlockBottom: placeLegendBlockBottom,
        placeLegendBlockRight: placeLegendBlockRight,
        placeHorizontalAxis: placeHorizontalAxis,
        placeVerticalAxis: placeVerticalAxis,
        placeHorizontalCanvasMarginAdjustment: adjustHorizontalCanvasMargin,
        placeVerticalCanvasMarginAdjustment: adjustVerticalCanvasMargin,
        placeHorizontalXYSpaceManager: barXYSpaceManager,
        placeVerticalXYSpaceManager: nonBarXYSpaceManager,
        placeVerticalAxisTitle: adjustVerticalAxisTitle,

        spaceManager : function () {
            return this.placeVerticalXYSpaceManager.apply(this, arguments);
        },

        /**
         * this function will set the min max and the tickinterval for a y axis
         */
        axisMinMaxSetter: function (aXisObj, axisConf, yAxisMaxValue,
            yAxisMinValue, stopMaxAtZero, setMinAsZero, numDivLines,
            adjustDiv) {

            var axisLimits;
            if (axisConf.stacking100Percent) {
                axisLimits = getAxisLimits(99, 1, 100, 0, stopMaxAtZero,
                    setMinAsZero, numDivLines, adjustDiv);
            }
            else {
                axisLimits = getAxisLimits(pluckNumber(axisConf.max,
                    yAxisMaxValue), pluckNumber(axisConf.min, yAxisMinValue),
                    yAxisMaxValue, yAxisMinValue, stopMaxAtZero, setMinAsZero,
                    numDivLines, adjustDiv);
            }
            aXisObj.min = Number(toPrecision(axisLimits.Min,10));
            aXisObj.max = Number(toPrecision(axisLimits.Max, 10));
            aXisObj.tickInterval = Number(toPrecision(axisLimits.divGap, 10));

             //for realtime chart add the calculated numdivlines
            axisConf.numdivlines = Math.round((aXisObj.max - aXisObj.min) / aXisObj.tickInterval) - 1;

            //fix issue #698
            if (axisLimits.Range / axisLimits.divGap <= 2) {
                aXisObj.alternateGridColor = COLOR_TRANSPARENT;
            }

            // Store the High and Low value of data in chartAPI before deleting
            // it form conf this will be use by FusionWidgets Spark Charts.
            this.highValue = axisConf.max;
            this.lowValue = axisConf.min;

            // Delete the min max.
            delete axisConf.max;
            delete axisConf.min;
        },
        configurePlotLines: configureAxis,

        xAxisMinMaxSetter: function (hcJSON, fcJSON, canvasWidth) {
            var conf = hcJSON[FC_CONFIG_STRING], xAxisConf = conf.x,
            

            // no catCount is requierd.
            FCChartObj = fcJSON.chart,
            min = xAxisConf.min = pluckNumber(xAxisConf.min, 0),
            max = xAxisConf.max = pluckNumber(xAxisConf.max, xAxisConf.catCount - 1),
            rightPixelPad,
            leftValuePad = 0, rightValuePad = 0, valuePixelRatio, defaultSeries = hcJSON.chart.defaultSeriesType,
            isColumnType = /^(column|column3d|bar|bar3d|floatedcolumn|sparkwinloss|boxandwhisker2d|dragcolumn)$/.test(defaultSeries),
            isLineType = /^(line|area|spline|areaspline)$/.test(defaultSeries),
            isXYPlot = /^(scatter|bubble|candlestick|dragnode)$/.test(defaultSeries),
            xAxis = hcJSON.xAxis,
            scrollOptions = xAxis.scroll,
            leftPixelPad = rightPixelPad = Math.min(pluckNumber(FCChartObj.canvaspadding, 0),
                (canvasWidth / 2) - 10);//plot area will not be less then 10 px

            //if scatter or bubble the calculate the min max
            //NOTE: this flag is added in cat adder of scatter
            if (xAxisConf.adjustMinMax) {
                var setadaptiveXmin = pluckNumber(FCChartObj.setadaptivexmin, 1),
                stopMaxAtZero,
                setMinAsZero = stopMaxAtZero = !setadaptiveXmin,
                numVDivLines = pluckNumber(this.numVDivLines, FCChartObj.numvdivlines, 4),
                adjustVDiv = FCChartObj.adjustvdiv !== ZEROSTRING,
                showXAxisValues = pluckNumber(FCChartObj.showxaxisvalues, FCChartObj.showxaxisvalue, 1),
                showVLimits = pluckNumber(FCChartObj.showvlimits, showXAxisValues),
                showVDivLineValues = pluckNumber(FCChartObj.showvdivlinevalue, FCChartObj.showvdivlinevalues,
                    showXAxisValues);

                //////////////////////calculate the axis min max and the div interval for x axis ///////////////////
                this.axisMinMaxSetter(xAxis, xAxisConf, FCChartObj.xaxismaxvalue, FCChartObj.xaxisminvalue, stopMaxAtZero,
                    setMinAsZero, numVDivLines, adjustVDiv);
                //add this new min max in the local variable for proper code flow
                min = xAxis.min;
                max = xAxis.max;
                //if auto numeric calculation requared
                if (xAxisConf.requiredAutoNumericLabels) {
                    var xaxisvaluesstep = pluckNumber(parseInt(FCChartObj.xaxisvaluesstep, 10), 1);
                    xaxisvaluesstep = xaxisvaluesstep < 1 ? 1 : xaxisvaluesstep;
                    this.configurePlotLines (FCChartObj, hcJSON, xAxis, xAxisConf, showVLimits,
                        showVDivLineValues, xaxisvaluesstep, conf.numberFormatter, false, true);
                }
                //now sort the grid lines so that we can determine the space during space management
                xAxis.plotLines.sort(plotLineSortFN);
            }
            //remove all grid related conf
            xAxis.labels.enabled = false;
            xAxis.gridLineWidth = INT_ZERO;
            xAxis.alternateGridColor = COLOR_TRANSPARENT;


            // We add some spacing to start and end of column/bar plot.
            if ((isColumnType || conf.isScroll) && !conf.hasNoColumn) {
                leftValuePad = 0.5;
                rightValuePad = 0.5;
            }

            if (conf.is3d) {
                leftPixelPad += pluckNumber(hcJSON.chart.xDepth, 0);
            }

            valuePixelRatio = (canvasWidth - (leftPixelPad + rightPixelPad)) / ((max - min) +
                (leftValuePad + rightValuePad));
            xAxis.min = min - (leftValuePad + (leftPixelPad / valuePixelRatio));
            xAxis.max = max + (rightValuePad + (rightPixelPad / valuePixelRatio));

            // Special checking for scroll charts
            if (scrollOptions && scrollOptions.enabled) {
                var vxLength = scrollOptions.vxLength,
                //scrollStartPercent = scrollOptions.startPercent,
                scrollableLength = xAxis.max - xAxis.min;

                scrollOptions.viewPortMin = xAxis.min;
                scrollOptions.viewPortMax = xAxis.max;
                scrollOptions.scrollRatio = vxLength / scrollableLength;
                scrollOptions.flatScrollBars = conf.flatScrollBars;
                scrollOptions.scrollBar3DLighting = conf.scrollBar3DLighting;
                //set the new min max
                // xAxis.min += (scrollableLength - vxLength) * scrollStartPercent;
                xAxis.max = xAxis.min + vxLength;
            }
            //fix for single point line series
            if (isLineType && xAxis.min === xAxis.max) {
                xAxis.min -= 0.5;
                xAxis.max += 0.5;
            }


            ///////////Trend-lines /////////////////
            if (isXYPlot && fcJSON.vtrendlines) {
                createTrendLine(fcJSON.vtrendlines, xAxis, conf, false, true, true);
            }

        },
        postSeriesAddition: postSeriesAddition,

        // supported style type that are supported in js chart
        styleMapForFont: fontStyleMap,

        styleApplicationDefinition_font: function (HC, toObj, style) {
            var styleobject, x, y, isDataValuess = false, i, len, styleobjectI,
            fontStyleMap = this.styleMapForFont;

            switch (toObj) {//fiend the toobject of HC depending upon toobject string of FC
                case 'caption':
                    styleobject = HC.title;
                    break;

                case 'datalabels':
                    styleobject = HC.xAxis.labels;
                    break;

                case 'datavalues':
                    styleobject = HC.plotOptions.series.dataLabels;
                    isDataValuess = true;
                    break;
                    
                case 'tldatavalues':
                    styleobject = {
                        style : HC.plotOptions.series.dataLabels.tlLabelStyle
                    };
                    break;
                    
                case 'trdatavalues':
                    styleobject = {
                        style : HC.plotOptions.series.dataLabels.trLabelStyle
                    };
                    break;
                    
                case 'bldatavalues':
                    styleobject = {
                        style : HC.plotOptions.series.dataLabels.blLabelStyle
                    };
                    break;
                    
                case 'brdatavalues':
                    styleobject = {
                        style : HC.plotOptions.series.dataLabels.brLabelStyle
                    };
                    break;

                case 'subcaption':
                    styleobject = HC.subtitle;
                    break;

                case 'tooltip':
                    styleobject = HC.tooltip;
                    break;

                case 'trendvalues':
                    styleobject = {
                        style : HC[FC_CONFIG_STRING].trendStyle
                    };
                    break;

                case 'xaxisname':
                    styleobject = HC.xAxis.title;
                    break;

                case 'yaxisname':
                case 'pyaxisname'://for candlestick mainly
                case 'axistitle'://for mlline only
                    styleobject = [];
                    for (i = 0, len = HC.yAxis.length; i < len; i += 1) {
                        styleobject.push(HC.yAxis[i].title);
                    }
                    break;
                case 'yaxisvalues':
                    styleobject = [];
                    for (i = 0, len = HC.yAxis.length; i < len; i += 1) {
                        styleobject.push(HC.yAxis[i].labels);
                    }
                    break;
                case 'vlinelabels':
                    styleobject = {
                        style : HC[FC_CONFIG_STRING].divlineStyle
                    };
                    break;

                case 'legend':
                    styleobject = {
                        style : HC.legend.itemStyle
                    };
                    break;

                default:
                    //to prevent error send a dummy styleObj
                    styleobject = HC.orphanStyles[toObj];
                    if (!styleobject) {
                        HC.orphanStyles[toObj] = styleobject = {
                            text: '',
                            style : {}
                        };
                    }
                    break;
            }

            if (typeof styleobject === 'object') {
                if (styleobject instanceof Array) {
                    for (i = 0, len = styleobject.length; i < len; i += 1) {
                        styleobjectI = styleobject[i];
                        for (x in style) {//add all style attr into the hc object
                            y = x.toLowerCase();
                            if (typeof fontStyleMap[y] === 'function') {
                                fontStyleMap[y](style[x], styleobjectI, isDataValuess);
                            }
                        }
                        setLineHeight(styleobjectI.style);
                    }
                }
                else {
                    for (x in style) {//add all style attr into the hc object
                        y = x.toLowerCase();
                        if (typeof fontStyleMap[y] === 'function') {
                            fontStyleMap[y](style[x], styleobject, isDataValuess);
                        }
                    }
                    setLineHeight(styleobject.style);
                }
            }
        },

        parseStyles: function (hcObj) {
            var j, styleArr, styleName, tempstyle = {}, l, definitionObj,
            fcObj = this.dataObj;

            if (fcObj.styles && fcObj.styles.definition instanceof Array && fcObj.styles.application instanceof Array) {
                // retrieving all style definition and storing them in a temporary store
                for (j = 0; j < fcObj.styles.definition.length; j += 1) {
                    definitionObj = fcObj.styles.definition[j];
                    if (definitionObj.type && definitionObj.name &&
                        this['styleApplicationDefinition_' + definitionObj.type.toLowerCase()]) {
                        tempstyle[definitionObj.name.toLowerCase()] = definitionObj;
                    }
                }

                // find all apply object
                for (j = 0; j < fcObj.styles.application.length; j += 1) {
                    styleArr = fcObj.styles.application[j].styles &&
                    fcObj.styles.application[j].styles.split(COMMASTRING) || [];
                    for (l = 0; l < styleArr.length; l += 1) {
                        styleName = styleArr[l].toLowerCase();
                        if (tempstyle[styleName] && fcObj.styles.application[j].toobject) {
                            this['styleApplicationDefinition_' + tempstyle[styleName].type.toLowerCase()]
                            (hcObj, fcObj.styles.application[j].toobject.toLowerCase(), tempstyle[styleName]);
                        }
                    }
                }
            }
        },

        dispose: function () {
            var logic = this,
                prop;

            logic.disposing = true;
            // execute specific objects that has dispose functions
            logic.renderer && logic.renderer.dispose();
            logic.numberFormatter && logic.numberFormatter.dispose();
            logic.smartLabel && logic.smartLabel.dispose();

            // remove all variables
            for (prop in logic) {
                delete logic[prop];
            }
            delete logic.disposing;
            logic.disposed = true;
        }

    });

    chartAPI('stub', {
        standaloneInit: true
    }, chartAPI.base);

    chartAPI('barbase', {
        spaceManager: function () {
            return this.placeHorizontalXYSpaceManager.apply(this, arguments);
        }
    }, chartAPI.base);

    //// add the singleseries
    chartAPI('singleseries', {
        series : function (FCObj, HCObj, chartName, width, height) {
            var data = FCObj.data || (FCObj.dataset && FCObj.dataset[0] && FCObj.dataset[0].data);
            //if (FCObj.data && FCObj.data.length > 0) {
            if (data && data.length > 0 && data instanceof Array) {
                var series = {
                    data : [],
                    // for single series the color will be added point by point from palette
                    colorByPoint: true
                }, seriesArr;

                /////////if any SPECIAL settings needed for single series chart

                //disable the legend (special case for pie)
                HCObj.legend.enabled = false;


                //add data using chart speciffic function
                seriesArr = this.point(chartName, series, data, FCObj.chart, HCObj);
                //if the returned series is an array of series (case: pareto)
                if (seriesArr instanceof Array) {
                    HCObj.series = HCObj.series.concat(seriesArr)
                }
                //all other case there will be only1 series
                else {
                    HCObj.series.push(seriesArr);
                }

                ///configure the axis
                this.configureAxis(HCObj, FCObj);
                ///////////Trend-lines /////////////////
                if (FCObj.trendlines) {
                    createTrendLine (FCObj.trendlines, HCObj.yAxis, HCObj[FC_CONFIG_STRING],
                        false, this.isBar);
                }

            }
        },
        defaultSeriesType : BLANKSTRING,
        configureAxis : yxAxisConfigurer,
        pointValueWatcher : pointValueWatcher,

        // Function to create tooltext for individual data points
        getPointStub: function (setObj, value, label, HCObj) {
            var toolText, displayValue, dataLink, HCConfig = HCObj[FC_CONFIG_STRING],
            formatedVal = value === null ? value : HCConfig.numberFormatter.dataLabels(value),
            setTooltext = getValidValue(parseUnsafeString(setObj.tooltext)),
            setDisplayValue = getValidValue(parseUnsafeString(setObj.displayvalue));

            //create the tooltext
            if (!HCConfig.showTooltip) {
                toolText = BLANKSTRING;
            }
            else if (setTooltext !== undefined) {
                toolText = setTooltext;
            }
            else {//determine the dispalay value then
                toolText = formatedVal === null ? false :
                (label !== BLANKSTRING) ? label + HCConfig.tooltipSepChar + formatedVal : formatedVal;
            }
            //create the displayvalue
            if (!pluckNumber(setObj.showvalue, HCConfig.showValues)) {
                displayValue = BLANKSTRING;
            }
            else if (setDisplayValue !== undefined) {
                displayValue = setDisplayValue;
            }
            else {//determine the dispalay value then
                displayValue = formatedVal;
            }

            ////create the link
            dataLink = pluck(setObj.link);
            return {
                displayValue : displayValue,
                toolText : toolText,
                link: dataLink
            };
        }
    }, chartAPI.base);

    //// add the multyseries
    chartAPI('multiseries', {
        series : function (FCObj, HCObj, chartName) {
            var index, length, conf = HCObj[FC_CONFIG_STRING],
            series, seriesArr;

            /*
            // Use single series data for ms charts
            if (!FCObj.dataset && FCObj.data && !FCObj.categories) {
                FCObj.dataset = [{data: FCObj.data}];
                FCObj.categories = [{category: []}];
                for (index = 0; index < FCObj.data.length; index += 1) {
                    FCObj.categories[0].category.push({
                        label: pluck(FCObj.data[index].label, FCObj.data[index].name, '')
                    })
                }
            }
            */

            //enable the legend
            HCObj.legend.enabled = Boolean(pluckNumber(FCObj.chart.showlegend, 1));

            if (FCObj.dataset && FCObj.dataset.length > 0) {
                // add category
                this.categoryAdder(FCObj, HCObj);
                //add data series
                for (index = 0, length = FCObj.dataset.length; index < length; index += 1) {
                    series = {
                        visible: !!pluckNumber(FCObj.dataset[index].visible, 1),
                        data : []
                    };
                    //add numColumns for all non-stacked charts
                    if (!this.isStacked){
                            series.numColumns = length;
                    }
                    //add data to the series
                    seriesArr = this.point(chartName, series,
                        FCObj.dataset[index], FCObj.chart, HCObj, conf.oriCatTmp.length,
                        index);


                    //if the returned series is an array of series (case: pareto)
                    if (seriesArr instanceof Array) {
                        HCObj.series = HCObj.series.concat(seriesArr)
                    }
                    //all other case there will be only1 series
                    else {
                        HCObj.series.push(seriesArr);
                    }
                }
                ///configure the axis
                this.configureAxis(HCObj, FCObj);
                ///////////Trend-lines /////////////////
                //for log it will be done in configureAxis
                if (FCObj.trendlines && !this.isLog) {
                    createTrendLine (FCObj.trendlines, HCObj.yAxis, conf,
                        false, this.isBar, undefined, this.inversed);
                }

            }
        },
        categoryAdder : function(FCObj, HCObj) {
            var index, countCat = 0, fontSize, conf = HCObj[FC_CONFIG_STRING],
            axisGridManager = conf.axisGridManager, FCChartObj = FCObj.chart,
            xAxisObj = HCObj.xAxis, dataLabel, axisConf = conf.x, showLabels;
            if (FCObj.categories && FCObj.categories[0] && FCObj.categories[0].category) {
                //update the font relate attr in HC cat
                if (FCObj.categories[0].font) {
                    HCObj.xAxis.labels.style.fontFamily  = FCObj.categories[0].font;
                }
                if ((fontSize = pluckNumber(FCObj.categories[0].fontsize)) !== undefined) {
                    if (fontSize < 1) {
                        fontSize = 1;
                    }
                    HCObj.xAxis.labels.style.fontSize  = fontSize + PXSTRING;
                    setLineHeight(HCObj.xAxis.labels.style);
                }
                if (FCObj.categories[0].fontcolor) {
                    HCObj.xAxis.labels.style.color  = FCObj.categories[0].fontcolor.
                    split(COMMASTRING)[0].replace(/^\#?/, "#");
                }
                //temp object for cat text in data tooltext
                var oriCatTmp = HCObj[FC_CONFIG_STRING].oriCatTmp,
                categories = FCObj.categories[0].category;
                for (index = 0; index < categories.length; index += 1) {
                    if (!categories[index].vline) {
                        showLabels = pluckNumber(categories[index].showlabel, FCChartObj.showlabels, 1);
                        dataLabel = parseUnsafeString(getFirstValue(FCObj.categories[0].category[index].label,
                            FCObj.categories[0].category[index].name));
                        axisGridManager.addXaxisCat(xAxisObj, countCat, countCat, showLabels ? dataLabel : BLANKSTRING);
                        oriCatTmp[countCat] = getFirstValue(parseUnsafeString(
                            FCObj.categories[0].category[index].tooltext), dataLabel);
                        countCat += 1;
                    }
                    else {
                        axisGridManager.addVline(xAxisObj, categories[index], countCat, HCObj);
                    }
                }
            }
            axisConf.catCount = countCat;
        },

        // Function to create tooltext for individual data points
        getPointStub: function (setObj, value, label, HCObj, dataset, datasetShowValues, yAxisIndex) {
            var toolText, displayValue, dataLink, HCConfig = HCObj[FC_CONFIG_STRING],
            showPercentValuesRequared, showPercentInToolTipRequared,
            formatedVal = value === null ? value : this.numberFormatter.dataLabels(value, yAxisIndex),
            seriesname, setTooltext = getValidValue(parseUnsafeString(setObj.tooltext)),
            tooltipSepChar = HCConfig.tooltipSepChar;

            //create the tooltext
            if (!HCConfig.showTooltip) {
                toolText = false;
            }
            // if tooltext is given in data object
            else if (setTooltext !== undefined) {
                toolText = setTooltext;
            }
            else {//determine the tooltext then
                if (formatedVal === null) {
                    toolText = false;
                } else {
                    if (HCConfig.seriesNameInToolTip) {
                        seriesname = getFirstValue(dataset && dataset.seriesname);
                    }
                    toolText = seriesname ? seriesname + tooltipSepChar : BLANKSTRING;
                    toolText += label ? label + tooltipSepChar : BLANKSTRING;
                    if (HCConfig.showPercentInToolTip){
                        showPercentInToolTipRequared = true;
                    }
                    else {
                        toolText += formatedVal;
                    }
                }
            }

            //create the displayvalue
            if (!pluckNumber(setObj.showvalue, datasetShowValues)) {
                displayValue = BLANKSTRING;
            }
            else if (getValidValue(setObj.displayvalue) !== undefined) {
                displayValue = parseUnsafeString(setObj.displayvalue);
            }
            else if (HCConfig.showPercentValues){
                showPercentValuesRequared = true;
            }
            else {//determine the dispalay value then
                displayValue = formatedVal;
            }

            ////create the link
            dataLink = pluck(setObj.link);

            return {
                displayValue : displayValue,
                toolText : toolText,
                link: dataLink,
                showPercentValues : showPercentValuesRequared,
                showPercentInToolTip : showPercentInToolTipRequared
            };
        }
    }, chartAPI.singleseries);

    //// add the multyseries
    var sortFN = function (a, b) {
        return a - b;
    }

    chartAPI('xybase', {
        hideRLine : function () {
            var index = this.index,
            regrationLineSeries = this.chart.series[index + 1];
            if (regrationLineSeries && regrationLineSeries.hide) {
                regrationLineSeries.hide();
            }
        },
        showRLine : function () {
            var index = this.index,
            regrationLineSeries = this.chart.series[index + 1];
            if (regrationLineSeries && regrationLineSeries.show) {
                regrationLineSeries.show();
            }
        },
        getRegressionLineSeries : function (regrationObj, showYOnX, dataLength) {
            var data, xMin, xMax, yMin, yMax, slopeB, firstY, secondY, firstX, secondX,
            sumXY = regrationObj.sumXY,
            sumX = regrationObj.sumX,
            sumY = regrationObj.sumY,
            xValues = regrationObj.xValues,
            sumXsqure = regrationObj.sumXsqure,
            yValues = regrationObj.yValues,
            sumYsqure = regrationObj.sumYsqure;
            if(showYOnX){
                //Short the array
                xValues.sort(sortFN);
                //Store X minimum and maximum no
                xMin = xValues[0];
                xMax = xValues[xValues.length - 1];

                slopeB = (dataLength*sumXY - sumX*sumY) / (dataLength*sumXsqure - Math.pow(sumX, 2));
                firstY = (!isNaN(slopeB))? (slopeB * (xMin - sumX/dataLength)) + sumY/dataLength : sumY/dataLength;
                secondY = (!isNaN(slopeB))? (slopeB * (xMax - sumX/dataLength)) + sumY/dataLength : sumY/dataLength;

                data = [{
                    x : xMin,
                    y : firstY
                }, {
                    x : xMax,
                    y : secondY
                }];
            } else {
                //Short the array
                yValues.sort(sortFN);
                //Store Y minimum and maximum no
                yMin = yValues[0];
                yMax = yValues[yValues.length - 1];

                slopeB = (dataLength*sumXY - sumX*sumY) / (dataLength*sumYsqure - Math.pow(sumY, 2));
                firstX = (!isNaN(slopeB))? (slopeB * (yMin - sumY/dataLength)) + sumX/dataLength : sumX/dataLength;
                secondX = (!isNaN(slopeB))? (slopeB * (yMax - sumY/dataLength)) + sumX/dataLength : sumX/dataLength;

                data = [{
                    x : firstX,
                    y : yMin
                }, {
                    x : secondX,
                    y : yMax
                }];
            }
            return data;
        },
        pointValueWatcher: function (HCObj, valueY, valueX, regressionObj) {
            var obj, FCconf = HCObj[FC_CONFIG_STRING], objX;
            if (valueY !== null) {
                obj = FCconf[0];
                obj.max = obj.max > valueY ? obj.max : valueY;
                obj.min = obj.min < valueY ? obj.min : valueY;
            }
            if (valueX !== null) {
                objX = FCconf.x;
                objX.max = objX.max > valueX ? objX.max : valueX;
                objX.min = objX.min < valueX ? objX.min : valueX;
            }
            //code for regration line
            if (regressionObj) {
                var itemValueX = valueX || 0,
                itemValueY = valueY || 0;
                //Calculating the summation of X.
                regressionObj.sumX += itemValueX;
                //Calculating the summation of Y.
                regressionObj.sumY += itemValueY;
                //Calculating the summation of XY.
                regressionObj.sumXY += itemValueX * itemValueY;
                //Calculating the summation of X²
                regressionObj.sumXsqure += Math.pow(itemValueX, 2);
                //Push all the x values
                regressionObj.xValues.push(itemValueX);
                //Calculating the summation of Y²
                regressionObj.sumYsqure += Math.pow(itemValueY, 2);
                //Push all the y values
                regressionObj.yValues.push(itemValueY);

            }
        }

    }, chartAPI.multiseries);

    chartAPI('scrollbase', {
        

        postSeriesAddition: function () {

            var iapi = this,
                hc = iapi.hcJSON,
                xAxis = hc.xAxis,
                scollOptions = xAxis.scroll,
                config = hc[FC_CONFIG_STRING],
                width = config.width,
                catCount = config.x.catCount,
                chartAttrs = iapi.dataObj.chart,
                totalNumPoint,
                numVisiblePlot;

            //add the scroll flag at chart so ttat the cliprect works properly
            config.isScroll = true;
            hc.chart.hasScroll = true;

            if (this.isStacked) {
                numberOfColumnSeries = 1;
            }
            else {
                var numberOfColumnSeries = 0, i = 0, length, seriesArr = hc.series,
                type, columnStr = 'column', defaultseries = hc.chart.defaultSeriesType;
                for (length = seriesArr.length; i < length; i ++) {
                    type = pluck(seriesArr[i].type, defaultseries);
                    if (type === columnStr) {
                        numberOfColumnSeries += 1;
                    }
                }
                if (numberOfColumnSeries < 1) {
                    numberOfColumnSeries = 1;
                }

            }

            totalNumPoint = catCount * numberOfColumnSeries;
            numVisiblePlot = pluckNumber(chartAttrs.numvisibleplot,
                Math.floor(width / iapi.avgScrollPointWidth));

            // Validate numVisiblePlot and then enable the scroll.
            if (scollOptions && numVisiblePlot >= 2 && numVisiblePlot < totalNumPoint) {
                scollOptions.enabled = true;
                scollOptions.vxLength = numVisiblePlot / numberOfColumnSeries;
                scollOptions.startPercent = chartAttrs.scrolltoend === ONESTRING ?
                1 : 0;

                scollOptions.padding = pluckNumber(chartAttrs.scrollpadding,
                    hc.chart.plotBorderWidth / 2);
                scollOptions.height = pluckNumber(chartAttrs.scrollheight, 16);
                scollOptions.buttonWidth = pluckNumber(chartAttrs.scrollbtnwidth,
                    chartAttrs.scrollheight, 16);
                scollOptions.buttonPadding = pluckNumber(chartAttrs.scrollbtnpadding, 0);
                scollOptions.color = getFirstColor(pluck(chartAttrs.scrollcolor,
                    defaultPaletteOptions.altHGridColor[hc.chart.paletteIndex]));

                //add the space for scroller
                config.marginBottomExtraSpace +=
                scollOptions.padding + scollOptions.height;
            }

            if (hasTouch || pluckNumber(chartAttrs.enabletouchscroll, 0)) { // when on touch devices
                hc.chart.zoomType = 'x';
                hc.chart.nativeZoom = false;
                hc.chart.selectionMarkerFill = 'rgba(255,255,255,0)';
                (hc.callbacks || (hc.callbacks = [])).push(function (chart) {
                    addEvent(chart, 'selectionstart selectiondrag', chartAPI.scrollbase.performTouchScroll, {})
                })
            }

        },
        performTouchScroll: function (e) {
            var chart = this,
                xAxis = chart.xAxis[0],
                scroller = xAxis.scroller,
                config = scroller.config,
                scrollBarW = config.trackLength,
                groupWidth = config.width / config.scrollRatio,
                pageX =  (scrollBarW / groupWidth) * (e.chartX || 1);

            if(e.isOutsidePlot === true) {
                return;
            }
            fireEvent(scroller.elements.anchor.element, (e.type === 'selectionstart' ? 'dragstart' : 'drag'), {
                pageX: -pageX,
                pageY: -e.chartY
            });
        }
    }, chartAPI.multiseries);

    chartAPI('logbase', {
        isLog: true,
        // Log charts cannot have negative values.
        isValueAbs: true,
        // Log charts have their own configureAxis function that linearizes log
        // data to make it plottable on ex-renderer
        configureAxis: function (HCObj, FCObj) {
            var conf = HCObj[FC_CONFIG_STRING],
            axisGridManager = conf.axisGridManager,
            numberFormatter = this.numberFormatter,
            series = HCObj.series,
            xAxisObj = HCObj.xAxis,
            yAxisObj = HCObj.yAxis[0],
            yAxisConf = conf[0],
            chartAttr = FCObj.chart,
            hideLimits = !pluckNumber(chartAttr.showlimits,
                chartAttr.showyaxisvalues, 1),
            hideValues = !pluckNumber(chartAttr.showdivlinevalues,
                chartAttr.showyaxisvalues, 1),
            base = pluckNumber(chartAttr.base, chartAttr.logbase, 10),
            userYMax = pluckNumber(chartAttr.yaxismaxvalue),
            userYMin = pluckNumber(chartAttr.yaxisminvalue),

            // Minor grid line color and alpha processing is done here since
            // minor gridlines are specific to log charts.
            showMinorValues = pluckNumber(chartAttr.showminordivlinevalues) === 1,
            minorGlColor = pluck(chartAttr.minordivlinecolor, yAxisObj.gridLineColor,
                defaultPaletteOptions.divLineColor[HCObj.chart.paletteIndex]),
            minorGlAlpha = pluckNumber(chartAttr.minordivlinealpha, chartAttr.divlinealpha,
                defaultPaletteOptions.divLineAlpha[HCObj.chart.paletteIndex]),

            // Grid line configs (gl stands for grid-line)
            majorGridParams = [
            yAxisObj,
            undefined, // variable: value
            undefined, // variable: text
            pluckNumber(chartAttr.divlinethickness, 2), // thickness
            yAxisObj.gridLineDashStyle, // dashed
            yAxisObj.gridLineColor, // color
            2
            ],
            seri,
            minorGridParams = [
            yAxisObj,
            undefined, // variable: value
            undefined, // variable: text
            pluckNumber(chartAttr.minordivlinethickness , 1), // thickness
            yAxisObj.gridLineDashStyle, // dashed
            convertColor(pluck(chartAttr.minordivlinecolor,
                minorGlColor), pluckNumber(chartAttr.minordivlinealpha,
                minorGlAlpha / 2)), // color
            2
            ],

            doCalculateMinors = showMinorValues || (minorGlAlpha &&
                minorGridParams[3]),

            logLimits,
            data,
            item,
            i,
            j;


            // Perform zero validation for log charts. This is very important so
            // as to avoid infinite loop related crashes
            if (base <= 0) {
                base = 10
            }
            if (userYMax <= 0) {
                userYMax = undefined;
            }
            if (userYMin <= 0) {
                userYMin = undefined;
            }



            // Recalculate log limits post data modification.
            logLimits = this.getLogAxisLimits(yAxisConf.max || base,
                yAxisConf.min || 1, userYMax, userYMin, base,
                doCalculateMinors ? chartAttr.numminordivlines : 0);

            xAxisObj.title.text = parseUnsafeString(chartAttr.xaxisname);

            // Configure the axis that is to be processed by ex-renderer
            extend2(yAxisObj, {
                title: { // set axis name
                    text: parseUnsafeString(chartAttr.yaxisname)
                },
                labels: { // disable labels and other ex-renderer own processes.
                    enabled: false
                },
                gridLineWidth: INT_ZERO,
                alternateGridColor: COLOR_TRANSPARENT,
                reversed: (chartAttr.invertyaxis === '1'),
                max: logOf(logLimits.Max, base),
                min: logOf(logLimits.Min, base)
            });

            // Modify all series value
            i = series.length;
            while (i--) {
                seri = series[i];
                if (seri) {
                    //fix #PCXT-427
                   //threshold always should be axis min
                    seri.threshold = yAxisObj.min;
                    data = seri.data;
                    j = data && data.length || 0;
                    while (j--) {
                        item = data[j];
                        item.y = logOf(item.y, base);
                    }
                }
            }

            // delete the min max from conf and mark the conf axis as 'log'
            delete yAxisConf.max;
            delete yAxisConf.min;
            yAxisConf.isLog = true;

            if (yAxisObj.reversed && yAxisObj.min >= 0) {
                HCObj.plotOptions.series.threshold = yAxisObj.max;
            }

            // now put the trends in it
            if (FCObj.trendlines) {
                createTrendLine (FCObj.trendlines, [{
                    max : logLimits.Max,
                    min : logLimits.Min,
                    plotLines : yAxisObj.plotLines,
                    plotBands : yAxisObj.plotBands
                }], conf);
            }

            // Modify all plotLines and plotBands lines
            i = yAxisObj.plotLines.length;
            while (i--) {
                item = yAxisObj.plotLines[i];
                item.value && (item.value = logOf(item.value, base));
                item.from && (item.from = logOf(item.from, base));
                item.to && (item.to = logOf(item.to, base));
            }

            i = yAxisObj.plotBands.length;
            while (i--) {
                item = yAxisObj.plotBands[i];
                item.from && (item.from = logOf(item.from, base));
                item.to && (item.to = logOf(item.to, base));
            }

            // Add the major and minor divlines
            i = logLimits.divArr.length;
            while (i--) {
                item = logLimits.divArr[i];

                if (item.ismajor) {
                    majorGridParams[1] = logOf(item.value, base);
                    majorGridParams[2] = numberFormatter.yAxis(item.value);
                    axisGridManager.addAxisGridLine
                    .apply(axisGridManager, majorGridParams);
                }
                // While calculating minor divlines, we need to draw it (even
                // if it is not needed) when it is in extreme.
                else if (doCalculateMinors || item.isextreme) {
                    minorGridParams[1] = logOf(item.value, base);
                    minorGridParams[2] = (showMinorValues || item.isextreme) ?
                    numberFormatter.yAxis(item.value) : BLANKSTRING;
                    axisGridManager.addAxisGridLine
                    .apply(axisGridManager, minorGridParams);
                }

                // re-using "data" variable to store reference to last plotline.
                data = yAxisObj.plotLines[yAxisObj.plotLines.length - 1];

                // extreme items does not show the lines.
                // the label texts are made blank instead of setting hidden style.
                if (item.isextreme) {
                    data.width = 0.1;
                    if (hideLimits) {
                        data.label.text = BLANK;
                    }
                }
                else if (hideValues && data.label) {
                    data.label.text = BLANK;
                }
            }
            // When space management will be done, yAxis.plotLines needs to be
            // sorted. Refer to base function.
        },

        //log axis helper Function
        /**
        * getAxisLimits is the method to calculate the axis limits
        * of the chart w.r.t. the mantissa of the yMax and yMin.
        * @param	maxValue	the maximum value of the data set to
        *						be plotted.
        * @param	minValue	the minimum value of the data set to
        *						be plotted.
        */
        getLogAxisLimits : function (maxValue , minValue, yAxisMaxValue,
            yAxisMinValue, base, numMinorDivLines ) {
            var
            //Local function to check whether the given parameter is specified or not.
            validate = function (param) {
                if (param == null || param == undefined || param == ""
                    || isNaN (param)) {
                    //Variable is not specified - so return false.
                    return false;
                }
                else {
                    //Variable is specified - so return true.
                    return true;
                }
            },
            //Initialize counter to 0
            counter = 0,
            divLines = [],
            power,
            minLogY,
            maxLogY,
            yMin,
            yMax,
            numDivLines,
            divLineValue,
            //Initial and check value
            iniValue,
            checkValue,
            //Get log of base w.r.t. base=10
            r,
            i,
            j,
            isYMinDivLine,
            isYMaxDivLine,
            d,
            //Numeric interval between two succesive major divLines (variable)
            slabInterval,
            //Numeric interval between two succesive minor divLines (variable) in between 2 successive major divLines
            subInterval;

            // if yAxisMaxValue is valid and greater than yMax
            if (validate(yAxisMaxValue) && Number(yAxisMaxValue) >= maxValue) {
                yMax = Number(yAxisMaxValue);
            } else {
                // for base greater than one
                if (base > 1) {
                    power = mathCeil (mathLog (maxValue) / mathLog (base));
                // for 0 < base < 1

                }
                else {
                    power = mathFloor (mathLog (maxValue) / mathLog (base));
                }
                yMax = mathPow (base, power);
                maxLogY = power;
            }
            // if maxLogY is not yet defined
            if (!maxLogY) {
                // for base greater than one
                if (base > 1) {
                    maxLogY = mathCeil (mathLog (yMax) / mathLog (base));
                } else {
                    maxLogY = mathFloor (mathLog (yMax) / mathLog (base));
                }
            }
            // if yAxisMinValue is valid and less than yMin
            if (validate(yAxisMinValue) && Number(yAxisMinValue) <= minValue) {
                yMin = Number(yAxisMinValue);
            } else {
                // for base greater than one
                if (base > 1) {
                    power = mathFloor(mathLog(minValue) / mathLog(base));
                } else {
                    power = mathCeil(mathLog(minValue) / mathLog(base));
                }
                yMin = mathPow(base, power);
                minLogY = power;
            }
            // if minLogY is not yet defined
            if (!minLogY) {
                // for base greater than one
                if (base > 1) {
                    minLogY = mathFloor(mathLog(yMin) / mathLog(base));
                // for 0 < base < 1
                } else {
                    minLogY = mathCeil (mathLog(yMin) / mathLog(base));
                }
            }
            //}




            //Get log of base w.r.t. base=10
            r = Number (String(mathLog(base) / mathLog(10)));
            //R is integer if base is an integer power of 10. So, set
            //num div lines accordingly.
            numDivLines = Number(numMinorDivLines) || ((mathFloor(r) == r) ? 8 : 4);
            //Initialize iniValue and checkValue w.r.t base value
            if (base > 1) {
                //If base > 1
                iniValue = maxLogY;
                checkValue = minLogY;
            } else if (base > 0 && base < 1) {
                //If base between 0 and 1.
                iniValue = minLogY;
                checkValue = maxLogY;
            }
            //Initialize r to maxLogY. It will be incremented/decremented within loop as required
            r = maxLogY;

            //Loop to calculate major div lines
            for (i = iniValue; i >= checkValue; --i) {

                //Select the major divLines
                // Conditions for major div lines:
                // 1. If y-axis is inverted and div value is not the very first one
                // 	  (the lowest one coinciding with x-axis)
                // OR
                // 2. If y-axis is not inverted and div value is not the very last one
                //	  (the lowest one coinciding with x-axis)
                //if ((invertYAxis && r != maxLogY) || !(invertYAxis || i == checkValue)) {
                //Get the numerical value of div line by getting power of base.
                divLineValue = mathPow(base, r);
                //Create the div line object
                // conditional to avoid plot of major divLines and their axis labels beyond plot area

                if (yMin <= divLineValue && yMax >= divLineValue) {
                    divLines [counter++] = {
                        value: divLineValue,
                        ismajor: true
                    };
                }
                //Increment counter to be used in calculation for minor divLines

                //If it's upper limit (mantissa), no need of the minor divLines, as only major can be plotted
                if (i == checkValue) {
                    continue;
                }
                //Multiplication factor
                //For base <1, powers go in negative -0.1 is 10^-1, 0.001 is 10 ^ -3 and so on.
                d = (base > 1) ? - 1 : 1;
                //Numeric interval between two succesive major divLines (variable)
                slabInterval = mathPow(base, r) - mathPow(base, r + d);
                //Numeric interval between two succesive minor divLines (variable) in between 2 successive major divLines
                subInterval = slabInterval / (numDivLines + 1);
                //Iterate through minor div lines
                for (j = 1; j <= numDivLines; ++j) {
                    //Get the numeric value for minor div line
                    //By adding the sub-interval to power of base (of major div line)
                    divLineValue = mathPow(base, r + d) + subInterval * j;
                    //Create the object
                    // conditional to avoid plot of minor divLines and their axis labels beyond plot area
                    //if (divLineValue>=yMin && divLineValue<=yMax) {
                    if (yMin <= divLineValue && yMax >= divLineValue) {
                        divLines [counter++] = {
                            value: divLineValue,
                            ismajor: false
                        };
                    }
                //Increment
                }
                //Update counter corresponding to next major divLine w.r.t. base value
                if (base > 1) {
                    r--;
                } else {
                    r++;
                }
            }
            // iterating to check if the limits are divLines and flagged
            for (var u in divLines) {
                for (var e in divLines [u]) {
                    if (e == 'value') {
                        //if its found that yMin is a divLine, then don't work on it anymore
                        if (!isYMinDivLine) {
                            isYMinDivLine = (divLines [u][e] == yMin) &&
                            (divLines[u].isextreme = true);
                        }
                        //if its found that yMax is a divLine, then don't work on it anymore
                        if (!isYMaxDivLine) {
                            isYMaxDivLine = (divLines [u][e] == yMax) &&
                            (divLines [u].isextreme = true);
                        }
                    }
                }
            }

            // if yMin is not a divLine
            if (!isYMinDivLine) {
                // include yMin as a divLine
                divLines [counter++] = {
                    value: yMin,
                    ismajor: true,
                    isextreme: true
                };
            }
            // if yMax is not a divLine
            if (!isYMaxDivLine) {
                // include yMax as a divLine
                divLines [counter] = {
                    value: yMax,
                    ismajor: true,
                    isextreme: true
                };
            }

            ///return
            return {
                Max: yMax,
                Min: yMin,
                divArr: divLines
            };
        },

        // PVWathcer of log chart needs to avoid/drop negative values.
        pointValueWatcher: function (HCObj, value, yAxisIndex) {
            var axis,
            conf = HCObj[FC_CONFIG_STRING];

            yAxisIndex = pluckNumber(yAxisIndex, 0);

            if (value > 0) {
                if (!conf[yAxisIndex]) {
                    conf[yAxisIndex] = {};
                }

                axis = conf[yAxisIndex];
                axis.max = axis.max > value ? axis.max : value;
                axis.min = axis.min < value ? axis.min : value;
            }
        }
    }, chartAPI.mslinebase);

    //////// COMMOM Charts to be use as charts as well as PowerCharts   //////////////
    /////////////////  column2d //////////////
    var singleSeriesAPI = chartAPI.singleseries,
        multiSeriesAPI = chartAPI.multiseries;

    //add the charts
    //only the point and default series will differ from singleSeriesAPI
    chartAPI('column2dbase', {
        point : function (chartName, series, data, FCChartObj, HCObj) {

            // length of the data
            var length = data.length,
                // ex-renderer configuration
                conf = HCObj[FC_CONFIG_STRING],
                // axisGridManager to manage the axis
                // it contains addVline, addXaxisCat, addAxisAltGrid and
                // addAxisGridLine function
                axisGridManager = conf.axisGridManager,
                // ex-renderer xAxis obj
                xAxisObj = HCObj.xAxis,
                // palette of the chart
                paletteIndex = HCObj.chart.paletteIndex,
                // xAxis configuration it contains configuration of xAxis like
                // catCount, horizontalAxisNamePadding, horizontalLabelPadding,
                // labelDisplay, slantLabels, staggerLines
                xAxisConf = conf.x,
                // Array of default colors (paletteColors)
                // We use it to specify the individual data point color
                defaultColors = HCObj.colors,
                // Length of the default colors
                defaultColLen = HCObj.colors.length,
                // is3d and isBar helps to get the column color by
                // getColumnColor function
                // whether the chart is a 3D or Bar
                is3d = /3d$/.test(HCObj.chart.defaultSeriesType),
                isBar = this.isBar,
                // dataplot border width
                // Managing for 3D too
                showPlotBorder = pluck(FCChartObj.showplotborder,
                    (is3d ? ZEROSTRING : ONESTRING) ) === ONESTRING,
                // 3D column chart doesn't show the plotborder by default
                // until we set showplotborder true
                setBorderWidth = showPlotBorder ?
                (is3d ? 1 : pluckNumber(FCChartObj.plotborderthickness, 1)) : 0,
                // whether to use round edges or not in the column
                isRoundEdges = HCObj.chart.useRoundEdges,
                // dataplot border alpha
                setPlotBorderAlpha = pluckNumber(FCChartObj.plotborderalpha,
                    FCChartObj.plotfillalpha, 100),
                // dataplot border color
                setPlotBorderColor = pluck(FCChartObj.plotbordercolor,
                    defaultPaletteOptions.plotBorderColor[paletteIndex])
                    .split(COMMASTRING)[0],
                // GradientColor of the area fill
                seriesGradientColor = COMMASTRING +
                (pluckNumber(FCChartObj.useplotgradientcolor, 1) ?
                getDefinedColor(FCChartObj.plotgradientcolor,
                    defaultPaletteOptions.plotGradientColor[paletteIndex]) :
                BLANKSTRING),
                // Original index of the data inside the loop
                catIndex = 0,
                // use3DLighting to show gredient color effect in 3D Column charts
                use3DLighting = Boolean(pluckNumber(FCChartObj.use3dlighting,
                1)),
                NumberFormatter = HCObj[FC_CONFIG_STRING].numberFormatter,
                // Calculate the dashStyle per point
                pointDashStyle,
                seriesDashStyle = pluckNumber(FCChartObj.plotborderdashed, 0),
                // length of the dash
                seriesDashLen = pluckNumber(FCChartObj.plotborderdashlen, 5),
                // distance between dash
                seriesDashGap = pluckNumber(FCChartObj.plotborderdashgap, 4),

                itemValue,
                index,
                countPoint,
                dataLabel,
                setColor,
                setAlpha,
                setRatio,
                colorArr,
                dataObj,
                setAngle,
                showLabel,
                pointShadow;

            // Iterate through all level data
            // We are managing the data value labels and other cosmetics
            // inside this loop
            for (index = 0, countPoint = 0; index < length; index += 1) {

                // individual data obj
                dataObj = data[index];

                // Managing vLines in between <set> elements
                // If its vline
                // we call the grid manager addVline function,
                // that creates vline and we stop execution here and
                // continue the loop to next data
                if (dataObj.vline) {
                    axisGridManager.addVline(xAxisObj, dataObj, catIndex,
                        HCObj);
                    continue;
                }

                // get the valid value
                // parsePointValue check the its a value value of not and
                // return the valid value
                itemValue = NumberFormatter.getCleanValue(dataObj.value);
                // we check showLabel in individual data
                // if its set to 0 than we do not show the particular label
                showLabel = pluckNumber(dataObj.showlabel,
                    FCChartObj.showlabels, 1);

                // Label of the data
                // getFirstValue returns the first defined value in arguments
                // we check if showLabel is not set to 0 in data
                // then we take the label given in data, it can be given using
                // label as well as name too
                // we give priority to label if label is not there,
                // we check the name attribute
                dataLabel = parseUnsafeString(getFirstValue(dataObj.label, dataObj.name));
                // adding label in HighChart xAxis categories
                // increase category counter by one
                axisGridManager.addXaxisCat(xAxisObj, catIndex, catIndex,
                    showLabel ? dataLabel : BLANKSTRING);
                catIndex += 1;

                // <set> cosmetics
                // Color of the particular data
                setColor = pluck(dataObj.color, defaultColors[countPoint %
                        defaultColLen]) + seriesGradientColor.replace(/,+?$/,'');
                // Alpha of the data
                setAlpha = pluck(dataObj.alpha, FCChartObj.plotfillalpha,
                    HUNDREDSTRING);
                // Fill ratio of the data
                setRatio = pluck(dataObj.ratio, FCChartObj.plotfillratio);
                // defaultAngle depend upon item value
                setAngle = pluck(360 - FCChartObj.plotfillangle, isBar ? 180 : 90);

                if (itemValue < 0) {
                    if (isBar){
                        setAngle = 180 - setAngle;
                    }
                    else {
                        setAngle = 360 - setAngle;
                    }
                }

                // Used to set alpha of the shadow
                pointShadow = {
                    opacity: setAlpha / 100
                };

                // calculate the color object for the column
                colorArr = getColumnColor (setColor, setAlpha, setRatio,
                    setAngle, isRoundEdges, setPlotBorderColor,
                    pluck(dataObj.alpha, setPlotBorderAlpha) + BLANKSTRING,
                        isBar, is3d);

                // get per-point dash-style
                pointDashStyle = pluckNumber(dataObj.dashed, seriesDashStyle) ?
                getDashStyle(pluck(dataObj.dashlen, seriesDashLen),
                    pluck(dataObj.dashgap, seriesDashGap), setBorderWidth) :
                        undefined;

                // Finally add the data
                // we call getPointStub function that manage displayValue,
                // toolText and link
                series.data.push( extend2(
                    this.getPointStub(dataObj, itemValue, dataLabel, HCObj), {
                        y: itemValue,
                        shadow: pointShadow,
                        color: colorArr[0],
                        borderColor: colorArr[1],
                        borderWidth: setBorderWidth,
                        use3DLighting: use3DLighting,
                        dashStyle: pointDashStyle,
                        tooltipConstraint : this.tooltipConstraint

                       })
                );
                // Set the maximum and minimum found in data
                // pointValueWatcher use to calculate the maximum and minimum
                // value of the Axis
                this.pointValueWatcher(HCObj, itemValue);
                countPoint += 1;
            }
            // set the xAxisConf catCount for further use
            xAxisConf.catCount = catIndex;

            return series;
        },
        defaultSeriesType : 'column'
    }, singleSeriesAPI);

    /////////////// Line ///////////
    chartAPI('linebase', {
        defaultSeriesType : 'line',
        hasVDivLine : true,
        defaultPlotShadow: 1,

        point : function (chartName, series, data, FCChartObj, HCObj) {
            var itemValue, index, dataLabel, dataObj,
            countPoint, showLabel, dashStyle, pointShadow,
            lineDashLen, lineDashGap, lineColor, lineAlpha, lineThickness,
            lineDashed, drawAnchors, lineColorDef, lineAlphaDef,
            pointAnchorEnabled,
            // set attributes
            setAnchorSides, setAnchorBorderThickness, setAnchorBorderColor,
            setAnchorRadius, setAnchorBgColor, setAnchorAlpha, setAnchorBgAlpha,
            setAnchorAngle,
            HCChartObj = HCObj.chart,
            // length of the data
            length = data.length,
            // ex-renderer xAxis obj
            xAxisObj = HCObj.xAxis,
            // ex-renderer configuration
            conf = HCObj[FC_CONFIG_STRING],
            // axisGridManager to manage the axis
            // it contains addVline, addXaxisCat, addAxisAltGrid and
            // addAxisGridLine function
            axisGridManager = conf.axisGridManager,
            catIndex = 0,
            xAxisConf = conf.x,
            paletteIndex = HCObj.chart.paletteIndex,
            NumberFormatter = HCObj[FC_CONFIG_STRING].numberFormatter;

            // Managing line series cosmetics
            // Color of the line
            lineColorDef = getFirstColor(pluck(FCChartObj.linecolor,
                FCChartObj.palettecolors,
                defaultPaletteOptions.plotFillColor[paletteIndex]));
            // alpha
            lineAlphaDef = pluck(FCChartObj.linealpha, HUNDREDSTRING);
            // thickness
            lineThickness = pluckNumber(FCChartObj.linethickness, this.lineThickness, 4);
            // to use dash line
            lineDashed = Boolean(pluckNumber(FCChartObj.linedashed, 0));
            // length of the dash
            lineDashLen = pluckNumber(FCChartObj.linedashlen, 5);
            // distance between dash
            lineDashGap = pluckNumber(FCChartObj.linedashgap, 4);

            // set the line color and alpha to
            // HC seris obj with FusionCharts color format using FCcolor obj
            series.color = {
                FCcolor: {
                    color: lineColorDef,
                    alpha: lineAlphaDef
                }
            };

            // set the line thickness (line width)
            series.lineWidth = lineThickness;

            // IF its a step line chart
            series.step = pluck(this.stepLine, series.step);
            // Special attribute for StepLine (drawVerticalJoins)
            series.drawVerticalJoins = Boolean(pluckNumber(series.drawVerticalJoins, FCChartObj.drawverticaljoins, 1));
            series.useForwardSteps = Boolean(pluckNumber(series.useForwardSteps, FCChartObj.useforwardsteps, 1));

            // Managing line series markers
            // Whether to drow the Anchor or not
            drawAnchors = pluckNumber(FCChartObj.drawanchors ,
                FCChartObj.showanchors);

            // Iterate through all level data
            for (index = 0, countPoint = 0; index < length; index += 1) {
                // individual data obj
                // for further manipulation
                dataObj = data[index];

                // Managing vLines in between <set> elements
                // If its vline
                // we call the grid manager addVline function, that creates vline
                // and we stop execution here and continue the loop to next data
                if (dataObj.vline) {
                    axisGridManager.addVline(xAxisObj, dataObj, catIndex, HCObj);
                    continue;
                }

                // get the valid value
                // parsePointValue check the its a value value of not and return
                // the valid value
                itemValue = NumberFormatter.getCleanValue(dataObj.value);

                // we check showLabel in individual data
                // if its set to 0 than we do not show the particular label
                showLabel = pluckNumber(dataObj.showlabel, FCChartObj.showlabels, 1);

                // Label of the data
                // getFirstValue returns the first defined value in arguments
                // we check if showLabel is not set to 0 in data
                // then we take the label given in data, it can be given using label as well as name too
                // we give priority to label if label is not there, we check the name attribute
                dataLabel = parseUnsafeString(getFirstValue(dataObj.label, dataObj.name));

                // adding label in HighChart xAxis categories
                // increase category counter by one
                axisGridManager.addXaxisCat(xAxisObj, catIndex, catIndex, showLabel ? dataLabel : BLANKSTRING);
                catIndex += 1;

                // Managing line series cosmetics
                // Color of the line
                lineColor = getFirstColor(pluck( dataObj.color, lineColorDef));
                // alpha
                lineAlpha = pluck(dataObj.alpha, lineAlphaDef);

                // create line dash
                // using dashStyle of HC
                dashStyle = pluckNumber(dataObj.dashed, lineDashed) ? getDashStyle(lineDashLen,
                    lineDashGap, lineThickness) : undefined;

                pointShadow = {
                    opacity: lineAlpha / 100
                };

                // Anchor cosmetics in data points
                // Getting anchor cosmetics for the data points or its default values
                // The default value is different from flash in order to render a
                // perfect circle when no anchorside is provided.
                setAnchorSides = pluckNumber(dataObj.anchorsides,
                    FCChartObj.anchorsides, 0);
                setAnchorAngle = pluckNumber(dataObj.anchorstartangle,
                    FCChartObj.anchorstartangle, 90);
                setAnchorRadius = pluckNumber(dataObj.anchorradius,
                    FCChartObj.anchorradius, this.anchorRadius, 3);
                setAnchorBorderColor = getFirstColor(pluck(dataObj.anchorbordercolor,
                    FCChartObj.anchorbordercolor, lineColorDef));
                setAnchorBorderThickness = pluckNumber(dataObj.anchorborderthickness,
                    FCChartObj.anchorborderthickness, this.anchorBorderThickness, 1);
                setAnchorBgColor = getFirstColor(pluck(dataObj.anchorbgcolor,
                    FCChartObj.anchorbgcolor, defaultPaletteOptions.anchorBgColor[paletteIndex]));
                setAnchorAlpha = pluck(dataObj.anchoralpha, FCChartObj.anchoralpha,
                    HUNDREDSTRING);
                setAnchorBgAlpha = pluck(dataObj.anchorbgalpha,
                    FCChartObj.anchorbgalpha, setAnchorAlpha);
                pointAnchorEnabled = drawAnchors === undefined ?
                lineAlpha != 0 : !!drawAnchors;

                // Finally add the data
                // we call getPointStub function that manage displayValue, toolText and link
                series.data.push(extend2(
                    this.getPointStub(dataObj, itemValue, dataLabel, HCObj),
                    {
                        y : itemValue,
                        color: {
                            FCcolor: {
                                color: lineColor,
                                alpha: lineAlpha
                            }
                        },
                        shadow: pointShadow,
                        dashStyle: dashStyle,
                        valuePosition: pluck(dataObj.valueposition, HCChartObj.valuePosition),
                        marker : {
                            enabled: !!pointAnchorEnabled,
                            fillColor: {
                                FCcolor: {
                                    color: setAnchorBgColor,
                                    alpha: ((setAnchorBgAlpha * setAnchorAlpha) / 100) + BLANKSTRING
                                }
                            },
                            lineColor: {
                                FCcolor: {
                                    color: setAnchorBorderColor,
                                    alpha: setAnchorAlpha
                                }
                            },
                            lineWidth: setAnchorBorderThickness,
                            radius: setAnchorRadius,
                            startAngle: setAnchorAngle,
                            symbol: mapSymbolName(setAnchorSides)
                        },
                        tooltipConstraint : this.tooltipConstraint
                    }));

                // Set the maximum and minimum found in data
                // pointValueWatcher use to calculate the maximum and minimum value of the Axis
                this.pointValueWatcher(HCObj, itemValue);
                countPoint += 1;
            }
            xAxisConf.catCount = catIndex;
            //return series
            return series;
        },
        defaultZeroPlaneHighlighted: false
    }, singleSeriesAPI);

    /////////////// Area ///////////
    chartAPI('area2dbase', {
        defaultSeriesType : 'area',
        hasVDivLine : true,

        point :
        function (chartName, series, data, FCChartObj, HCObj) {
            // HighChart chart obj
            var HCChartObj = HCObj.chart,
                // Data array in dataset object
                length = data.length,
                // ex-renderer xAxis obj
                xAxisObj = HCObj.xAxis,
                // HighChart configuration object
                conf = HCObj[FC_CONFIG_STRING],
                // Index of the palette to be use for charts palette cosmetics
                paletteIndex = HCObj.chart.paletteIndex,
                // axisGridManager to manage the axis
                // it contains addVline, addXaxisCat, addAxisAltGrid and
                // addAxisGridLine function
                axisGridManager = conf.axisGridManager,
                xAxisConf = conf.x,
                NumberFormatter = HCObj[FC_CONFIG_STRING].numberFormatter,
                catIndex = 0,

                itemValue,
                index,
                dataLabel,
                showLabel,
                seriesFillColor,
                seriesFillAlpha,
                seriesFillAngle,
                seriesLineColor,
                seriesLineAlpha,
                seriesLineAngle,
                seriesLineRatio,
                setAnchorSides,
                setAnchorRadius,
                setAnchorBorderColor,
                setAnchorAngle,
                dataObj,
                setAnchorBgColor,
                setAnchorAlpha,
                setAnchorBgAlpha,
                drawAnchors,
                seriesDashed,
                seriesDashLen,
                seriesDashGap,
                seriesLineThickness,
                setAnchorBorderThickness,
                countPoint,
                setColor,
                setAlpha,
                seriesGradientColor,
                pointShadow,
                seriesFill,
                pointFillColor;

            // Managing Area cosmetics
            // Color of the area
            seriesFillColor = pluck(FCChartObj.plotfillcolor,
                FCChartObj.areabgcolor, (getValidValue(FCChartObj.palettecolors)
                    ? HCObj.colors[0] : defaultPaletteOptions.plotFillColor
                    [paletteIndex])).split(COMMASTRING)[0];
            // GradientColor of the area fill
            seriesGradientColor = COMMASTRING +
            (pluckNumber(FCChartObj.useplotgradientcolor, 1) ?
                getDefinedColor(FCChartObj.plotgradientcolor,
                defaultPaletteOptions.plotGradientColor[paletteIndex]) :
            BLANKSTRING);
            seriesFillAlpha = pluck(FCChartObj.plotfillalpha,
                FCChartObj.areaalpha, this.isStacked ? HUNDREDSTRING : '90');
            seriesFillAngle = pluckNumber(FCChartObj.plotfillangle , 270);

            // Managing line series cosmetics
            // Color of the line
            seriesLineColor = pluck(FCChartObj.plotbordercolor,
                FCChartObj.areabordercolor,
                (getValidValue(FCChartObj.palettecolors) ?
                    HCObj.colors[0] :
                    defaultPaletteOptions.plotBorderColor[paletteIndex]))
                .split(COMMASTRING)[0];

            // Plot border alpha
            seriesLineAlpha = FCChartObj.showplotborder == ZEROSTRING ?
            ZEROSTRING : pluck(FCChartObj.plotborderalpha,
                FCChartObj.plotfillalpha, FCChartObj.areaalpha,
                HUNDREDSTRING);
            seriesLineAngle = pluckNumber(FCChartObj.plotborderangle , 270);
            seriesLineRatio = HUNDREDSTRING;
            seriesDashed = Boolean(pluckNumber(FCChartObj.plotborderdashed, 0));
            seriesDashLen = pluckNumber(FCChartObj.plotborderdashlen, 5);
            seriesDashGap = pluckNumber(FCChartObj.plotborderdashgap, 4);
            // Plot border thickness
            seriesLineThickness = pluckNumber(FCChartObj.plotborderthickness,
                FCChartObj.areaborderthickness, 1);
            // Set the area fill color and alpha to
            // HC seris obj with FusionCharts color format using FCcolor obj
            seriesFill = series.fillColor = {
                FCcolor: {
                    color: seriesFillColor + seriesGradientColor.replace(/,+?$/,''),
                    alpha: seriesFillAlpha,
                    ratio: BGRATIOSTRING,
                    angle: seriesFillAngle
                }
            };

            series.lineWidth = seriesLineThickness;
            series.dashStyle  = seriesDashed ? getDashStyle(seriesDashLen,
                seriesDashGap, seriesLineThickness) : undefined;
            // set the line color and alpha to
            // HC seris obj with FusionCharts color format using FCcolor obj
            series.lineColor = {
                FCcolor: {
                    color: seriesLineColor,
                    alpha: seriesLineAlpha,
                    ratio: seriesLineRatio,
                    angle: seriesLineAngle
                }
            };

           // IF its a step area chart
            series.step = pluck(this.stepLine, series.step);
            // Special attribute for StepLine (drawVerticalJoins)
            series.drawVerticalJoins = Boolean(pluckNumber(series.drawVerticalJoins, FCChartObj.drawverticaljoins, 1));
            series.useForwardSteps = Boolean(pluckNumber(series.useForwardSteps, FCChartObj.useforwardsteps, 1));


            // Managing line series markers
            // Whether to drow the Anchor or not
            drawAnchors = Boolean(pluckNumber(FCChartObj.drawanchors ,
                FCChartObj.showanchors , 1));

            // Iterate through all level data
            for (index = 0, countPoint = 0; index < length; index += 1) {

                dataObj = data[index];

                // vLine
                if (dataObj.vline) {
                    axisGridManager.addVline(xAxisObj, dataObj, catIndex,
                    HCObj);
                    continue;
                }

                itemValue = NumberFormatter.getCleanValue(dataObj.value);

                showLabel = pluckNumber(dataObj.showlabel,
                    FCChartObj.showlabels, 1);
                // Label of the data
                // getFirstValue returns the first defined value in arguments
                // we check if showLabel is not set to 0 in data
                // then we take the label given in data, it can be given
                // using label as well as name too
                // we give priority to label if label is not there,
                // we check the name attribute
                dataLabel = parseUnsafeString(getFirstValue(dataObj.label, dataObj.name));
                // Put label in ex-renderer xAxis categories
                axisGridManager.addXaxisCat(xAxisObj, catIndex, catIndex,
                    showLabel ? dataLabel : BLANKSTRING);
                catIndex += 1;

                // Taking default anchor cosmetics form dataset obj or
                // Chart obj or default
                setAnchorSides = pluckNumber(dataObj.anchorsides,
                    FCChartObj.anchorsides, 0);
                setAnchorAngle = pluckNumber(dataObj.anchorstartangle,
                    FCChartObj.anchorstartangle, 90);
                setAnchorRadius = pluckNumber(dataObj.anchorradius,
                    FCChartObj.anchorradius, 3);
                setAnchorBorderColor = getFirstColor(pluck(
                    dataObj.anchorbordercolor, FCChartObj.anchorbordercolor,
                    seriesLineColor));
                setAnchorBorderThickness = pluckNumber(
                    dataObj.anchorborderthickness,
                    FCChartObj.anchorborderthickness, 1);
                setAnchorBgColor = getFirstColor(pluck(dataObj.anchorbgcolor,
                    FCChartObj.anchorbgcolor,
                        defaultPaletteOptions.anchorBgColor[paletteIndex]));
                setAnchorAlpha = pluck(dataObj.anchoralpha,
                FCChartObj.anchoralpha, this.anchorAlpha, ZEROSTRING);
                setAnchorBgAlpha = pluck(dataObj.anchorbgalpha,
                    FCChartObj.anchorbgalpha, setAnchorAlpha);


                // Managing line series cosmetics
                // Color of the line
                

                setColor = getValidValue(dataObj.color);
                // alpha
                setAlpha = pluckNumber(dataObj.alpha);

                if (setColor !== undefined || setAlpha !== undefined) {
                    pointFillColor = {
                        FCcolor: {
                            color: setColor ? getFirstColor(setColor) +
                                seriesGradientColor : seriesFillColor,
                            alpha: undefined === setAlpha ?
                                getFirstAlpha(setAlpha) + BLANKSTRING :
                                seriesFillAlpha,
                            ratio: BGRATIOSTRING,
                            angle: seriesFillAngle
                        }
                    }
                }
                else {
                    pointFillColor = seriesFill;
                }


                // Used to set alpha of the shadow
                pointShadow = {
                    opacity: Math.max(setAlpha, seriesLineAlpha) / 100,
                    inverted: true
                };

                // Finally add the data
                // we call getPointStub function that manage displayValue,
                // toolText and link
                series.data.push(extend2(
                    this.getPointStub(dataObj, itemValue, dataLabel, HCObj),
                    {
                        y : itemValue,
                        shadow: pointShadow,
                        color: pointFillColor,
                        valuePosition: pluck(dataObj.valueposition,
                            HCChartObj.valuePosition),
                        marker : {
                            enabled: drawAnchors,
                            fillColor: {
                                FCcolor: {
                                    color: setAnchorBgColor,
                                    alpha: ((setAnchorBgAlpha * setAnchorAlpha) /
                                         100) + BLANKSTRING
                                }
                            },
                            lineColor: {
                                FCcolor: {
                                    color: setAnchorBorderColor,
                                    alpha: setAnchorAlpha
                                }
                            },
                            lineWidth: setAnchorBorderThickness,
                            radius: setAnchorRadius,
                            symbol: mapSymbolName(setAnchorSides),
                            startAngle: setAnchorAngle
                        },
                        tooltipConstraint : this.tooltipConstraint,
                        // Set the maximum and minimum found in data
                        // pointValueWatcher use to calculate the maximum and minimum
                        // value of the Axis
                        previousY: this.pointValueWatcher(HCObj, itemValue)
                    }));


                countPoint += 1;
            }
            xAxisConf.catCount = catIndex;

            //return series
            return series;
        }
    }, singleSeriesAPI);

    

    var getDataParser = lib.getDataParser = {
        column : function (HCObj, seriesConf, chartAPI) {
            var conf = HCObj[FC_CONFIG_STRING],
            borderWidth = seriesConf.borderWidth;

            return function (dataObj, index, itemValue) {
                // Alpha of the data point
                // using getFirstAlpha to avoid comma separated alpha
                var setAlpha = getFirstAlpha(pluck(dataObj.alpha,
                    seriesConf.alpha)).toString(),
                // Used to set alpha of the shadow
                pointShadow = {
                    opacity: setAlpha / 100
                },
                isBar = seriesConf.isBar,
                fillAangle = seriesConf.fillAangle,
                angle = itemValue < 0 ? (isBar ? (180 - fillAangle) : (360 - fillAangle)) : fillAangle,
                // calculate the color object for the set
                colorArr = getColumnColor (pluck(dataObj.color, seriesConf.color) + seriesConf.plotgradientcolor,
                    setAlpha, pluck(dataObj.ratio, seriesConf.ratio), angle, seriesConf.isRoundEdges,
                    seriesConf.plotBorderColor,  Math.min(setAlpha,
                        // using getFirstAlpha to avoid comma separated alpha
                        getFirstAlpha(seriesConf.plotBorderAlpha)).toString(),
                    isBar, seriesConf.is3d),
                // get per-point dash-style
                pointDashStyle = pluckNumber(dataObj.dashed, seriesConf.dashed) ?
                getDashStyle(pluck(dataObj.dashlen, seriesConf.dashLen),
                    pluck(dataObj.dashgap, seriesConf.dashGap), borderWidth) : undefined,
                point = chartAPI.getPointStub(dataObj, itemValue, conf.oriCatTmp[index], HCObj, seriesConf, seriesConf.showValues, seriesConf.yAxis);
                point.y = itemValue;
                point.shadow= pointShadow;
                point.color= colorArr[0];
                point.borderColor= colorArr[1];
                point.borderWidth= borderWidth;
                point.use3DLighting = seriesConf.use3DLighting;
                point.dashStyle= pointDashStyle;
                point.tooltipConstraint = chartAPI.tooltipConstraint;
                return point;
            };
        },
        line : function (HCObj, seriesConf, chartAPI) {
            var conf = HCObj[FC_CONFIG_STRING];

            return function (dataObj, index, itemValue) {
                // Alpha
                var lineAlpha = pluck(dataObj.alpha, seriesConf.lineAlpha),
                // Used to set alpha of the shadow
                pointShadow = {
                    opacity: lineAlpha / 100
                },
                setAnchorAlpha = pluck(dataObj.anchoralpha, seriesConf.anchorAlpha),
                point = chartAPI.getPointStub(dataObj, itemValue, conf.oriCatTmp[index], HCObj, seriesConf, seriesConf.showValues, seriesConf.yAxis);
                point.y = itemValue;
                point.shadow= pointShadow;
                point.dashStyle = pluckNumber(dataObj.dashed, seriesConf.lineDashed) ?
                getDashStyle(seriesConf.lineDashLen, seriesConf.lineDashGap, seriesConf.lineThickness) : undefined;
                point.color= {
                    FCcolor: {
                        color: getFirstColor(pluck(dataObj.color, seriesConf.lineColor)),
                        alpha: lineAlpha
                    }
                };
                point.valuePosition = pluck(dataObj.valueposition, seriesConf.valuePosition);
                point.marker = {
                    enabled:  seriesConf.drawAnchors === undefined ?
                    lineAlpha != 0 : !!seriesConf.drawAnchors,
                    fillColor: {
                        FCcolor: {
                            color: getFirstColor(pluck(dataObj.anchorbgcolor, seriesConf.anchorBgColor)),
                            alpha: (pluck(dataObj.anchorbgalpha, seriesConf.anchorBgAlpha) * setAnchorAlpha / 100).toString()
                        }
                    },
                    lineColor: {
                        FCcolor: {
                            color: getFirstColor(pluck(dataObj.anchorbordercolor, seriesConf.anchorBorderColor)),
                            alpha: setAnchorAlpha
                        }
                    },
                    lineWidth: pluckNumber(dataObj.anchorborderthickness, seriesConf.anchorBorderThickness),
                    radius: pluckNumber(dataObj.anchorradius, seriesConf.anchorRadius),
                    symbol: mapSymbolName(pluckNumber(dataObj.anchorsides, seriesConf.anchorSides)),
                    startAngle: pluck(dataObj.anchorstartangle, seriesConf.anchorAngle)
                };
                return point;
            };
        },
        area : function (HCObj, seriesConf, chartAPI) {
            var conf = HCObj[FC_CONFIG_STRING];

            return function (dataObj, index, itemValue) {
                // Alpha
                var setAlpha = pluck(dataObj.alpha, seriesConf.fillAlpha),
                // Used to set alpha of the shadow
                pointShadow = {
                    opacity: Math.max(setAlpha, seriesConf.lineAlpha) / 100,
                    inverted: true
                },
                setAnchorAlpha = pluck(dataObj.anchoralpha, seriesConf.anchorAlpha),
                point = chartAPI.getPointStub(dataObj, itemValue, conf.oriCatTmp[index], HCObj, seriesConf, seriesConf.showValues, seriesConf.yAxis);
                point.y = itemValue;
                point.shadow= pointShadow;
                point.color= {
                    FCcolor: {
                        color: getFirstColor(pluck(dataObj.color, seriesConf.fillColor)),
                        alpha: setAlpha
                    }
                };
                point.valuePosition = pluck(dataObj.valueposition, seriesConf.valuePosition);
                point.marker = {
                    enabled:  seriesConf.drawAnchors,
                    fillColor: {
                        FCcolor: {
                            color: getFirstColor(pluck(dataObj.anchorbgcolor, seriesConf.anchorBgColor)),
                            alpha: (pluck(dataObj.anchorbgalpha, seriesConf.anchorBgAlpha) * setAnchorAlpha / 100).toString()
                        }
                    },
                    lineColor: {
                        FCcolor: {
                            color: getFirstColor(pluck(dataObj.anchorbordercolor, seriesConf.anchorBorderColor)),
                            alpha: setAnchorAlpha
                        }
                    },
                    lineWidth: pluckNumber(dataObj.anchorborderthickness, seriesConf.anchorBorderThickness),
                    radius: pluckNumber(dataObj.anchorradius, seriesConf.anchorRadius),
                    symbol: mapSymbolName(pluckNumber(dataObj.anchorsides, seriesConf.anchorSides)),
                    startAngle: pluck(dataObj.anchorstartangle, seriesConf.anchorAngle)
                };
                point.events = {
                    click: seriesConf.getLink
                }
                return point;
            };
        }
    };

    /////////////// mscolumn2d ///////////
    chartAPI('mscolumn2dbase', {
        /*
         *  Function for MSColumn2D chart
         *  @param {string} chartName name of the chart eg: column2d
         *  @param {object} series HighChart series object where the point will be added
         *  @param {object} dataset corresponding FusionCharts dataset object
         *  @param {object} FCChartObj FusionCharts JSON of chart tag
         *  @param {object} HCObj HighChart JSON object
         *  @param {number} catLength total number of categories
         *  @param {number} seriesIndex index position of that series
         *  @param {number} MSStackIndex stack index of that series (only for MSStacked)
         *  @param {number} position of the column for MSColumn or MSStacked charts
         */
        point : function (chartName, series, dataset, FCChartObj, HCObj,
                    catLength, seriesIndex, MSStackIndex, columnPosition) {

            var hasValidPoint = false,
                data = dataset.data || [],
                dataParser,
                // HighChart configuration object
                conf = HCObj[FC_CONFIG_STRING],
                // take the series type
                seriesType = pluck(series.type, this.defaultSeriesType),
                // Check the chart is a stacked chart or not
                isStacked = pluck(series.isStacked, (HCObj.plotOptions[seriesType] &&
                    HCObj.plotOptions[seriesType].stacking)),
                // 100% stacked chart takes absolute values only
                isValueAbs = pluck(this.isValueAbs, conf.isValueAbs, false),
                // showValues attribute in individual dataset
                seriesYAxis = pluckNumber(series.yAxis, 0),
                NumberFormatter = HCObj[FC_CONFIG_STRING].numberFormatter,
                paletteIndex = HCObj.chart.paletteIndex,
                itemValue,
                index,
                dataObj,
                fillAangle,
                isBar = HCObj._FCconf.isBar,
                is3d,
                pointObj;

            //add column position
            if (!isStacked) {
             series.columnPosition = pluckNumber(columnPosition, MSStackIndex, seriesIndex);
            }

            // Dataset seriesname
            series.name = getValidValue(dataset.seriesname);

            // If includeInLegend set to false
            // We set series.name blank
            if (pluckNumber(dataset.includeinlegend) === 0 ||
                    series.name === undefined) {
                series.showInLegend = false;
            }

            // Color of the individual series
            series.color = pluck(dataset.color, HCObj.colors[seriesIndex %
                    HCObj.colors.length]).split(COMMASTRING)[0]
                .replace(/^#?/g, "#");
            // is3d and isBar helps to get the column color by
            // getColumnColor function
            // whether the chart is a 3D
            is3d = /3d$/.test(HCObj.chart.defaultSeriesType);

            fillAangle = pluck(360 - FCChartObj.plotfillangle, isBar ? 180 : 90);
            if (itemValue < 0) {
                fillAangle = 360 - fillAangle;
            }
            dataParser = series._dataParser = getDataParser.column(HCObj, {
                seriesname : series.name,
                color : pluck(dataset.color, HCObj.colors[seriesIndex %
                        HCObj.colors.length]),
                alpha : pluck(dataset.alpha, FCChartObj.plotfillalpha,
                    HUNDREDSTRING),
                plotgradientcolor : COMMASTRING +
                    (pluckNumber(FCChartObj.useplotgradientcolor, 1) ?
                    getDefinedColor(FCChartObj.plotgradientcolor,
                        defaultPaletteOptions.plotGradientColor[paletteIndex]) :
                    BLANKSTRING),
                ratio : pluck(dataset.ratio, FCChartObj.plotfillratio),
                fillAangle : fillAangle,
                isRoundEdges : HCObj.chart.useRoundEdges,
                plotBorderColor : pluck(FCChartObj.plotbordercolor, is3d ?
                    COLOR_WHITE : defaultPaletteOptions.plotBorderColor
                    [paletteIndex]).split(COMMASTRING)[0],
                plotBorderAlpha : (FCChartObj.showplotborder == ZEROSTRING  ||
                    (is3d && FCChartObj.showplotborder != ONESTRING)) ?
                    ZEROSTRING : pluck(FCChartObj.plotborderalpha,
                    HUNDREDSTRING),
                isBar : this.isBar,
                is3d : is3d,
                dashed : pluckNumber(dataset.dashed,
                    FCChartObj.plotborderdashed, 0),
                dashLen : pluckNumber(dataset.dashlen,
                    FCChartObj.plotborderdashlen, 5),
                dashGap : pluckNumber(dataset.dashgap,
                    FCChartObj.plotborderdashgap, 4),
                borderWidth : pluck(FCChartObj.plotborderthickness , ONESTRING),
                showValues : pluckNumber(dataset.showvalues, conf.showValues),
                yAxis : seriesYAxis,
                use3DLighting : pluckNumber(FCChartObj.use3dlighting, 1),
                // also sending FusionCharts dataset to pick new attributes if
                // needed in any new chart type.
                _sourceDataset: dataset

            }, this);

            // Iterate through all level data
            // We are managing the data value labels and other
            // cosmetics inside this loop
            for (index = 0; index < catLength; index += 1) {
                // Individual data object
                dataObj = data[index];
                if (dataObj) {
                    // get the valid value
                    itemValue = NumberFormatter.getCleanValue(
                        dataObj.value, isValueAbs);
                    if (itemValue === null) {
                        // add the data
                        series.data.push({
                            y : null
                        });
                        continue;
                    }
                    //set this flag as true
                    hasValidPoint = true;

                    pointObj = dataParser(dataObj, index, itemValue);
                    //push the point object
                    series.data.push(pointObj);

                    // Set the maximum and minimum found in data
                    // pointValueWatcher use to calculate the maximum and
                    // minimum value of the Axis
                    pointObj.previousY = this.pointValueWatcher(HCObj, itemValue, seriesYAxis,
                        isStacked, index, MSStackIndex, seriesType);

                }
                else {
                    // add the data
                    series.data.push({
                        y : null
                    });
                }
            }

            if (!hasValidPoint && !this.realtimeEnabled) {
                series.showInLegend = false;
            }

            return series;
        },
        defaultSeriesType : 'column'
    }, multiSeriesAPI);

    /////////////// msline ///////////
    chartAPI('mslinebase', {
        hasVDivLine : true,
        point: function (chartName, series, dataset, FCChartObj, HCObj, catLength, seriesIndex) {
            var hasValidPoint = false,
                itemValue,
                index,
                dataParser,
                dataObj,
                pointObj,
                HCChartObj = HCObj.chart,
                // Data array in dataset object
                data = dataset.data || [],
                // HighChart configuration object
                conf = HCObj[FC_CONFIG_STRING],
                // take the series type
                seriesType = pluck(series.type, this.defaultSeriesType),
                // Check the chart is a stacked chart or not
                isStacked = pluck(series.isStacked, (HCObj.plotOptions[seriesType] &&
                    HCObj.plotOptions[seriesType].stacking)),
                // 100% stacked chart takes absolute values only
                isValueAbs = pluck(this.isValueAbs, conf.isValueAbs, false),
                seriesYAxis = pluckNumber(series.yAxis, 0),
                NumberFormatter = this.numberFormatter,

                // Line cosmetics attributes
                // Color of the line series
                lineColorDef = getFirstColor(pluck(dataset.color, FCChartObj.linecolor, HCObj.colors[seriesIndex % HCObj.colors.length])),
                // Alpha of the line
                lineAlphaDef = pluck(dataset.alpha, FCChartObj.linealpha, HUNDREDSTRING),
                showShadow = pluckNumber(FCChartObj.showshadow, this.defaultPlotShadow, 1),
                // Managing line series markers
                // Whether to drow the Anchor or not
                drawAnchors = pluckNumber(dataset.drawanchors, dataset.showanchors , FCChartObj.drawanchors, FCChartObj.showanchors),
                // Anchor cosmetics
                // We first look into dataset then chart obj and then default value.
                setAnchorSidesDef = pluckNumber(dataset.anchorsides,
                    FCChartObj.anchorsides, 0),
                setAnchorAngleDef = pluckNumber(dataset.anchorstartangle,
                    FCChartObj.anchorstartangle, 90),
                setAnchorRadiusDef = pluckNumber(dataset.anchorradius,
                    FCChartObj.anchorradius, 3),
                setAnchorBorderColorDef = getFirstColor(pluck(dataset.anchorbordercolor,
                    FCChartObj.anchorbordercolor, lineColorDef)),
                setAnchorBorderThicknessDef = pluckNumber(dataset.anchorborderthickness,
                    FCChartObj.anchorborderthickness, 1),
                setAnchorBgColorDef = getFirstColor(pluck(dataset.anchorbgcolor,
                    FCChartObj.anchorbgcolor, defaultPaletteOptions.anchorBgColor[HCObj.chart.paletteIndex])),
                setAnchorAlphaDef = pluck(dataset.anchoralpha, FCChartObj.anchoralpha,
                    HUNDREDSTRING),
                setAnchorBgAlphaDef = pluck(dataset.anchorbgalpha, FCChartObj.anchorbgalpha,
                    setAnchorAlphaDef);



            // Dataset seriesname
            series.name = getValidValue(dataset.seriesname);
            // If includeInLegend set to false
            // We set series.name blank
            if (pluckNumber(dataset.includeinlegend) === 0 ||
                series.name === undefined || (lineAlphaDef == 0 &&
                    drawAnchors !== 1)) {
                series.showInLegend = false;
            }

            //set the marker attr at series
            series.marker = {
                fillColor: {
                    FCcolor: {
                        color: setAnchorBgColorDef,
                        alpha: ((setAnchorBgAlphaDef * setAnchorAlphaDef) / 100) + BLANKSTRING
                    }
                },
                lineColor: {
                    FCcolor: {
                        color: setAnchorBorderColorDef,
                        alpha: setAnchorAlphaDef + BLANKSTRING
                    }
                },
                lineWidth: setAnchorBorderThicknessDef,
                radius: setAnchorRadiusDef,
                symbol: mapSymbolName(setAnchorSidesDef),
                startAngle: setAnchorAngleDef
            };

            // Set the line color and alpha to
            // HC seris obj with FusionCharts color format using FCcolor obj
            series.color = {
                FCcolor: {
                    color: lineColorDef,
                    alpha: lineAlphaDef
                }
            };
            // For Spline Chart shadow do not works at point label.
            series.shadow = showShadow ? {
                opacity: showShadow ? lineAlphaDef / 100 : 0
            } : false;

            // IF its a step line chart
            series.step = pluck(this.stepLine, series.step);
            // Special attribute for StepLine (drawVerticalJoins)
            series.drawVerticalJoins = Boolean(pluckNumber(series.drawVerticalJoins, FCChartObj.drawverticaljoins, 1));
            series.useForwardSteps = Boolean(pluckNumber(series.useForwardSteps, FCChartObj.useforwardsteps, 1));

            // Set the line thickness (line width)
            series.lineWidth = pluckNumber(dataset.linethickness, FCChartObj.linethickness, 2);


            dataParser = series._dataParser = getDataParser.line(HCObj, {
                seriesname : series.name,
                lineAlpha : lineAlphaDef,
                anchorAlpha : setAnchorAlphaDef,
                showValues : pluckNumber(dataset.showvalues, conf.showValues),
                yAxis : seriesYAxis,
                lineDashed : Boolean(pluckNumber(dataset.dashed, FCChartObj.linedashed, 0)),
                lineDashLen : pluckNumber(dataset.linedashlen, FCChartObj.linedashlen, 5),
                lineDashGap : pluckNumber(dataset.linedashgap, FCChartObj.linedashgap, 4),
                lineThickness : series.lineWidth,
                lineColor : lineColorDef,
                valuePosition : pluck(dataset.valueposition, HCChartObj.valuePosition),
                drawAnchors : drawAnchors,
                anchorBgColor : setAnchorBgColorDef,
                anchorBgAlpha : setAnchorBgAlphaDef,
                anchorBorderColor : setAnchorBorderColorDef,
                anchorBorderThickness : setAnchorBorderThicknessDef,
                anchorRadius : setAnchorRadiusDef,
                anchorSides : setAnchorSidesDef,
                anchorAngle : setAnchorAngleDef,
                // also sending FusionCharts dataset to pick new attributes if
                // needed in any new chart type.
                _sourceDataset: dataset
            }, this);



            // Iterate through all level data
            for (index = 0; index < catLength; index += 1) {
                // Individual data obj
                // for further manipulation
                dataObj = data[index];
                if (dataObj) {
                    itemValue = NumberFormatter.getCleanValue(dataObj.value, isValueAbs);
                    if (itemValue === null) {
                        // add the data
                        series.data.push({
                            y : null
                        });
                        continue;
                    }
                    //set the flag
                    hasValidPoint = true;

                    pointObj = dataParser(dataObj, index, itemValue);
                    //push the point object
                    series.data.push(pointObj);

                    // Set the maximum and minimum found in data
                    // pointValueWatcher use to calculate the maximum and
                    // minimum value of the Axis
                    pointObj.previousY = this.pointValueWatcher(HCObj, itemValue, seriesYAxis,
                        isStacked, index, 0, seriesType);

                }
                else {
                    // add the data
                    series.data.push({
                        y : null
                    });
                }
            }

            if (!hasValidPoint && !this.realtimeEnabled) {
                series.showInLegend = false
            }

            //return series
            return series;
        },
        defaultSeriesType : 'line',
        defaultPlotShadow: 1,
        defaultZeroPlaneHighlighted: false
    }, multiSeriesAPI);

    ////// msarea ////////
    chartAPI('msareabase', {
        hasVDivLine : true,
        point: function (chartName, series, dataset, FCChartObj, HCObj,
                   catLength, seriesIndex) {
            var hasValidPoint = false,
                HCChartObj = HCObj.chart,
                iapi = this,
                // Data array in dataset object
                data = dataset.data || [],
                // HighChart configuration object
                conf = HCObj[FC_CONFIG_STRING],
                // take the series type
                seriesType = pluck(series.type, iapi.defaultSeriesType),
                // Check the chart is a stacked chart or not
                isStacked = pluck(series.isStacked, (HCObj.plotOptions[seriesType] &&
                    HCObj.plotOptions[seriesType].stacking)),
                // 100% stacked chart takes absolute values only
                isValueAbs = pluck(iapi.isValueAbs, conf.isValueAbs, false),
                // Index of the palette to be use for charts palette cosmetics
                paletteIndex = HCObj.chart.paletteIndex,
                // Whether to use yAxis or not
                seriesYAxis = pluckNumber(series.yAxis, 0),
                NumberFormatter = HCObj[FC_CONFIG_STRING].numberFormatter,
                // Area fill color
                seriesFillColor = pluck(dataset.color,
                    FCChartObj.plotfillcolor,
                    HCObj.colors[seriesIndex % HCObj.colors.length])
                    .split(COMMASTRING)[0].replace(/^#?/g, "#")
                    .split(COMMASTRING)[0],
                // Alpha of the area fill
                seriesFillAlpha = pluck(dataset.alpha, FCChartObj.plotfillalpha,
                    FCChartObj.areaalpha, iapi.areaAlpha, 70),
                // Angle of the area fill
                seriesFillAngle = pluckNumber(FCChartObj.plotfillangle, 270),
                // Angle of the fill ratio
                seriesFillRatio = BGRATIOSTRING,
                // Area line cosmetics
                seriesLineColor = pluck(dataset.plotbordercolor,
                    FCChartObj.plotbordercolor, FCChartObj.areabordercolor,
                    iapi.isRadar ? HCObj.colors[seriesIndex %
                        HCObj.colors.length] : '666666').split(COMMASTRING)[0],
                // Area border cosmetics
                // alpha
                seriesLineAlpha = pluck(dataset.showplotborder,
                    FCChartObj.showplotborder) == ZEROSTRING  ? ZEROSTRING :
                    pluck(dataset.plotborderalpha, FCChartObj.plotborderalpha,
                    dataset.alpha, FCChartObj.plotfillalpha,
                    FCChartObj.areaalpha, '95'),
                seriesLineAngle = pluckNumber(FCChartObj.plotborderangle , 270),
                seriesLineRatio = HUNDREDSTRING,
                // Taking default anchor cosmetics form dataset obj or
                // Chart obj or default
                setAnchorSidesDef = pluckNumber(dataset.anchorsides,
                    FCChartObj.anchorsides, 0),
                setAnchorAngleDef = pluckNumber(dataset.anchorstartangle,
                    FCChartObj.anchorstartangle, 90),
                setAnchorRadiusDef = pluckNumber(dataset.anchorradius,
                    FCChartObj.anchorradius, 3),
                setAnchorBorderColorDef = getFirstColor(pluck(
                    dataset.anchorbordercolor,
                    FCChartObj.anchorbordercolor, seriesFillColor)),
                setAnchorBorderThicknessDef = pluckNumber(
                    dataset.anchorborderthickness,
                    FCChartObj.anchorborderthickness, 1),
                setAnchorBgColorDef = getFirstColor(pluck(dataset.anchorbgcolor,
                    FCChartObj.anchorbgcolor,
                    defaultPaletteOptions.anchorBgColor[paletteIndex])),
                setAnchorAlphaDef = pluckNumber(dataset.anchoralpha,
                    FCChartObj.anchoralpha, iapi.anchorAlpha, 0),
                setAnchorBgAlphaDef = pluckNumber(dataset.anchorbgalpha,
                    FCChartObj.anchorbgalpha, setAnchorAlphaDef),
                dataParser,
                itemValue,
                index,
                dataObj,
                pointObj;

            if (!iapi.isRadar) {
                seriesFillColor += COMMASTRING + (pluckNumber(
                    FCChartObj.useplotgradientcolor, 1) ?
                    getDefinedColor(FCChartObj.plotgradientcolor,
                        defaultPaletteOptions.plotGradientColor[paletteIndex]) :
                    BLANKSTRING);
                seriesFillColor = seriesFillColor.replace(/,+?$/,'');
            }

            // IF its a step area chart
            series.step = pluck(iapi.stepLine, series.step);
            // Special attribute for StepLine (drawVerticalJoins)
            series.drawVerticalJoins = Boolean(pluckNumber(series.drawVerticalJoins, FCChartObj.drawverticaljoins, 1));
            series.useForwardSteps = Boolean(pluckNumber(series.useForwardSteps, FCChartObj.useforwardsteps, 1));


            // Dataset seriesname
            series.name = pluck(dataset.seriesname);
            // If includeInLegend set to false
            // We set series.name blank
            if (pluckNumber(dataset.includeinlegend) === 0 ||
                    series.name === undefined) {
                series.showInLegend = false;
            }
            // Set the area fill color and alpha to
            // HC seris obj with FusionCharts color format using FCcolor obj
            series.fillColor = {
                FCcolor: {
                    color: seriesFillColor,
                    alpha: seriesFillAlpha,
                    ratio: seriesFillRatio,
                    angle: seriesFillAngle
                }
            };
            // To set the color of the legend icon, we need to set the
            // series color
            series.color = seriesFillColor;
            // For Spline Chart shadow do not works at point label.
            series.shadow = {
                opacity: pluckNumber(FCChartObj.showshadow, 1) ?
                    (seriesLineAlpha / 100) : 0
            };

            // set the line color and alpha to
            // HC seris obj with FusionCharts color format using FCcolor obj
            series.lineColor = {
                FCcolor: {
                    color: seriesLineColor,
                    alpha: seriesLineAlpha,
                    ratio: seriesLineRatio,
                    angle: seriesLineAngle
                }
            };
            // set the line thickness (line width)
            series.lineWidth = pluck(dataset.plotborderthickness,
                FCChartObj.plotborderthickness, 1);
            // create line dash
            // using dashStyle of HC
            series.dashStyle  = Boolean(pluckNumber(dataset.dashed,
                FCChartObj.plotborderdashed, 0)) ? getDashStyle(
                pluckNumber(dataset.dashlen, FCChartObj.plotborderdashlen, 5),
                pluckNumber(dataset.dashgap, FCChartObj.plotborderdashgap, 4),
                series.lineWidth) : undefined;
            //set the marker attr at series
            series.marker = {
                fillColor: {
                    FCcolor: {
                        color: setAnchorBgColorDef,
                        alpha: ((setAnchorBgAlphaDef * setAnchorAlphaDef) /
                            100) + BLANKSTRING
                    }
                },
                lineColor: {
                    FCcolor: {
                        color: setAnchorBorderColorDef,
                        alpha: setAnchorAlphaDef + BLANKSTRING
                    }
                },
                lineWidth: setAnchorBorderThicknessDef,
                radius: setAnchorRadiusDef,
                symbol: mapSymbolName(setAnchorSidesDef),
                startAngle: setAnchorAngleDef
            };
            dataParser = series._dataParser = getDataParser.area(HCObj, {
                seriesname : series.name,
                lineAlpha : seriesLineAlpha,
                anchorAlpha : setAnchorAlphaDef,
                showValues : pluckNumber(dataset.showvalues, conf.showValues),
                yAxis : seriesYAxis,
                fillColor : seriesFillColor,
                fillAlpha : seriesFillAlpha,
                valuePosition : pluck(dataset.valueposition,
                    HCChartObj.valuePosition),
                drawAnchors : Boolean(pluckNumber(FCChartObj.drawanchors,
                    FCChartObj.showanchors , 1)),
                anchorBgColor : setAnchorBgColorDef,
                anchorBgAlpha : setAnchorBgAlphaDef,
                anchorBorderColor : setAnchorBorderColorDef,
                anchorBorderThickness : setAnchorBorderThicknessDef,
                anchorRadius : setAnchorRadiusDef,
                anchorSides : setAnchorSidesDef,
                anchorAngle : setAnchorAngleDef,
                getLink : iapi.linkClickFN,
                // also sending FusionCharts dataset to pick new attributes if
                // needed in any new chart type.
                _sourceDataset: dataset

            }, this);

            // Iterate through all level data
            for (index = 0; index < catLength; index += 1) {
                // individual data obj
                // for further manipulation
                dataObj = data[index];
                if (dataObj) {
                    // get the valid value
                    // parsePointValue check the its a value value of not
                    // and return the valid value
                    itemValue = dataObj ? NumberFormatter.getCleanValue(
                        dataObj.value, isValueAbs) : null;
                    if (itemValue === null) {
                        // add the data
                        series.data.push({
                            y : null
                        });
                        continue;
                    }

                    hasValidPoint = true;

                    pointObj = dataParser(dataObj, index, itemValue);
                    //push the point object
                    series.data.push(pointObj);


                    // Set the maximum and minimum found in data
                    // pointValueWatcher use to calculate the maximum and
                    // minimum value of the Axis
                    pointObj.previousY = iapi.pointValueWatcher(HCObj, itemValue, seriesYAxis,
                        isStacked, index, 0, seriesType);
                }
                else {
                    // add the data
                    series.data.push({
                        y : null
                    });
                }
            }

            if (!hasValidPoint && !iapi.realtimeEnabled) {
                series.showInLegend = false
            }
            return series;
        },
        defaultSeriesType : 'area',
        defaultPlotShadow: 0
    }, multiSeriesAPI);

    //////scatter base ////////
    chartAPI('scatterbase', {
        showValues : 0,
        defaultPlotShadow: 0,
        rendererId: 'cartesian',
        defaultSeriesType: 'scatter',
        point: function (chartName, series, dataset, FCChartObj, HCObj, catLength, seriesIndex) {
            if (dataset.data) {
                var itemValueY, index, scatterBorderColor, scatterAlpha, lineThickness, lineDashed,
                lineDashLen, lineDashGap, drawAnchors, dataLabel, dataObj, pointShadow,
                seriesAnchorSides, seriesAnchorRadius, seriesAnchorBorderColor,
                seriesAnchorBorderThickness, seriesAnchorBgColor, seriesAnchorAlpha,
                seriesAnchorBgAlpha, setAnchorSides, setAnchorRadius, setAnchorBorderColor,
                setAnchorBorderThickness, setAnchorBgColor, setAnchorAlpha, setAnchorBgAlpha,
                itemValueX, hasValidPoint = false, seriesAnchorAngle,
                pointStub, chartNameAPI = this,
                // Whether to draw scatter line
                drawLine = pluckNumber(dataset.drawline, FCChartObj.drawlines, 0),
                drawProgressionCurve = pluckNumber(dataset.drawprogressioncurve, 0),
                conf = HCObj[FC_CONFIG_STRING],
                // Data array in dataset object
                data = dataset.data,
                regressionData,
                dataLength = data.length,
                // showValues attribute in individual dataset
                datasetShowValues = pluckNumber(dataset.showvalues, conf.showValues),
                NumberFormatter = this.numberFormatter,

                //Regratation line
                showRegressionLine = pluckNumber(dataset.showregressionline,
                    FCChartObj.showregressionline, 0);

                //add z index so that the regration line set at the back of the series
                series.zIndex = 1;

                // Dataset seriesname
                series.name = getValidValue(dataset.seriesname);
                // If showInLegend set to false
                // We set series.name blank
                if (pluckNumber(dataset.includeinlegend) === 0 || series.name === undefined) {
                    series.showInLegend = false;
                }

                if (drawLine || drawProgressionCurve) {
                    

                    // Line cosmetics attributes
                    // Color of the line series
                    scatterBorderColor = getFirstColor(pluck(dataset.color,
                        HCObj.colors[seriesIndex % HCObj.colors.length]));
                    // Alpha of the line
                    scatterAlpha = pluck(dataset.alpha, HUNDREDSTRING);
                    // Line Thickness
                    lineThickness = pluckNumber(dataset.linethickness,
                        FCChartObj.linethickness, 2);
                    // Whether to use dashline
                    lineDashed = Boolean(pluckNumber(dataset.linedashed,
                        dataset.dashed, FCChartObj.linedashed, 0));

                    // line dash attrs
                    lineDashLen = pluckNumber(dataset.linedashlen,
                        FCChartObj.linedashlen, 5);
                    lineDashGap = pluckNumber(dataset.linedashgap,
                        FCChartObj.linedashgap, 4);

                    // Set the line color and alpha to
                    // HC seris obj with FusionCharts color format using FCcolor obj
                    series.color = convertColor(pluck(dataset.linecolor,
                        FCChartObj.linecolor, scatterBorderColor),
                        pluckNumber(dataset.linealpha, FCChartObj.linealpha,
                        scatterAlpha));

                    // Set the line thickness (line width)
                    series.lineWidth = lineThickness;
                    // Create line dash
                    // Using dashStyle of HC
                    series.dashStyle = lineDashed ? getDashStyle(lineDashLen,
                        lineDashGap, lineThickness) : undefined;
                }

                // Managing line series markers
                // Whether to drow the Anchor or not
                drawAnchors = Boolean(pluckNumber(dataset.drawanchors, dataset.showanchors,
                    FCChartObj.drawanchors, FCChartObj.showanchors, 1));

                // Anchor cosmetics
                // We first look into dataset then chart obj and then default value.
                seriesAnchorSides = pluckNumber(dataset.anchorsides,
                    FCChartObj.anchorsides, seriesIndex + 3);
                seriesAnchorRadius = pluckNumber(dataset.anchorradius,
                    FCChartObj.anchorradius, 3);
                seriesAnchorBorderColor = getFirstColor(pluck(dataset.anchorbordercolor, dataset.color,
                    FCChartObj.anchorbordercolor, scatterBorderColor, HCObj.colors[seriesIndex % HCObj.colors.length]));
                seriesAnchorBorderThickness = pluckNumber(dataset.anchorborderthickness,
                    FCChartObj.anchorborderthickness, 1);
                seriesAnchorBgColor = getFirstColor(pluck(dataset.anchorbgcolor,
                    FCChartObj.anchorbgcolor, defaultPaletteOptions.anchorBgColor[HCObj.chart.paletteIndex]));
                seriesAnchorAlpha = pluck(dataset.anchoralpha, dataset.alpha, FCChartObj.anchoralpha,
                    HUNDREDSTRING);
                seriesAnchorBgAlpha = pluck(dataset.anchorbgalpha, dataset.alpha, FCChartObj.anchorbgalpha,
                    seriesAnchorAlpha);
                seriesAnchorAngle = pluck(dataset.anchorstartangle, FCChartObj.anchorstartangle, 90);


                //set the marker attr at series
                series.marker = {
                    fillColor: this.getPointColor(seriesAnchorBgColor, HUNDREDSTRING),
                    lineColor: {
                        FCcolor: {
                            color: seriesAnchorBorderColor,
                            alpha: seriesAnchorAlpha + BLANKSTRING
                        }
                    },
                    lineWidth: seriesAnchorBorderThickness,
                    radius: seriesAnchorRadius,
                    symbol: mapSymbolName(seriesAnchorSides)
                };

                if (showRegressionLine) {
                    series.events = {
                        hide : this.hideRLine,
                        show : this.showRLine
                    };
                    //regration object used in XY chart
                    //create here to avoid checking always
                    var regressionObj = {
                        sumX : 0,
                        sumY : 0,
                        sumXY : 0,
                        sumXsqure : 0,
                        sumYsqure : 0,
                        xValues : [],
                        yValues : []
                    }, regSeries,
                    showYOnX = pluckNumber(dataset.showyonx, FCChartObj.showyonx, 1),
                    regressionLineColor = getFirstColor(pluck(dataset.regressionlinecolor,
                        FCChartObj.regressionlinecolor, seriesAnchorBorderColor)),
                    regressionLineThickness = pluckNumber(dataset.regressionlinethickness,
                        FCChartObj.regressionlinethickness, seriesAnchorBorderThickness),
                    regressionLineAlpha = getFirstAlpha(pluckNumber(dataset.regressionlinealpha,
                        FCChartObj.regressionlinealpha, seriesAnchorAlpha)),
                    regLineColor = convertColor(regressionLineColor, regressionLineAlpha);
                }

                // Iterate through all level data
                for (index = 0; index < dataLength; index += 1) {
                    // Individual data obj
                    // for further manipulation
                    dataObj = data[index];
                    if (dataObj) {
                        itemValueY = NumberFormatter.getCleanValue(dataObj.y);
                        itemValueX = NumberFormatter.getCleanValue(dataObj.x);

                        if (itemValueY === null) {
                            series.data.push({
                                y: null,
                                x: itemValueX
                            });
                            continue;
                        }

                        hasValidPoint = true;

                        pointStub = chartNameAPI
                        .getPointStub(dataObj, itemValueY, NumberFormatter.xAxis(itemValueX), HCObj, dataset, datasetShowValues);


                        // Anchor cosmetics
                        // We first look into dataset then chart obj and then default value.
                        setAnchorSides = pluckNumber(dataObj.anchorsides, seriesAnchorSides);
                        setAnchorRadius = pluckNumber(dataObj.anchorradius, seriesAnchorRadius);
                        setAnchorBorderColor = getFirstColor(pluck(dataObj.anchorbordercolor, seriesAnchorBorderColor));
                        setAnchorBorderThickness = pluckNumber(dataObj.anchorborderthickness, seriesAnchorBorderThickness);
                        setAnchorBgColor = getFirstColor(pluck(dataObj.anchorbgcolor, seriesAnchorBgColor));
                        setAnchorAlpha = pluck(dataObj.anchoralpha, dataObj.alpha, seriesAnchorAlpha);
                        setAnchorBgAlpha = pluck(dataObj.anchorbgalpha, seriesAnchorBgAlpha);

                        // Finally add the data
                        // we call getPointStub function that manage displayValue, toolText and link
                        series.data.push({
                            y: itemValueY,
                            x: itemValueX,
                            displayValue : pointStub.displayValue,
                            toolText : pointStub.toolText,
                            link: pointStub.link,
                            marker: {
                                enabled: drawAnchors,
                                fillColor: {
                                    FCcolor: {
                                        color: setAnchorBgColor,
                                        alpha: ((setAnchorBgAlpha * setAnchorAlpha) / 100) + BLANKSTRING
                                    }
                                },
                                lineColor: {
                                    FCcolor: {
                                        color: setAnchorBorderColor,
                                        alpha: setAnchorAlpha
                                    }
                                },
                                lineWidth: setAnchorBorderThickness,
                                radius: setAnchorRadius,
                                symbol: mapSymbolName(setAnchorSides),
                                startAngle: pluck(dataObj.anchorstartangle, 90)
                            }
                        });

                        // Set the maximum and minimum found in data
                        // pointValueWatcher use to calculate the maximum and minimum value of the Axis
                        this.pointValueWatcher(HCObj, itemValueY, itemValueX, showRegressionLine && regressionObj);
                    }
                    else {
                        // add the data
                        series.data.push({
                            y : null
                        });
                    }
                }

                if (showRegressionLine) {
                    regressionData = this.getRegressionLineSeries(regressionObj,
                        showYOnX, dataLength);

                    this.pointValueWatcher(HCObj, regressionData[0].y,
                        regressionData[0].x);
                    this.pointValueWatcher(HCObj, regressionData[1].y,
                        regressionData[1].x);

                    regSeries = {
                        type : 'line',
                        color : regLineColor,
                        showInLegend: false,
                        lineWidth : regressionLineThickness,
                        enableMouseTracking : false,
                        marker : {
                            enabled : false
                        },
                        data: regressionData,
                        zIndex : 0
                    };
                    series = [series, regSeries];
                }
            }
            // If all the values in current dataset is null
            // we will not show its legend
            if (!hasValidPoint) {
                series.showInLegend = false;
            }
            return series;
        },

        categoryAdder : function(FCObj, HCObj) {
            var index, countCat = 0, fontSize, conf = HCObj[FC_CONFIG_STRING],
            xAxisConf = conf.x, catXValue,
            xAxisObj = HCObj.xAxis, dataLabel, categories,
            FCchartObj = FCObj.chart,
            labelStep = parseInt(FCchartObj.labelstep, 10),
            showLabels = pluckNumber(FCchartObj.showlabels, 1),
            xAxisLabelMode = pluck(FCchartObj.xaxislabelmode, 'categories').toLowerCase(),
            NumberFormatter = HCObj[FC_CONFIG_STRING].numberFormatter;

            // NOTE: adding isXYPlot as the placeHorizontalAxis function needs this info.
            HCObj._FCconf.isXYPlot = true;

            labelStep = labelStep > 1 ? labelStep : 1;
            //track category occupied values
            //so that auto values will not work for that value
            xAxisConf.catOccupied = {};

            if (xAxisLabelMode !== 'auto' && FCObj.categories && FCObj.categories[0] && FCObj.categories[0].category) {
                categories = FCObj.categories[0];
                //update the font relate attr in HC cat
                if (categories.font) {
                    HCObj.xAxis.labels.style.fontFamily  = categories.font;
                }
                if ((fontSize = pluckNumber(categories.fontsize)) !== undefined) {
                    if (fontSize < 1) {
                        fontSize = 1;
                    }
                    HCObj.xAxis.labels.style.fontSize  = fontSize + PXSTRING;
                    setLineHeight(HCObj.xAxis.labels.style);
                }

                if (categories.fontcolor) {
                    HCObj.xAxis.labels.style.color  = categories.fontcolor.
                    split(COMMASTRING)[0].replace(/^\#?/, "#");
                }
                var verticalLineColor = pluck(categories.verticallinecolor ,
                    defaultPaletteOptions.divLineColor[HCObj.chart.paletteIndex]),
                verticalLineThickness = pluckNumber(categories.verticallinethickness, 1),
                verticalLineAlpha = pluckNumber(categories.verticallinealpha,
                    defaultPaletteOptions.divLineAlpha[HCObj.chart.paletteIndex]),
                verticalLineDashed = pluckNumber(categories.verticallinedashed, 0),
                verticalLineDashLen = pluckNumber(categories.verticallinedashlen, 4),
                verticalLineDashGap = pluckNumber(categories.verticallinedashgap, 2),
                verticalLineColorRGB = convertColor(verticalLineColor, verticalLineAlpha),
                category,
                catShowVerticalLine,
                catLineDashed,
                catShowLabel;



                for (index = 0; index < categories.category.length; index += 1) {
                    category = categories.category[index];
                    catXValue = NumberFormatter.getCleanValue(category.x);
                    if (catXValue !== null && !category.vline) {
                        //store the cat occupied values
                        xAxisConf.catOccupied[catXValue] = true;

                        catShowLabel = pluckNumber(category.showlabel, category.showname,
                            showLabels);
                        catShowVerticalLine = pluckNumber(category.showverticalline, category.showline, category.sl, 0);
                        catLineDashed = pluckNumber(category.linedashed, verticalLineDashed);
                        dataLabel = (catShowLabel === 0 || countCat % labelStep !== 0) ? BLANKSTRING : parseUnsafeString(getFirstValue(category.label,
                            category.name));
                        xAxisObj.plotLines.push({
                            isGrid : true,
                            isCat : true,
                            width: catShowVerticalLine ? verticalLineThickness : 0,
                            color  : verticalLineColorRGB,
                            dashStyle  : getDashStyle(verticalLineDashLen, verticalLineDashGap, verticalLineThickness, catLineDashed),
                            value: catXValue,
                            label : {
                                text : dataLabel,
                                style : xAxisObj.labels.style,
                                align: POSITION_CENTER,
                                verticalAlign: POSITION_BOTTOM,
                                textAlign: POSITION_CENTER,
                                rotation : 0,
                                x : 0,
                                y : 0
                            }
                        });

                        //watch the value for min max of x
                        this.pointValueWatcher(HCObj, null, catXValue);
                        countCat += 1;
                    }
                }
                //if it is in mix mode then set the flag for requiredAutoNumericLabels
                if (xAxisLabelMode === 'mixed') {
                    // Fix for hide the min and max for the xAxis of the CandleStick Chart
                    xAxisConf.requiredAutoNumericLabels = pluckNumber(this.requiredAutoNumericLabels, 1);
                }
            }
            else {
                // Fix for hide the min and max for the xAxis of the CandleStick Chart
                xAxisConf.requiredAutoNumericLabels = pluckNumber(this.requiredAutoNumericLabels, 1);
            }
            xAxisConf.adjustMinMax = true;
        },

        // Function that produce the point color
        getPointColor : function (color, alpha) {
            var colorObj, innerColor, outerColor;
            color = getFirstColor(color);
            alpha = getFirstAlpha(alpha);
            innerColor = getLightColor(color, 70);
            outerColor = getDarkColor(color, 50);
            colorObj = {
                FCcolor : {
                    gradientUnits : 'objectBoundingBox',
                    cx: 0.4,
                    cy: 0.4,
                    r: '100%',
                    color :  innerColor + COMMASTRING + outerColor,
                    alpha : alpha + COMMASTRING + alpha,
                    ratio : BGRATIOSTRING,
                    radialGradient : true
                }
            };

            return colorObj;
        }
    }, chartAPI.xybase);

    /////// mscombi2d ///////
    chartAPI('mscombibase', {
        series : function (FCObj, HCObj, chartName) {
            var seriesIndex, length, dataset, catLength, FCChartObj = FCObj.chart,
            series, lineArr = [], columnArr = [], areaArr = [],
            isSY, renderAs,
            conf = HCObj[FC_CONFIG_STRING],
            isDual = this.isDual,
            columnPosition = 0,
            i,
            ln;

            //enable the legend
            HCObj.legend.enabled = Boolean(pluckNumber(FCObj.chart.showlegend, 1));

            if (FCObj.dataset && FCObj.dataset.length > 0) {
                // add category
                this.categoryAdder(FCObj, HCObj);
                catLength = conf.oriCatTmp.length;
                //add data series
                for (seriesIndex = 0, length = FCObj.dataset.length;
                seriesIndex < length; seriesIndex += 1) {
                    dataset = FCObj.dataset[seriesIndex];
                    isSY = isDual && pluck(dataset.parentyaxis, 'p')
                        .toLowerCase() === 's' ? true : false;
                    series = {
                        visible: !!pluckNumber(dataset.visible, 1),
                        legendIndex: seriesIndex,
                        data : []
                    };
                    if (isSY) {
                        series.yAxis = 1;
                        renderAs = getFirstValue(dataset.renderas,
                            this.secondarySeriesType);
                    }
                    else {
                        renderAs = getFirstValue(dataset.renderas,
                            this.defaultSeriesType);
                    }
                    renderAs = renderAs.toLowerCase();

                    switch(renderAs){
                        case 'line':
                        case 'spline':
                            series.type = 'line';
                            lineArr.push(chartAPI.mslinebase.point.call(this,
                                chartName, series, dataset,
                                FCChartObj, HCObj, catLength, seriesIndex));
                            break;
                        case 'area':
                        case 'splinearea':
                            series.type = 'area';
                            //if there has any area chart then set series2D3Dshift as true
                            HCObj.chart.series2D3Dshift = true;
                            areaArr.push(chartAPI.msareabase.point.call(this,
                                chartName, series, dataset,
                                FCChartObj, HCObj, catLength, seriesIndex));
                            break;
                        case 'column':
                        case 'column3d':
                            columnArr.push(chartAPI.mscolumn2dbase.point.call(this,
                                chartName, series, FCObj.dataset[seriesIndex],
                                FCChartObj, HCObj, catLength, seriesIndex,
                                undefined, columnPosition));
                            columnPosition += 1;
                            break;
                        default:
                            if (isSY) {
                                series.type = 'line';
                                lineArr.push(chartAPI.mslinebase.point.call(this,
                                    chartName, series, dataset,
                                    FCChartObj, HCObj, catLength, seriesIndex));
                            }
                            else {
                                columnArr.push(chartAPI.mscolumn2dbase.point.call(this,
                                    chartName, series, FCObj.dataset[seriesIndex],
                                    FCChartObj, HCObj, catLength, seriesIndex,
                                    undefined, columnPosition));
                                columnPosition += 1;
                            }
                    }
                }

                //push the data at the series array
                

                if (FCChartObj.areaovercolumns !== '0') {
                    HCObj.chart.areaOverColumns = true;
                    HCObj.series = HCObj.series.concat(columnArr, areaArr, lineArr);
                }
                else {
                    HCObj.chart.areaOverColumns = false;
                    HCObj.series = HCObj.series.concat(areaArr, columnArr, lineArr);
                }
                if (columnArr.length === 0) {
                    conf.hasNoColumn = true;
                }
                else if(!this.isStacked){
                    //add column count
                    for (i = 0, ln = columnArr.length;i < ln; i += 1 ) {
                        columnArr[i].numColumns = ln;
                    }
                }
                ///configure the axis
                this.configureAxis(HCObj, FCObj);
                ///////////Trend-lines /////////////////
                if (FCObj.trendlines) {
                    createTrendLine (FCObj.trendlines, HCObj.yAxis, HCObj[FC_CONFIG_STRING], isDual, this.isBar);
                }
            }
        }
    }, chartAPI.mscolumn2dbase);

}]);
/*jslint forin: true, regexp: true, todo: true, white: false, browser: true,
    sloppy: true, white: true */
/*global window: true, FusionCharts */

/**
 * Red Raphael JavaScript Library
 * ------------------------------
 * Base common renderer taht consumes Raphael for rendering the
 * visualization logic.
 */

FusionCharts(['private', 'modules.renderer.js-renderer', function () {

    var global = this,
        lib = global.hcLib,
        R = lib.Raphael,
        renderer = lib.chartAPI,
        rendererRoot,

        userAgent = navigator.userAgent,
        win = window,
        isIE = /msie/i.test(userAgent) && !win.opera,
        doc = document,
        isVML = (R.type === 'VML'),
        BLANK = lib.BLANKSTRING,
        COMMA = ",",
        HYPHEN = "-",
        COLON = ":",
        PNG = "png",
        SVG = "svg",
        PDF = "pdf",
        INPUT = "input",
        FORM = "form",
        DOWNLOAD = "download",
        HIDDEN = "hidden",
        POST = "POST",
        CRISP = "crisp",
        TRACKER_FILL = 'rgba(192,192,192,'+ (isIE ? 0.002 : 0.000001) +')', // invisible but clickable,
        TOUCH_THRESHOLD_PIXELS = 10,
        CLICK_THRESHOLD_PIXELS = 3,
        NONE = 'none',
        DRAGSTART = 'dragstart',
        DRAG = 'drag',
        DRAGEND = 'dragend',
        mathRound = Math.round,
        stubFN = lib.stubFN,
        stubEvent = {
            pageX: 0,
            pageY: 0
        },
        toFloat = parseFloat,
        toInt = parseInt,
        extend2 = lib.extend2,
        addEvent = lib.addEvent,
        removeEvent = lib.removeEvent,
        pluck = lib.pluck,
        pluckNumber = lib.pluckNumber,
        hex2rgb = lib.graphics.HEXtoRGB,
        setImageDisplayMode = lib.setImageDisplayMode,
        falseFN = lib.falseFN,
        CONFIGKEY = lib.FC_CONFIG_STRING,
        xAttrRegx = /\s\bx\b=['"][^'"]+?['"]/ig,
        yAttrRegx = /\s\by\b=['"][^'"]+?['"]/ig,
        /**
        * Check whether an object is Array or not
        * @type Boolean
        * @param {object} subject is the variable that is
        * tested for Array identity check
        */
        isArray = lib.isArray = (function () {
            // Use compiler's own isArray when available
            if (Array.isArray) {
                return Array.isArray;
            }

            // Retain references to variables for performance
            // optimization
            var objectToStringFn = Object.prototype.toString,
            arrayToStringResult = objectToStringFn.call([]);

            return function (subject) {
                return objectToStringFn.call(subject) === arrayToStringResult;
            };
        }()),

        each = lib.each = function(obj, fn, scope, data) {
            var i;

            if (!scope) {
                scope = obj;
            }

            if (!data) {
                data = {};
            }

            if (isArray(obj)) {
                for (i = 0; i < obj.length; i += 1) {
                    if (fn.call(scope, obj[i], i, obj, data) === false) {
                        return i;
                    }
                }
            }
            else if (!(obj === null || obj === undefined)) {
                for (i in obj) {
                    if (fn.call(scope, obj[i], i, obj, data) === false) {
                        return i;
                    }
                }
            }
        },

        createElement = lib.createElement,
        createContextMenu = lib.createContextMenu,

        toRaphaelColor = lib.toRaphaelColor = (function () {
            var cache = {};

            return function (obj) {
                obj = obj || this;
                var o = obj && obj.FCcolor || obj,
                colors = o.color,
                ratio = o.ratio,
                angle = o.angle,
                opacities = o.alpha,
                r = o.r,
                cx = o.cx,
                cy = o.cy,
                fx = o.fx,
                fy = o.fy,
                units = o.gradientUnits,
                x1 = o.x1,
                y1 = o.y1,
                x2 = o.x2,
                y2 = o.y2,
                opacity = 1,
                str,
                i,
                l,
                color,
                hash;

                if (typeof obj === 'string') {
                    return cache[(hash = '~' + obj)] ||
                        (cache[hash] = obj.replace(/^#?([a-f0-9]{3,6})/ig, '#$1'));
                }

                colors = colors || BLANK;

                if (!colors) {
                    return str;
                }

                hash = [colors,opacities,ratio,angle,r,cx,cy,units,fx,fy,x1,x2,y1,y2]
                .join('_').replace(/[\(\)\s,\xb0#]/g, "_");
                if (cache[hash]) {
                    return cache[hash];
                }

                ratio = ratio && (ratio+BLANK).split(COMMA) || [];
                opacities = (opacities || opacities === 0) &&
                (opacities+BLANK).split(COMMA) || [];

                if((colors = colors.split(COMMA))) {
                    str = BLANK;
                    if (colors.length === 1) {
                        color = colors[0].replace(/^#?([a-f0-9]{3,6})/ig, '$1');
                        if (opacities.length) {
                            str = 'rgba(' + hex2rgb(color).join(COMMA) + ',' +
                            toFloat(opacities[0]) * 0.01 + ')';
                        }
                        else {
                            str = color.replace(/^#?([a-f0-9]{3,6})/ig, '#$1');
                        }
                    }
                    else {
                        for (i = 0, l = colors.length; i < l; i++) {
                            color = colors[i].replace(/^#?([a-f0-9]{3,6})/ig, '$1');
                            if (!isNaN(ratio[i])) {
                                ratio[i] = toFloat(ratio[i]);
                                color += COLON + ratio[i];
                                if (!isNaN(ratio[i + 1])) {
                                    ratio[i + 1] = toFloat(ratio[i + 1]) + ratio[i];
                                }
                            }
                            if (!isNaN(opacities[i]) && opacities[i] !== BLANK) {
                                opacity = opacities[i] * 0.01;
                            }
                            colors[i] = 'rgba(' + hex2rgb(color).join(COMMA) + ',' +
                            opacity + ')';
                            if (!isNaN(ratio[i])) {
                                colors[i] = colors[i] + COLON + ratio[i];
                            }
                        }
                        str += colors.join(HYPHEN);

                        if (r !== undefined || fx !== undefined || cx !== undefined || o.radialGradient) {
                            str = "xr(" +
                            [fx, fy, r, cx, cy, units].join(',') + ")" + str;
                        }
                        else {
                            str = HYPHEN + str;
                            if (x1 !== undefined || y1 !== undefined || x2 !== undefined || y2 !== undefined) {
                                str = "(" + [x1, y1, x2, y2, units].join(',') + ")" + str;
                            }
                            if (angle === undefined) {
                                angle = 0;
                            }
                            str = (360 - toFloat(angle) % 360) + str;
                        }
                    }
                }
                return cache[hash] = str;
            };
        }()),

        gradientify = lib.gradientify = (function () {
            return function (colors, opacities, ratios, angles, cx, cy, r) {
                var attr = '',
                args = arguments,
                isRadial = (arguments.length > 4),

                color,
                opacity,
                ratio;


                return attr;
            };

        }()),

        hasTouch = lib.hasTouch,
        // hot/tracker threshold in pixels
        HTP = hasTouch ? TOUCH_THRESHOLD_PIXELS :
                CLICK_THRESHOLD_PIXELS,

        getSentenceCase = lib.getSentenceCase,
        getCrispValues = lib.getCrispValues,
        DRAW_TRACKER = 'drawTracker',
        //add the tools thats are requared
        getValidValue = lib.getValidValue,
        pluckNumber = lib.pluckNumber,
        getFirstValue = lib.getFirstValue,
        hasSVG = lib.hasSVG,
        dropHash = lib.regex.dropHash,
        HASHSTRING = lib.HASHSTRING,
        extend = function(a, b) {
            var n;
            if (!a) {
                a = {};
            }
            for (n in b) {
                a[n] = b[n];
            }
            return a;
        },
        defined = function(obj) {
            return obj !== UNDEFINED && obj !== null;
        },
        pInt = function(s, mag) {
            return parseInt(s, mag || 10);
        },
        isObject = function(obj) {
            return typeof obj === 'object';
        },
        isString = function(s) {
            return typeof s === 'string';
        },
        getCrispPath = function(path, width) {
            if (path[1] === path[4]) {
                path[1] = path[4] = mathRound(path[1]) + (width % 2 / 2);
            }
            if (path[2] === path[5]) {
                path[2] = path[5] = mathRound(path[2]) + (width % 2 / 2);
            }
            return path;
        },
        docMode8 = document.documentMode === 8,
        UNDEFINED,
        VISIBLE = docMode8 ? 'visible' : '',
        CRISP = 'crisp',
        M = 'M',
        L = 'L',
        V = 'V',
        H = 'H',
        Z = "Z",
        math = Math,
        mathSin = math.sin,
        mathCos = math.cos,
        mathATan2 = math.atan2,
        mathRound = math.round,
        mathMin = math.min,
        mathMax = math.max,
        mathAbs = math.abs,
        mathPI = math.PI,
        mathCeil = math.ceil,
        mathFloor = math.floor,
        mathSqrt = math.sqrt,
        mathLog = math.log,
        mathPow = math.pow,
        deg2rad = mathPI / 180,
        rad2deg = 180 / mathPI,
        pi = math.PI,
        piBy2 = pi / 2,
        pi2 = 2 * pi,
        pi3By2 = pi + piBy2,
        pi4 = 4 * pi,
        getFirstColor = lib.getFirstColor,
        getDarkColor = lib.graphics.getDarkColor,
        getLightColor = lib.graphics.getLightColor,
        COLOR_TRANSPARENT = lib.COLOR_TRANSPARENT,
        TRACKER_FILL = 'rgba(192,192,192,'+ (isIE ? 0.002 : 0.000001) +')',
        POSITION_CENTER = lib.POSITION_CENTER,
        POSITION_TOP = lib.POSITION_TOP,
        POSITION_BOTTOM = lib.POSITION_BOTTOM,
        POSITION_RIGHT = lib.POSITION_RIGHT,
        POSITION_LEFT = lib.POSITION_LEFT,
        POSITION_MIDDLE = 'middle',
        POSITION_START = 'start',
        POSITION_END = 'end',
        MAX_MITER_LINEJOIN = 2,
        GUTTER_4 = 4,
        GUTTER_2 = 2,
        t = 't',
        r = 'r';

    // Custom attribute to mark an element as tracker equivalent.
    R.ca.ishot = function (val) {
        if (this.removed) {
            return false;
        }
        var o = this,
            node = o.node,
            val = val || "",
            child;

        node.ishot = val;
        switch (o.type) {
            case "group":
                child = o.bottom;
                while (child) {
                    child.attr('ishot', val);
                    child = child.next;
                }
            break;
            case "text":
                if (R.svg) {
                    child = node.getElementsByTagName("tspan")[0];
                    while(child) {
                        child.ishot = val;
                        child = child.nextSibling;
                    }
                }
        }
        return false;
    };

    // Add custom symbol to Raphael
    R.addSymbol({
        printIcon: function(x, y, radius) {
            var r1 = radius * 0.75,
                r2 = radius * 0.5,
                r3 = radius * 0.33,
                x1 = mathRound(x - radius) + 0.5,
                y1 = mathRound(y - radius) + 0.5,
                x2 = mathRound(x + radius) + 0.5,
                y2 = mathRound(y + radius) + 0.5,
                x3 = mathRound(x - r1) + 0.5,
                y3 = mathRound(y - r1) + 0.5,
                x4 = mathRound(x + r1) + 0.5,
                y4 = mathRound(y + r2) + 0.5,
                x5 = mathRound(x + r2) + 0.5,
                y5 = mathRound(y + r3) + 0.5,
                x6 = mathRound(x - r2) + 0.5,
                y6 = mathRound(y + r3 + r3) + 0.5;
            return [
                M, // the upper sheet
                x3, y1,
                L,
                x4, y1,
                x4, y3,
                x3, y3,
                'Z',
                M, // the printer
                x1, y3,
                L,
                x1, y4,
                x3, y4,
                x3, y,
                x4, y,
                x4, y4,
                x2, y4,
                x2, y3,
                'Z',
                M, // the lower sheet
                x3, y,
                L,
                x3, y2,
                x4, y2,
                x4, y,
                'Z',
                M,//lower lines
                x5, y5,
                L,
                x6, y5,
                M,
                x5, y6,
                L,
                x6, y6
            ];
        },
        exportIcon: function(x, y, radius) {
        var r1 = radius * 0.66,
            r2 = r1 * 0.5,
        x1 = mathRound(x - radius) + 0.5,
                y1 = mathRound(y - radius) + 0.5,
                x2 = mathRound(x + radius) + 0.5,
                y2 = mathRound(y + radius) - 0.5,
                x3 = mathRound(x - r2) + 0.5,
                y3 = y < y2 - 3 ? y2 - 3 : mathRound(y) + 0.5,
                x4 = mathRound(x + r2) - 0.5,
                x5 = mathRound(x + r1) - 0.5,
                x6 = mathRound(x - r1) + 0.5;
            return [
                M, // the disk
                x1, y3,
                L,
                x1, y2,
                x2, y2,
                x2, y3,
                x2, y2,
                x1, y2,
                'Z',
                M, // the arrow
                x, y2 - 1,
                L,
                x6, y,
                x3, y,
                x3, y1,
                x4, y1,
                x4, y,
                x5, y,
                'Z'
            ];
        }

    });


    rendererRoot = lib.rendererRoot = renderer('renderer.root', {
        standaloneInit: false, // prevent being used as visualization logic
        isRenderer: true, // flag as compatible to be used as renderer

        inited: false,

        callbacks: [],

        init: function (logic, options, callback) {
            var chart = this,
                container = chart.container = options.chart.renderTo,
                tooltip = options.tooltip,
                paper,
                layers = chart.layer;

            chart.options = options;
            chart.logic = logic;
            chart.definition = logic.dataObj;
            chart.smartLabel = logic.smartLabel;
            chart.numberFormatter = logic.numberFormatter;
            chart.fusionCharts = logic.chartInstance;
            chart.linkClickFN = logic.linkClickFN;

            // Clear the container so that it only contains the SVG element
            container.innerHTML = BLANK;
            paper = chart.paper = R(container,
                container.offsetWidth || logic.width,
                container.offsetHeight || logic.height);

            chart.chartWidth = paper.width;
            chart.chartHeight = paper.height;

            if (!chart.elements) {
                chart.elements = {};
            }
            if (!layers) {
                layers = chart.layers = {};
                layers.background = layers.background || paper.group('background');
                layers.dataset = layers.dataset || paper.group('dataset')
                                               .insertAfter(layers.background);
                layers.tracker = layers.tracker || paper.group('hot')
                                               .insertAfter(layers.dataset);
            }

            // set tooltip configurations
            if (tooltip && (tooltip.enabled !== false)) {
                paper.tooltip(tooltip.style, tooltip.shadow, tooltip.constrain);
            }

            chart.setMargins();
            chart.drawBackground();

            // add Buttons
            chart.drawButtons();

            chart.drawGraph();

             //draw the Legend
            if (options.legend && options.legend.enabled) {
                chart.drawLegend();
            }

            chart.drawCaption();
            chart.drawLogo();

            // set clickURL and other events that happen globally.
            chart.setChartEvents();

            chart.drawLabels && chart.drawLabels();

            each(options.callbacks, function(fn) {
                fn.apply(chart, this);
            }, [logic]);

            each(chart.callbacks, function(fn) {
                fn.apply(chart, this);
            }, [logic]);

            chart.hasRendered = true;
            callback && callback(chart);
        },

        reinit: function (logic, options, callback) {
            var chart = this;

            if (!chart.hasRendered) {
                chart.init(options, callback);
            }
        },

        dispose: function () {
            var chart = this;
            chart.disposing = true;

            if (chart.paper) {
                chart.paper.remove();
                delete chart.paper;
            }
            if(chart.exportIframe){
                chart.exportIframe.parentNode.removeChild(chart.exportIframe);
                delete chart.exportIframe;
            }
            delete chart.disposing;
            chart.disposed = true;
            

        },

        onContainerClick: function (e) {
            var tgt = e.target || e.originalTarget || e.srcElement ||
                e.relatedTarget || e.fromElement,
                chart = e.data;

            // do not receive event if the clicked target element is marked as
            // hot
            if (tgt && tgt.ishot && chart) {
                return;
            }

            chart.linkClickFN.call(chart, chart);
        },

        setChartEvents: function () {
            var chart = this,
                options = chart.options,
                link = chart.options.chart.link,
                container = chart.container;

            // In case link is not defined, but chart has a previously attached
            // link, then we remove the same from container and from chart.
            removeEvent(container, 'click', chart.onContainerClick);

            // Check if link has been defined or not. If defined, then append
            // the click event to the chart container and pass on the relevant
            // information as event data
            if (link) {
                chart.link = link; // store the link in chart
                addEvent(container, 'click', chart.onContainerClick, chart);
            }

            // Set the cursor based on the presense of link. Note that IE and
            // other browsers have separate css value.
            if (R.svg) {
                chart.paper.canvas.style.cursor = link && 'pointer' || 'default';
            }
            else {
                chart.paper.canvas.style.cursor = link && 'hand' || 'default';
            }
        },

        onOverlayMessageClick: function () {
            var chart = this,
                paper = chart.paper,
                options = chart.options,
                elements = chart.elements,
                _anim = R.animation({
                    opacity: 0
                }, 1000);

            elements.messageText && elements.messageText.hide();
            elements.messageVeil && elements.messageVeil.hide();
        },

        showMessage: function (msg, cancelable) {
            var chart = this,
                paper = chart.paper,
                options = chart.options,
                optionsChart = options.chart,
                elements = chart.elements,
                messageText = elements.messageText,
                messageVeil = elements.messageVeil,
                w = paper.width,
                h = paper.height,
                text;

            // create the layer at the first call
            if (!messageVeil) {
                messageVeil = elements.messageVeil = paper.rect(0, 0, w, h).attr({
                    fill: 'rgba(0,0,0,0.2)',
                    stroke: 'none'
                });
            }
            messageVeil.show().toFront()
                .attr('cursor', cancelable ? 'pointer' : 'default')[cancelable ?
                'click' : 'unclick'](chart.onOverlayMessageClick, chart);

            if (!messageText) {
                messageText = elements.messageText = paper.text(w / 2, h / 2, BLANK).attr({
                    fill: 'rgba(255,255,255,1)',
                    'font-family': 'Verdana',
                    'font-size': 10,
                    'line-height': 14,
                    ishot: true
                });
            }

            msg = msg || BLANK;
            chart.smartLabel.setStyle({
                'line-height': '14px',
                'font-family': 'Verdana',
                'font-size': '10px'
            });

            text = chart.smartLabel.getSmartText(msg, w -
                (optionsChart.spacingRight || 0) - (optionsChart.spacingLeft || 0), h -
                (optionsChart.spacingTop || 0) - (optionsChart.spacingBotton || 0));

            messageText.attr({
                text: text.text,
                ishot: true,
                cursor: cancelable ? 'pointer' : 'default'
            })[cancelable ? 'click' : 'unclick'](chart.onOverlayMessageClick, chart)
                .show().toFront();

        },

        // draws export and print buttons
        drawButtons: function () {

            var chart = this,
                isZoomLine = chart.logic.rendererId === 'zoomline',
                paper = chart.paper,
                elements = chart.elements,
                toolbar = chart.toolbar || (chart.toolbar = []),
                menus = chart.menus || (chart.menus = []),
                logic = chart.logic,
                layers = chart.layers,
                options = chart.options,
                conf = options[CONFIGKEY],
                outCanvasStyle = conf && conf.outCanvasStyle ||
                                    chart.logic.outCanvasStyle || {},
                chartOptions = options.chart,
                toolbarOptions = chartOptions.toolbar || {},
                hDirection = toolbarOptions.hDirection,
                vDirection = isZoomLine ? 1: toolbarOptions.vDirection,

                button = toolbarOptions.button || {},
                buttonCount = toolbar.count = 0,
                scale = button.scale,
                width = button.width * button.scale,
                height = button.height * button.scale,
                spacing = hDirection * (button.spacing * button.scale + width),
                radius = button.radius,

                y  = toolbar.y || (toolbar.y = (isZoomLine ? 0 : toolbarOptions.y)
                                    + toolbarOptions.vMargin * vDirection +
                                    mathMin(0, height * vDirection)),
                x  = toolbar.x || (toolbar.x =
                                    toolbarOptions.x +
                                    toolbarOptions.hMargin * hDirection -
                                     mathMax(0, width * hDirection)),

                exportOptions = options.exporting,
                buttonConfig = exportOptions && exportOptions.buttons || {},
                isExportButton = buttonConfig.exportButton &&
                                buttonConfig.exportButton.enabled !== false,
                isPrintButton = buttonConfig.printButton &&
                                buttonConfig.printButton.enabled !== false,
                exportContextMenu,
                exportButton,
                printButton,
                buttonsLayer = layers.buttons || (layers.buttons =
                        paper.group('buttons'));

                toolbar.add = function(symbol, callback, options) {
                    var buttonElem,
                        opt = isString(options) ? { tooltip: options } :
                              options || {},
                        offsetX = toolbar.count === 0 ?
                                spacing - hDirection * button.spacing * button.scale :
                                spacing,
                        x = opt.x || (toolbar.x += offsetX),
                        y = opt.y || toolbar.y,
                        tooltip = opt.tooltip || '';

                    toolbar.push(
                        buttonElem = paper.button(
                            x,
                            y,
                            UNDEFINED,
                            symbol,
                            {
                                width: width,
                                height: height,
                                r: radius,
                                id: toolbar.count++,
                                verticalPadding: button.symbolHPadding * scale,
                                horizontalPadding: button.symbolHPadding
                            }, buttonsLayer)
                            .attr({
                                'ishot': true,
                                fill: [button.fill, button.labelFill,
                                    button.symbolFill, button.hoverFill],
                                stroke: [button.stroke, button.symbolStroke],
                                'stroke-width': [button.strokeWidth,
                                    button.symbolStrokeWidth]
                            })
                            .tooltip(tooltip)
                            .buttonclick(callback)
                    );

                    return buttonElem;
                };

            if (isExportButton) {
                menus.push (
                    exportContextMenu =
                    elements.exportMenu = createContextMenu({
                            chart: chart,
                            labels: {
                                style: outCanvasStyle,
                                hover: {
                                    color: 'rgba(255, 255, 255, 1)'
                                }
                            },
                            attrs: {
                                fill: 'rgba(255, 255, 255, 1)'
                            },
                            hover: {
                                fill: R.tintshade(outCanvasStyle.color, .7)
                            },
                            items: (function (formats) {
                                var ret = [], i;
                                for (var i in formats) {
                                    ret.push({
                                        text: formats[i],
                                        onclick: (function (format) {
                                                return function () {
                                                    chart.logic.chartInstance
                                                        .exportChart({
                                                            exportFormat: format
                                                        });
                                                };
                                            }(i))
                                        });
                                }

                                return ret;

                            }(exportOptions.exportformats))
                        })
                    );

                   elements.exportButton = toolbar.add('exportIcon', (function(x,y){
                            return function () {
                                if (exportContextMenu.visible) {
                                    exportContextMenu.hide();
                                    return;
                                }
                                 exportContextMenu.show({
                                        x: x,
                                        y: y + 1
                                    });
                            };
                        }(toolbar.x + width, toolbar.y + height)),
                        {tooltip: 'Export chart'});
            }

            if (isPrintButton) {
                elements.printButton = toolbar.add('printIcon', function(){
                        chart.print();
                    }, { tooltip: 'Print chart'});

            }


        },

        setMargins: function() {
            var chart = this,
                paper = chart.paper,
                options = chart.options,
                chartOptions = options.chart || {},
                canvasBorderWidth = chart.canvasBorderWidth =
                                        chartOptions.plotBorderWidth || 0;

            chart.canvasTop = mathRound(chartOptions.marginTop) || 0;
            chart.canvasLeft = mathRound(chartOptions.marginLeft) || 0;
            chart.canvasWidth = mathRound(paper.width  - (chartOptions.marginLeft  || 0) -
                                              (chartOptions.marginRight  || 0));
            chart.canvasHeight = mathRound(paper.height - (chartOptions.marginTop  || 0) -
                                              (chartOptions.marginBottom || 0));
            chart.canvasRight = chart.canvasLeft + chart.canvasWidth;
            chart.canvasBottom = chart.canvasTop + chart.canvasHeight;

        },

        drawBackground: function () {
            var chart = this,
                paper = chart.paper,
                layers = chart.layers,
                elements = chart.elements,
                group = layers.background ||
                    (layers.background = paper.group("background")),
                background = elements.background ||
                    (elements.background = paper.rect(group)),

                options = chart.options,
                chartOptions = options.chart || {},
                sw = toFloat(chartOptions.borderWidth) || 0,
                ssw = sw * 0.5,

                chartBorderWidth =
                    chartOptions.borderWidth || 0,

                chartHeight = chart.chartHeight,
                chartWidth = chart.chartWidth,

                chartBGImage = elements.backgroundImage,

                bgSWF = chartOptions.bgSWF,
                bgSWFAlpha = chartOptions.bgSWFAlpha / 100,
                bgImageDisplayMode = chartOptions.bgImageDisplayMode,
                bgImageVAlign = chartOptions.bgImageVAlign,
                bgImageHAlign = chartOptions.bgImageHAlign,
                bgImageScale = chartOptions.bgImageScale,
                imgClipRect = chartBorderWidth + COMMA + chartBorderWidth +
                    COMMA + (chartWidth - chartBorderWidth * 2) + COMMA +
                    (chartHeight - chartBorderWidth * 2),
                referenceImage,
                bgImageAttr,
                xRepeatCount,
                imageElement,
                yRepeatCount,
                yCount,
                counter,
                imgY;

            // Apply the container's bg color to SVG element. That will ensure
            // we do not have bleeding background-color due to CTM fixes done
            // to rendering.
            paper.canvas.style.backgroundColor =
                chartOptions.containerBackgroundColor;

            background.attr({
                x: ssw,
                y: ssw,
                width: paper.width - sw,
                height: paper.height - sw,
                stroke: chartOptions.borderColor,
                'stroke-width': sw,
                fill: toRaphaelColor(chartOptions.backgroundColor)
            });

            if (bgSWF) {
                referenceImage = new Image();
                xRepeatCount = 1;
                yRepeatCount = 1;

                //create the blank array as onload may called after the
                //chart._chartBGImage reference passed
                chartBGImage = [];

                referenceImage.onload = function () {
                    bgImageAttr = setImageDisplayMode(bgImageDisplayMode,
                        bgImageVAlign, bgImageHAlign, bgImageScale,
                        chartBorderWidth, chartWidth, chartHeight,
                        referenceImage);
                    bgImageAttr['clip-rect'] = imgClipRect;
                    if (bgImageAttr.tileInfo) {
                        xRepeatCount = bgImageAttr.tileInfo.xCount;
                        yRepeatCount = yCount = bgImageAttr.tileInfo.yCount;
                        imgY = bgImageAttr.y;

                        delete bgImageAttr.tileInfo;

                        while (xRepeatCount) {
                            yCount -= 1;
                            //Use the renderer ref from chartBGImageGroup
                            //as in case of realtime chart the renderer may be
                            // destroyed before onload
                            if (!imageElement) {
                                chartBGImage[counter] = imageElement =
                                    paper.image(bgSWF, group)
                                    .attr(bgImageAttr)
                                    .css({
                                        opacity : bgSWFAlpha
                                    });
                            } else {
                                chartBGImage[counter] = imageElement.clone()
                                .attr({
                                    x: bgImageAttr.x,
                                    y: bgImageAttr.y
                                });
                                group.appendChild(chartBGImage[counter]);
                            }

                            bgImageAttr.y += bgImageAttr.height;
                            if (yCount === 0) {
                                yCount = yRepeatCount;
                                xRepeatCount -= 1;
                                bgImageAttr.x += bgImageAttr.width;
                                bgImageAttr.y = imgY;
                            }
                        }

                    } else {
                        chartBGImage[0] = paper.image(bgSWF, group);
                        chartBGImage[0].attr(bgImageAttr)
                        .css({
                            opacity : bgSWFAlpha
                        })
                        .attr({
                            visibility: VISIBLE,
                            'clip-rect': imgClipRect
                        });
                    }
                };
                referenceImage.src = bgSWF;
                elements.backgroundImage = chartBGImage;
            }
        },

        drawGraph: function() {
            var chart = this,
                paper = chart.paper,
                

                plots = chart.plots = chart.elements.plots,
                logic = chart.logic,
                layers = chart.layers,
                options = chart.options,
                elements = chart.elements,
                chartOptions = options.chart,

                // chart data to be plotted
                datasets = chart.datasets = options.series,

                // series type
                renderAs = getFirstValue(chartOptions.rendererId,
                                             chartOptions.defaultSeriesType),
                // initial layers
                backgroundLayer = layers.background,
                datasetLayer = layers.dataset =
                               layers.dataset || paper.group('dataset')
                                                  .insertAfter(backgroundLayer),

                trackerLayer = layers.tracker =
                               layers.tracker || paper.group('hot')
                                                     .insertAfter(datasetLayer),

                DRAWPLOT = 'drawPlot',
                UPDATEPLOT = 'updatePlot',
                LEGENDCLICK = 'legendClick',
                drawPlotFunctionName,
                updatePlotFunctionName,
                drawPlotFunction,
                updatePlotFunction,
                datasetOptions,
                plotType,
                plot,
                i,
                l;

            // draw canvas where required
            chart.drawCanvas();

            // draw axes labels, divlines, divgrids, trendlines/zones where required
            chart.drawAxes();

            //
            if (!plots) {
                plots = chart.plots = (chart.plots || []);
                

                elements.plots = plots;
            }

            // draw all dataplots along with datalabels
            for (i = 0, l = datasets.length; i < l; i++) {
                datasetOptions = datasets[i] || {};

                updatePlotFunctionName = datasetOptions.updatePlot = UPDATEPLOT +
                            getSentenceCase(pluck(datasetOptions.type,
                                            datasetOptions.plotType, renderAs));

                updatePlotFunction = chart[updatePlotFunctionName];

                drawPlotFunctionName = datasetOptions.drawPlot = DRAWPLOT +
                            getSentenceCase(pluck(datasetOptions.type,
                                            datasetOptions.plotType, renderAs));

                drawPlotFunction = chart[drawPlotFunctionName] || chart[DRAWPLOT];

                if (!(plot = plots[i])) {
                    plots.push(plot = {
                        index   : i,
                        items   : [],
                        data    : datasetOptions.data || [],
                        name    : datasetOptions.name,
                        userID  : datasetOptions.userID,
                        setVisible      : (function (i, datasetOptions) {
                            return function (isVisible) {
                                var plot = plots[i],
                                    visibility,
                                    reflowUpdate = {hcJSON: {series: []}},
                                    reflowPlot = reflowUpdate.hcJSON.series[i] ||
                                            (reflowUpdate.hcJSON.series[i]={}),
                                    reflowData = logic.chartInstance.jsVars._reflowData;

                                    isVisible = getFirstValue(isVisible, !plot.visible),
                                    visibility = isVisible ? 'visible' : 'hidden';

                                // hide plots
                                each (plot.graphics, function (graphic){
                                    graphic.attr('visibility', visibility);
                                });

                                // Update plot visibility
                                plot.visible = isVisible;
                                datasetOptions.visible = isVisible;
                                // Save state of the updated visibility
                                reflowPlot.visible = isVisible;
                                extend2(reflowData, reflowUpdate, true);

                            };
                        }(i, datasetOptions)),

                        legendClick     : (function (i) {
                            return function (isVisible, restrainEvent) {
                                    chart[LEGENDCLICK + renderAs] &&
                                    chart[LEGENDCLICK + renderAs](plots[i], isVisible, restrainEvent)  ||
                                chart[LEGENDCLICK] &&
                                    chart[LEGENDCLICK](plots[i], isVisible, restrainEvent);
                            };
                        } (i)),

                        realtimeUpdate  : (function (i, drawPlotFunction, datasetOptions) {
                            return function (numUpdate, hasAxisChanged) {
                                    drawPlotFunction.call(chart, plots[i],
                                        datasetOptions, {
                                            numUpdate: numUpdate,
                                            hasAxisChanged: hasAxisChanged
                                        });
                            };
                        } (i, updatePlotFunction || drawPlotFunction, datasetOptions))

                    });

                    datasetOptions.plot = plot;
                    datasetOptions.legendClick = plot.legendClick;
                    datasetOptions.setVisible = plot.setVisible;
                }

                drawPlotFunction.call(chart, plot, datasetOptions);
            }

            if (chartOptions.hasScroll) {
                chart.drawScroller();
                // finalize scroll
                chart.finalizeScrollPlots();
            }

        },

        drawPlot: stubFN,
        drawCanvas: stubFN,
        drawAxes: stubFN,

        drawScroller: function() { },

        drawLegend: function() {
            var chart = this,
                options = chart.options,
                paper = chart.paper,
                optionsChart = options.chart || {},
                legendOptions = options.legend,
                scrollOptions = legendOptions.scroll,
                legend = {
                    elements: {
                    }
                },
                elements = legend.elements,
                legendGroup = chart.layers.legend,
                box = elements.box,
                caption = elements.caption,
                elementGroup = elements.elementGroup,
                isVertical = legendOptions.layout === "vertical",
                marginTop = optionsChart.spacingTop,
                marginBottom = optionsChart.spacingBottom,
                marginLeft = optionsChart.spacingLeft,
                marginRight = optionsChart.spacingRight,
                chartWidth = paper.width,
                chartHeight = paper.height,
                canvasTop = chart.canvasTop,
                canvasLeft = chart.canvasLeft,
                canvasWidth = chart.canvasWidth,
                canvasHeight = chart.canvasHeight,
                width = legendOptions.width,
                height = legendOptions.height,
                r = legendOptions.borderRadius,
                backgroundColor = legendOptions.backgroundColor,
                borderColor = legendOptions.borderColor,
                borderWidth = legendOptions.borderWidth || 0,
                semiBorder = borderWidth * 0.5,
                translationLimit = (borderWidth * 0.5) + 2, //2px gutter
                padding = pluckNumber(legendOptions.padding, 4),
                halfPad = padding * 0.5,
                //store all series type that has no special legend symbol
                markerLegend = {
                    line: true,
                    spline: true,
                    scatter: true,
                    zoomline: true
                },
                xPos,
                yPos,
                clipSTR1,
                clipH,
                clipSTR2,
                dragX,
                dragY,
                dragOffsetX,
                dragOffsetY,
                dragInitX,
                dragInitY,
                scroller,
                crispBox;


            if (isVertical) {
                xPos = chartWidth - marginRight - width;
                yPos = marginTop + ((chartHeight - marginBottom - marginTop -
                    height) * 0.5) + (legendOptions.y || 0);
            }
            else {
                xPos = marginLeft + ((chartWidth - marginLeft - marginRight -
                    width) * 0.5) + (legendOptions.x || 0);
                yPos = chartHeight - marginBottom - height;
            }

            // Crispen the legend box
            crispBox = R.crispBound(xPos, yPos, width, height, borderWidth);
            xPos = crispBox.x;
            yPos = crispBox.y;
            width = crispBox.width;
            height = crispBox.height;

            // Draw the parent group.
            if (!legendGroup) {
                legendGroup = chart.layers.legend = paper.group('legend')
                    .insertBefore(chart.layers.tracker)
                    .translate(xPos, yPos);
            }

            // Add legend dragging events and configuration.
            if (legendOptions.legendAllowDrag) {
                dragX = xPos;
                dragY = yPos;
                legendGroup.css({
                    cursor: 'move'
                }).drag(function(dx, dy) {
                    

                    dragOffsetX = dragInitX + dx;
                    dragOffsetY = dragInitY + dy;
                    if (dragOffsetX + width + translationLimit > chartWidth) {
                        dragOffsetX = chartWidth - width - translationLimit;
                    }
                    if (dragOffsetY + height + translationLimit > chartHeight) {
                        dragOffsetY = chartHeight - height - translationLimit;
                    }
                    if (dragOffsetX < translationLimit) {
                        dragOffsetX = translationLimit;
                    }
                    if (dragOffsetY < translationLimit) {
                        dragOffsetY = translationLimit;
                    }
                    legendGroup.translate(dragOffsetX - dragX, dragOffsetY - dragY);
                    dragX = dragOffsetX;
                    dragY = dragOffsetY;
                }, function(x, y) {
                    dragInitX = dragX;
                    dragInitY = dragY;
                });
            }

            //draw the background
            if (!box) {
                box = elements.box = paper.rect(legendGroup);
            }
            //apply all atributes
            box.attr({
                x: 0,
                y: 0,
                width: width,
                height: height,
                r: r,
                stroke: borderColor,
                'stroke-width': borderWidth,
                fill: backgroundColor || NONE,
                ishot: legendOptions.legendAllowDrag
            })
            .shadow(legendOptions && legendOptions.shadow);

            if (scrollOptions && scrollOptions.enabled) {
                clipSTR1 = '0,';
                clipH = height - padding;
                clipSTR2 = COMMA + width + COMMA + clipH;
                elementGroup = elements.elementGroup = paper.group('legenditems', legendGroup)
                    .attr({
                        'clip-rect': clipSTR1 + halfPad + clipSTR2
                    });
                scroller = elements.scroller || (elements.scroller =
                    paper.scroller(width - 10 +
                        halfPad - borderWidth, semiBorder, 10, height - borderWidth, false, {
                            scrollPosition: scrollOptions.scrollPosition || 0,
                            scrollRatio: (clipH + padding) / legendOptions.totalHeight,
                            showButtons: false,
                            displayStyleFlat: scrollOptions.flatScrollBars
                        }, legendGroup));

                scroller.attr('fill', legendOptions.legendScrollBgColor).scroll(function (pos) {
                    elementGroup.transform(['T',0, (clipH -
                        legendOptions.totalHeight) * pos]);

                    extend2(chart.fusionCharts.jsVars._reflowData, {
                        hcJSON: {
                            legend: {
                                scroll: {
                                    position: arguments[0]
                                }
                            }
                        }
                    }, true);

                });

            }
            else {
                elementGroup = elements.elementGroup = legendGroup;
            }

            //draw the caption
            if (legendOptions.title && legendOptions.title.text !== BLANK) {
                if (!caption) {
                    caption = elements.caption = paper.text(elementGroup);
                }
                caption.attr({
                    text: legendOptions.title.text,
                    title: (legendOptions.title.originalText || ''),
                    x: width * 0.5,
                    y: padding,
                    fill: legendOptions.title.style.color,
                    'vertical-align': 'top'
                }).css(legendOptions.title.style);
            }

            //draw legend items
            this['draw' + getSentenceCase(legendOptions.type || 'point') + 'LegendItem'](legend);


        },

        //Function to draw point type legend's item
        drawPointLegendItem: function (legend) {
            var chart = this,
                paper = chart.paper,
                options = chart.options,
                series = options.series,
                optionsChart = options.chart,
                defaultSeriesType = optionsChart.defaultSeriesType,
                legendOptions = options.legend,
                symbolBoxW = legendOptions.legendHeight,
                symbolPadding = legendOptions.symbolPadding,
                textPadding = legendOptions.textPadding || 2,
                padding = pluckNumber(legendOptions.padding, 4),
                itemHiddenStyle = legendOptions.itemHiddenStyle,
                itemStyle = legendOptions.itemStyle,
                itemTextColor = itemStyle.color,
                hiddenColor = itemHiddenStyle && itemHiddenStyle.color || '#CCCCCC',
                symbolWidth = legendOptions.symbolWidth,
                itemWidth = legendOptions.itemWidth,
                interactiveLegend = legendOptions.interactiveLegend !== false,
                elements = legend.elements,
                elementGroup = elements.elementGroup,
                item = legend.item = [],//store for individual legend item
                elementItem = elements.item = [],//store for drawing elements
                allItems = [],
                //store all series type that has no special legend symbol
                markerLegend = {
                    line: true,
                    spline: true,
                    scatter: true,
                    bubble: true,
                    dragnode: true,
                    zoomline: true
                },
                initialItemX,
                initialItemY,
                legendItem,
                legendType,
                visible,
                itemLineColor,
                itemClickFN,
                legendItemText,
                legendItemBackground,
                serie,
                data,
                type,
                point,
                itemX,
                itemY,
                itemHeight,
                i,
                j,
                ln,
                ln1,
                cx,
                cy,
                radius,
                symbol,
                dip,
                marker,
                legendItemSymbol,
                symbolConfig,
                legendItemLine,
                newLegendItem,
                symbolColor;

            //collect all element that has a valid legend
            for (i = 0, ln = series.length; i < ln; i += 1) {
                serie = series[i];
                if (serie && serie.showInLegend !== false) {
                    type = serie.type || defaultSeriesType;
                    // use points or series for the legend item depending on legendType
                    if (serie.legendType === 'point') {
                        data = serie.data || [];
                        for (j = 0, ln1 = data.length; j < ln1; j += 1) {
                            point = data[j] || {};
                            if (point.showInLegend !== false) {
                                point._legendType = type;
                                allItems.push(point);
                            }
                        }
                    }
                    else {
                       serie._legendType = type;
                       switch (type) {
                           case 'pie':
                           case 'pie3d':
                           case 'funnel':
                           case 'pyramid':
                               allItems = serie.data;
                           break;

                           default:
                               allItems.push(serie);
                           break;
                       }
                    }
                }
            }
            // sort by legendIndex
            allItems.sort(function(a, b) {
                return ((a.legendIndex || 0) - (b.legendIndex || 0)) ||
                    (a.__i - b.__i);
            });
            // reversed legend
            if (legendOptions.reversed) {
                // This reverse the main items as pie, so required to be reversed
                // again after legend item creation is over.
                allItems.reverse();
            }

            initialItemX = legendOptions.initialItemX || 0;
            initialItemY = legendOptions.initialItemY || 0;

            //draw all items
            for (i = 0, ln = allItems.length; i < ln; i += 1) {
                if (allItems[i].showInLegend === false) {
                    continue;
                }
                newLegendItem = {
                    elements: {},
                    hiddenColor: hiddenColor,
                    itemTextColor: itemTextColor
                };
                item.push(newLegendItem);
                elementItem.push(newLegendItem.elements);
                legendItem = allItems[i];
                itemX = initialItemX + legendItem._legendX + padding;
                itemY = initialItemY + legendItem._legendY - padding;
                itemHeight = legendItem._legendH;
                legendType = legendItem._legendType || type;
                visible = !(legendItem.visible === false);
                itemLineColor = newLegendItem.itemLineColor = toRaphaelColor(legendItem.color || {}); 

                itemClickFN = interactiveLegend ? (function(legendItem) {
                    return function() {
                        legendItem.legendClick();
                    };
                }(legendItem)) : falseFN;

                //store the legend elements into plot
                legendItem.plot.legend = newLegendItem;

                // draw background
                legendItemBackground = newLegendItem.elements.legendItemBackground = paper.rect(
                        itemX,
                        itemY, //text gutter
                        itemWidth,
                        itemHeight,
                        0,
                        elementGroup
                    )
                    .click(itemClickFN)
                    .attr({
                        fill: toRaphaelColor(legendItem.legendFillColor || TRACKER_FILL),
                        'stroke-width': 1,
                        stroke: toRaphaelColor(legendItem.legendBorderColor || NONE),
                        cursor: itemStyle.cursor || 'pointer',
                        ishot: interactiveLegend
                    });

                // create the text
                legendItemText = newLegendItem.elements.legendItemText = paper.text(
                        itemX + symbolBoxW + textPadding - 2,
                        itemY + (legendItem._legendTestY || 0), //text gutter
                        legendItem.name,
                        elementGroup
                    )
                    //.css(legendItem.visible === false ? {} : {})
                    .css(itemStyle)
                    .click(itemClickFN)
                    .attr({
                        fill: visible ? itemTextColor : hiddenColor,
                        'vertical-align': 'top',
                        'text-anchor': 'start',
                        cursor: itemStyle.cursor || 'pointer',
                        title: (legendItem.originalText || ''),
                        ishot: interactiveLegend
                    });

                //create the symbol
                if (markerLegend[legendType]) {
                    cy = itemY + symbolPadding + (symbolWidth * 0.5);
                    //draw the line
                    if (legendItem.lineWidth) {
                        legendItemLine = newLegendItem.elements.legendItemLine = paper.path([
                            M,
                            itemX + symbolPadding,
                            cy,
                            L,
                            itemX + symbolPadding + symbolWidth,
                            cy
                        ], elementGroup).click(itemClickFN)
                            .attr({
                            'stroke-width': legendItem.lineWidth,
                            stroke: visible ? itemLineColor : hiddenColor,
                            cursor: itemStyle.cursor || 'pointer',
                            ishot: interactiveLegend
                        });
                    }

                    //draw the marker
                    if (legendItem && (marker = legendItem.marker) && marker.enabled !== false) {
                        newLegendItem.symbolStroke = toRaphaelColor(pluck(marker.lineColor &&
                            (marker.lineColor.FCcolor && marker.lineColor.FCcolor.color.split(COMMA)[0] || marker.lineColor),
                            itemLineColor));
                        if (marker.fillColor && marker.fillColor.FCcolor){
                            symbolColor = extend2({}, marker.fillColor);
                            symbolColor.FCcolor.alpha = '100';
                        }
                        else {
                            symbolColor = pluck(marker.fillColor, itemLineColor);
                        }
                        newLegendItem.symbolColor = toRaphaelColor(symbolColor);
                        radius = symbolWidth * 0.5;
                        cx = itemX + symbolPadding + radius;
                        cy = itemY + symbolPadding + radius;
                        if (legendItemLine) {
                            radius *= 0.6;
                        }
                        symbol = marker.symbol.split('_');
                        dip = symbol[0] === "spoke" ? 1 : 0;
                        if (symbol[1]) {
                            legendItemSymbol = newLegendItem.elements.legendItemSymbol
                                = paper.polypath(symbol[1], cx, cy, radius, marker.startAngle, dip, elementGroup);
                        }
                        else {
                            legendItemSymbol = newLegendItem.elements.legendItemSymbol
                                = paper.circle(cx, cy, radius, elementGroup);
                        }
                        legendItemSymbol.click(itemClickFN)
                            .attr({
                            cursor: itemStyle.cursor || 'pointer',
                            stroke: visible ? newLegendItem.symbolStroke : hiddenColor,
                            fill: visible ? newLegendItem.symbolColor : hiddenColor,
                            'stroke-width': 1,
                            ishot: interactiveLegend
                        });
                    }
                }
                else {
                    symbolConfig = chart.getSymbolPath(itemX + symbolPadding, itemY + symbolPadding,
                        symbolWidth, symbolWidth, legendType, legendItem);
                    newLegendItem.symbolColor = toRaphaelColor(symbolConfig.color);
                    newLegendItem.symbolStroke = toRaphaelColor(symbolConfig.strokeColor);
                    legendItemSymbol = newLegendItem.elements.legendItemSymbol = paper.path(symbolConfig.path, elementGroup)
                        .click(itemClickFN)
                        .attr({
                        'stroke-width': symbolConfig.strokeWidth,
                        stroke: visible ? newLegendItem.symbolStroke : hiddenColor,
                        fill: visible ? newLegendItem.symbolColor : hiddenColor,
                        cursor: itemStyle.cursor || 'pointer',
                        ishot: interactiveLegend
                    });
                }

            }
            if (legendOptions.reversed) {
                // As stated above, the array is reversed once again to maintain
                // the right order, like for the case of pie.
                allItems.reverse();
            }
        },

        drawCaption: function () {
            var chart = this,
                optionsChart = chart.options.chart,
                optionsCap = chart.options.title,
                optionsSubcap = chart.options.subtitle,
                paper = chart.paper,
                elements = chart.elements,
                layers = chart.layers,
                captionGroup = layers.caption,
                caption = elements.caption,
                subcaption = elements.subcaption,
                interCaptionGap = 2,
                hasCaption = (optionsCap && optionsCap.text),
                hasSubcaption = (optionsSubcap && optionsSubcap.text),
                canvasCentre = ((chart.canvasLeft || 0) +
                    (pluckNumber(chart.canvasWidth, paper.width) / 2)),
                captionX = optionsCap.x,
                subcaptionX = (optionsSubcap && optionsSubcap.x);

            // if captions are needed, then we need to ensure that it is placed
            // within a group.
            if (hasCaption || hasSubcaption) {
                if (!captionGroup) {
                    captionGroup = layers.caption = paper.group('caption');

                    if (layers.tracker) {
                        captionGroup.insertBefore(layers.tracker);
                    }
                    else {
                        captionGroup.insertAfter(layers.dataset);
                    }
                }
            }

            // if definition has caption, we proceed creating one and if there
            // is no caption we remove any previously created caption element.
            // captions are center aligned with respect to canvas and we
            // position them (cap and subcap) vertically one after another
            // and keep their v-align as top.
            if (hasCaption) {
                if (!caption) {
                    caption = elements.caption = paper.text(captionGroup);
                }

                if (captionX === undefined) {
                    captionX = canvasCentre;
                    optionsCap.align = POSITION_MIDDLE;
                }

                caption.css(optionsCap.style).attr({
                    text: optionsCap.text,
                    fill: optionsCap.style.color,
                    x: captionX,
                    y: (optionsCap.y || optionsChart.spacingTop || 0),
                    'text-anchor': (optionsCap.align) || POSITION_MIDDLE,
                    'vertical-align': 'top',
                    visibility: 'visible',
                    title: (optionsCap.originalText || '')
                });

            }
            else if (caption) {
                caption = elements.caption = caption.remove();
            }

            if (hasSubcaption) {
                if (!subcaption) {
                    subcaption = elements.subcaption = paper.text(captionGroup);
                }

                if (subcaptionX === undefined) {
                    subcaptionX = canvasCentre;
                    optionsSubcap.align = POSITION_MIDDLE;
                }

                subcaption.css(optionsSubcap.style).attr({
                    text: optionsSubcap.text,
                    title: (optionsSubcap.originalText || ''),
                    fill: optionsSubcap.style.color,
                    x: subcaptionX,
                    y: hasCaption ?
                        (caption.attrs.y + caption.getBBox().height + interCaptionGap) :
                        (optionsCap.y || optionsChart.spacingTop || 0),

                    'text-anchor': optionsSubcap.align || 'middle',
                    'vertical-align': 'top',
                    visibility: 'visible'
                });
            }
            else if (subcaption) {
                subcaption = elements.subcaption = subcaption.remove();
            }

            // if neither caption or subcaption is needed, we need to dump the
            // group as well.
            if (!(hasCaption || hasSubcaption || !captionGroup)) {
                captionGroup = layers.caption = captionGroup.remove();
            }
        },

        drawLogo: function () {
            var chart = this,
                paper = chart.paper,
                layers = chart.layers,
                elements = chart.elements,
                options = chart.options,
                logic = chart.logic,
                credits = options.credits,
                chartOptions = options.chart || {},
                chartBorderWidth =
                    chartOptions.borderWidth || 0,
                chartHeight = chart.chartHeight,
                chartWidth = chart.chartWidth,
                chartLogoImage = elements.logoImage,
                chartLogoImageGroup = layers.tracker,
                logoURL = chartOptions.logoURL,
                logoAlpha = chartOptions.logoAlpha / 100,
                logoPosition = chartOptions.logoPosition,
                logoLink = chartOptions.logoLink,
                logoScale = chartOptions.logoScale,
                logoLeftMargin = chartOptions.logoLeftMargin,
                logoTopMargin = chartOptions.logoTopMargin,
                imgClipRect = chartBorderWidth + COMMA + chartBorderWidth +
                    COMMA + (chartWidth - chartBorderWidth * 2) + COMMA +
                    (chartHeight - chartBorderWidth * 2),
                position = {
                    tr: {
                        vAlign: POSITION_TOP,
                        hAlign: POSITION_RIGHT
                    },
                    bl: {
                        vAlign: POSITION_BOTTOM,
                        hAlign: POSITION_LEFT
                    },
                    br: {
                        vAlign: POSITION_BOTTOM,
                        hAlign: POSITION_RIGHT
                    },
                    cc: {
                        vAlign: POSITION_MIDDLE,
                        hAlign: POSITION_MIDDLE
                    }
                },
                logoReferenceImage,
                logoImageAttr,
                creditLabel;

            // Drawing of the credit-label.
            if (chart.logic && credits.enabled) {
//                paper.rect(1, chartHeight - 16, 100, 15).attr({
//                    stroke: 'none',
//                    fill: '180-rgba(255,255,255,0)-rgba(255,255,255,255)'
//                });
                creditLabel = paper.text()
                    .attr({
                        text: credits.text,
                        x: 6,
                        y: chartHeight - 4,
                        'vertical-align': POSITION_BOTTOM,
                        'text-anchor': POSITION_START,
                        fill: 'rgba(0,0,0,0.5)',
                        title: credits.title || ''
                    })
                    .css({
                        fontSize: 9,
                        fontFamily: 'Verdana',
                        cursor: 'pointer',
                        '_cursor' : 'hand'
                    })
                    .click(function () {
                        chartOptions.events.click.call({
                            link : credits.href
                        });
                    });
            }

            if (logoURL) {
                logoReferenceImage = new Image();
                logoPosition = position[logoPosition];
                if (!logoPosition) {
                    logoPosition = {
                        vAlign: POSITION_TOP,
                        hAlign: POSITION_LEFT
                    };
                }

                //create the image element as before onload the chart may be
                // destroyed in case of realtime chart with small updateInterval
                logoReferenceImage.onload = function () {
                    logoImageAttr = setImageDisplayMode(NONE,
                        logoPosition.vAlign, logoPosition.hAlign,
                        logoScale, chartBorderWidth, chartWidth, chartHeight,
                        logoReferenceImage);

                    chartLogoImage = paper.image(logoURL);
                    chartLogoImageGroup.appendChild(chartLogoImage);
                    logoImageAttr['clip-rect'] = imgClipRect;
                    chartLogoImage
                    .attr(logoImageAttr)
                    .translate(logoLeftMargin, logoTopMargin)
                    .css({
                        opacity : logoAlpha
                    });

                    if (logoLink) {
                        chartLogoImage.css({
                            cursor: 'pointer',
                            '_cursor' : 'hand'
                        })
                        .click(function () {
                            chartOptions.events.click.call({
                                link : logoLink
                            });
                        });
                    }
                };

                logoReferenceImage.src = logoURL;
                elements.logoImage = chartLogoImage;
            }
        },

        legendClick: function(plot, isVisible, restrainEvent) {

            var chart = this,
                item =  plot.legend,
                legendText = item.elements.legendItemText,
                legendIcon = item.elements.legendItemSymbol,
                legendIconLine = item.elements.legendItemLine,
                hiddenColor = item.hiddenColor,
                itemLineColor = item.itemLineColor,
                itemTextColor = item.itemTextColor,
                symbolColor = item.symbolColor,
                symbolStroke = item.symbolStroke,
                targetVisibility = pluck(isVisible, !plot.visible),
                eventArgs,
                graphics,
                graphic,
                relatedSeries,
                plotIndex,
                seriesCounter,
                relatedPlot,
                i,
                j,
                ln;

                // toggle visibility
                plot.setVisible(isVisible);

                if (restrainEvent !== true) {
                    // fire legenditemclicked event
                    eventArgs = {
                        datasetName: plot.name,
                        datasetIndex: plot.index,
                        id: plot.userID,
                        visible: targetVisibility
                    };
                    global.raiseEvent('legenditemclicked', eventArgs, chart.logic.chartInstance);
                }

                //change the color of all legend elements depemding upon state
                //show/hide series or point elements
                if (targetVisibility) {
                    legendIcon.attr({
                        fill: symbolColor || itemLineColor,
                        'stroke': symbolStroke
                    });
                    legendText.attr({
                        fill: itemTextColor
                    });
                    legendIconLine && (legendIconLine.attr({
                        'stroke': itemLineColor
                    }));
                }
                else {
                    legendIcon.attr({
                        fill: hiddenColor,
                        'stroke': hiddenColor
                    });
                    legendText.attr({
                        fill: hiddenColor
                    });
                    legendIconLine && (legendIconLine.attr({
                        'stroke': hiddenColor
                    }));

                }

                //get any related series
                relatedSeries = chart.datasets && chart.datasets[plot.index] &&
                        chart.datasets[plot.index].relatedSeries;

                if(relatedSeries && (relatedSeries instanceof Array) && relatedSeries.length > 0){
                    seriesCounter = relatedSeries.length;
                    while(seriesCounter--){
                        plotIndex = parseFloat(relatedSeries[seriesCounter]);
                        relatedPlot = chart.plots[plotIndex];
                        //invoke legendClick of the related plot
                        relatedPlot && relatedPlot.legend &&
                                relatedPlot.legendClick.call(relatedPlot, targetVisibility, false);

                    }

                }

        },

        /**
         * This function is used to export a chart
         *
         * @param {object} exportOption optional exporting configuration
         */
        exportChart: function(exportOption) {
            var renderer = this,
                elements = renderer.elements,
                printButton = elements.printButton,
                exportButton = elements.exportButton,
                fusionCharts = renderer.fusionCharts,
                chartId = fusionCharts.id,
                paper = renderer.paper,
                options = renderer.options,
                exportOptions_lowerKeys = isObject(exportOption) && (function (object) {
                            var newObject = {}, key;
                            for (var key in object) {
                                newObject[key.toLowerCase()] = object[key];
                            }
                            return newObject;
                        } (exportOption)) || {},
                optionsExport = extend2(extend2({}, options.exporting), exportOptions_lowerKeys),
                exportFormat = (optionsExport.exportformat || PNG).toLowerCase(),
                exportHandler = optionsExport.exporthandler,
                exportAction = (optionsExport.exportaction || BLANK).toLowerCase(),
                exportTargetWindow = optionsExport.exporttargetwindow || BLANK,
                exportAtClient = 0,//optionsExport.exportatclient,
                exportFileName = optionsExport.exportfilename,
                exportParameters = optionsExport.exportparameters,
                postData,
                frameid,
                iframe,
                form,
                ajax,
                item,
                svg;

            // In case exporting is disabled, we need not proceed any further.
            if (!options.exporting || !options.exporting.enabled || !exportHandler) {
                return false;
            }

            // hide print and export buttons before capturing export data
            printButton && printButton.attrs['visibility'] != 'hidden'
                            && (printButton.attr({'visibility': 'hidden'}));
            exportButton && exportButton.attrs['visibility'] != 'hidden'
                            && (exportButton.attr({'visibility': 'hidden'}));

            // procure the SVG of the current paper.
            svg = paper.toSVG();

            // show print and export buttons before capturing export data
            printButton  && (printButton.attr({'visibility': 'visible'}));
            exportButton  && (exportButton.attr({'visibility': 'visible'}));

            if (!exportAtClient) {

                // remove the no-effect paths
                svg = svg.replace(/(\sd\s*=\s*["'])[M\s\d\.]*(["'])/ig, '$1M 0 0 L 0 0$2');

                // add a dummy path to overcome Batik pdf convertion issue
                if (exportFormat === PDF) {
                    svg = svg.replace(/<(\b[^<>s\s]+\b)[^\>]+?opacity\s*=\s*['"][^1][^\>]+?(\/>|>[\s\r\n]*?<\/\1>)/ig,
                        function (fullText, tagName){
                            var recrXCommand = xAttrRegx.exec(fullText) || BLANK,
                            recrYCommand = yAttrRegx.exec(fullText) || BLANK;
                            return (fullText+'<'+ tagName + recrXCommand + recrYCommand + ' opacity="1" stroke-opacity="1" fill="#cccccc" stroke-width="0" r="0" height="0.5" width="0.5" d="M 0 0 L 1 1" />');
                        });
                }

                // create the server-side post object
                postData = {
                    charttype: fusionCharts.src,
                    stream: svg,
                    stream_type: SVG,
                    meta_bgColor: optionsExport.bgcolor || '',
                    meta_DOMId: fusionCharts.id,
                    meta_width: paper.width,
                    meta_height: paper.height,
                    parameters: [
                        'exportfilename=' + exportFileName,
                        'exportformat=' + exportFormat,
                        'exportaction=' + exportAction,
                        'exportparameters=' + exportParameters
                    ].join('|')
                };

                // In case export action is to download the exported
                // object, we simply post the chart as a form.
                if (exportAction === DOWNLOAD) {
                    if (/webkit/ig.test(navigator.userAgent)  && exportTargetWindow === '_self') {
                        exportTargetWindow = frameid = chartId + 'export_iframe';
                        if (!renderer.exportIframe){
                            renderer.exportIframe = iframe = createElement('IFRAME', {
                                name: frameid,
                                width: '1px',
                                height: '1px'
                            }, doc.body);
                            iframe.style.cssText = 'position:absolute;left:-10px;top:-10px;';
                        }
                    }
                    // We create a hidden form in the page body and
                    // populate with input elements that contain the
                    // required post data and then submit the form.
                    form = createElement(FORM, {
                        method: POST,
                        action: exportHandler,
                        target: exportTargetWindow,
                        style: 'display:none;'
                    }, doc.body);

                    for (item in postData) {
                        createElement(INPUT, {
                            type: HIDDEN,
                            name: item,
                            value: postData[item]
                        }, form);
                    }

                    form.submit();
                    doc.body.removeChild(form);
                    form = undefined;

                    return true;
                }
                // In case we need to save data on server, we would need
                // to send it as AJAX call and not as form post;
                else {
                    var ajax = new global.ajax(function(resp) {
                        var responseObj = {};
                        // Creete the responce object from responce text.
                        resp.replace(new RegExp("([^?=&]+)(=([^&]*))?", "g"), function($0, $1, $2, $3) {
                            responseObj[$1] = $3;
                        });

                        lib.raiseEvent('exported', responseObj, fusionCharts,
                            [responseObj]);
                    }, function(err) {
                        var responseObj = {
                            statusCode: 0,
                            statusMessage: 'failure',
                            error: err,
                            DOMId: chartId,
                            width: paper.width,
                            height: paper.height
                        };
                        lib.raiseEvent('exported', responseObj, fusionCharts,
                            [responseObj]);
                    });
                    ajax.post(exportHandler, postData);
                }

                return true;
            }


            

        },

        /**
         * This function prints the chart
         */
        print: function() {

            var chart = this,
            container = chart.container,
            elements = chart.elements,
            printButton = elements.printButton,
            exportButton = elements.exportButton,
            origDisplay = [],
            origParent = container.parentNode,
            body = doc.body,
            childNodes = body.childNodes;

            if (chart.isPrinting) { // block the button while in printing mode
                return;
            }

            chart.isPrinting = true;

            // hide all body content
            each(childNodes, function(node, i) {
                if (node.nodeType == 1) {
                    origDisplay[i] = node.style.display;
                    node.style.display = NONE;
                }
            });

            // hide print and export buttons before capturing export data
            printButton && printButton.attrs['visibility'] != 'hidden'
                            && (printButton.attr({'visibility': 'hidden'}));
            exportButton && exportButton.attrs['visibility'] != 'hidden'
                            && (exportButton.attr({'visibility': 'hidden'}));

            // pull out the chart
            body.appendChild(container);

            // print
            win.print();

            // allow the browser to prepare before reverting
            setTimeout(function() {

                // show print and export buttons before capturing export data
                printButton  && (printButton.attr({'visibility': 'visible'}));
                exportButton && (exportButton.attr({'visibility': 'visible'}));

                // put the chart back in
                origParent.appendChild(container);

                // restore all body content
                each(childNodes, function(node, i) {
                    if (node.nodeType == 1) {
                        node.style.display = origDisplay[i];
                    }
                });

                chart.isPrinting = false;

            }, 1000);

        },


        //function that will create a symbol path for a legend icon.
        getSymbolPath: function(x, y, w, h, seriesType, item, isVml) {
            

            var path = [M], colorStr = item.color && getFirstColor(typeof item.color === "string" ? item.color : item.color.FCcolor.color) || BLANK,
                color, w1, w2, h1, h2, height3, x1, x2, y1, y2, r1,
                Z = 'Z', A = 'A', lightColor, strokeWidth = 0.5, strokeColor;

            color = colorStr.replace(dropHash, '');
            lightColor = getLightColor(color, 40);
            strokeColor = getDarkColor(color, 60).replace(dropHash, HASHSTRING);
            color = {
                FCcolor: {
                    color: color + ',' + color + ',' + lightColor + ',' + color + ',' + color,
                    ratio: '0,30,30,30,10',
                    angle: 0,
                    alpha: '100,100,100,100,100'
                }
            };

            switch (seriesType) {
                case 'column':
                case 'dragcolumn':
                case 'column3d':
                    w1 = w * 0.25;
                    w2 = w1 * 0.5;
                    h1 = h * 0.7;
                    h2 = h * 0.4;

                    path = path.concat([x, y + h, "l", 0, -h1, w1, 0, 0, h1, "z",
                    "m", w1 + w2, 0, "l", 0, -h, w1, 0, 0, h, "z",
                    "m", w1 + w2, 0, "l", 0, -h2, w1, 0, 0, h2, "z"]);
                    color.FCcolor.angle = 270;
                    break;

                case 'bar':
                case 'bar3d':
                    w1 = w * 0.3;
                    w2 = w * 0.6;
                    h1 = h / 4;
                    h2 = h1 / 2;
                    path = path.concat([x, y, L, x + w2, y, x + w2, y + h1, x, y + h1, Z,
                       M,  x, y + h1 + h2, L, x + w, y + h1 + h2, x + w, y + h1 + h2 + h1,  x, y + (2 * h1) + h2, Z,
                       M, x, y + 2 * (h1 + h2), L, x + w1, y + 2 * (h1 + h2),  x + w1, y + h, x, y + h, Z
                    ]);
                    break;

                case 'area':
                case 'area3d':
                case 'areaspline':
                case 'dragarea':
                    w1 = w * 0.3;
                    w2 = w * 0.6;
                    h1 = h * 0.6;
                    h2 = h * 0.2;
                    height3 = h * 0.8;
                    path = path.concat([x, y + height3, L, x, y + h1, x + w1, y + h2,
                        x + w2, y + h1, x + w, y + h2, x + w, y + height3, Z]);
                    color.FCcolor.angle = 270;
                    break;

                case 'pie':
                case 'pie3d':
                    w1 = w / 2;
                    w2 = w * 0.7;
                    h1 = h / 2;
                    h2 = h * 0.7;
                    x1 = x, x2 = x, y1 = y, y2 = y;

                    path = path.concat([x2 + w1, y2 + h1, L, x + w2, y2,
                    A, w1, h1, 0, 0, 0, x2, y2 + h1, L, x2 + w1, y2 + h1,
                    M, x2 + w1, y1 + h1, L, x2, y1 + h1,
                    A, w1, h1, 0, 0, 0, x2 + w2, y1 + h, L, x2 + w1, y1 + h1,
                    M, x1 + w1, y + h1, L, x1 + w2, y1 + h,
                    A, w1 + 1, h1 + 1, 0, 0, 0, x1 + w2, y2, Z]);
                    break;
                case 'boxandwhisker2d':
                    path = path.concat([x, y, L, x + w, y, x + w, y + h, x, y + h, Z]);
                    color = item.color;
                    strokeColor = '#000000';
                    break;

                    // A square line for every other request.
                default:
                    path = path.concat([x, y, L, x + w, y, x + w, y + h, x, y + h, Z]);
                    color.FCcolor.angle = 270;
                    color.FCcolor.ratio = '0,70,30';
            }
            return {
                path: path,
                color: color,
                strokeWidth: strokeWidth,
                strokeColor: strokeColor
            };
        }

    });


    /******************************************************************************
     * Raphael Renderer Extension
     ******************************************************************************/

    var Axis = function(axisData, renderer, isVertical, isReverse){
            var axis = this,
                axisData = axis.axisData = axisData || {},
                renderer = axis.renderer = renderer,
                paper = renderer.paper,
                globalOptions = axis.globalOptions = renderer.options,
                layers = renderer.layers,
                plotLines = axisData && axisData.plotLines || [],
                plotBands = axisData && axisData.plotBands || [],
                groupName = isVertical ? "y-axis" : "x-axis",
                upGroup = axis.layerAboveDataset = layers.layerAboveDataset,
                dipGroup = axis.layerBelowDataset = layers.layerBelowDataset,
                uBands = upGroup.bands || (upGroup.bands = []),
                uBandsLen = uBands.length,
                dBands = dipGroup.bands || (dipGroup.bands = []),
                dBandsLen = dBands.length,
                uLines = upGroup.lines || (upGroup.lines = []),
                uLinesLen = uLines.length,
                dLines = dipGroup.lines || (dipGroup.lines = []),
                dLinesLen = dLines.length,
                uLabels = upGroup.labels || (upGroup.labels = []),
                uLabelsLen = uLabels.length,
                dLabels = dipGroup.labels || (dipGroup.labels = []),
                dLabelsLen = dLabels.length,
                realtimeEnabled = renderer.logic.realtimeEnabled;

                axis.isVertical = isVertical;
                //bands
                axis.topBandGroup = axis.topBandGroup ||
                        paper.group(groupName+"-bands", axis.layerAboveDataset);

                axis.belowBandGroup = axis.belowBandGroup ||
                        paper.group(groupName+"-bands", axis.layerBelowDataset);

                uBands.push(axis.topBandGroup);
                uBandsLen && (uBands[uBandsLen].insertAfter(uBands[uBandsLen - 1]));
                dBands.push(axis.belowBandGroup);
                dBandsLen && (dBands[dBandsLen].insertAfter(dBands[dBandsLen - 1]));

                axis.topLineGroup = axis.topLineGroup ||
                        paper.group(groupName+"-lines", axis.layerAboveDataset);

                axis.belowLineGroup = axis.belowLineGroup ||
                        paper.group(groupName+"-lines", axis.layerBelowDataset);

                axis.topLabelGroup = axis.topLabelGroup ||
                        paper.group(groupName+"-labels", axis.layerAboveDataset);

                    axis.belowLabelGroup = axis.belowLabelGroup ||
                        paper.group(groupName+"-labels", axis.layerBelowDataset);

                uLines.push(axis.topLineGroup);
                uLinesLen && (uLines[uLinesLen].insertAfter(uLines[uLinesLen - 1]));
                dLines.push(axis.belowLineGroup);
                dLinesLen && (dLines[dLinesLen].insertAfter(dLines[dLinesLen - 1]));
                uLabels.push(axis.topLabelGroup);
                uLabelsLen && (uLabels[uLabelsLen].insertAfter(uLabels[uLabelsLen - 1]));
                dLabels.push(axis.belowLabelGroup);
                dLabelsLen && (dLabels[dLabelsLen].insertAfter(dLabels[dLabelsLen - 1]));

                axis.isReverse = isReverse;

            this.configure();
        };

        Axis.prototype = {
            configure: function(){
                var axis = this,
                    axisData = axis.axisData,
                    renderer = axis.renderer,
                    isVertical = axis.isVertical,
                    isReverse = axis.isReverse,
                    paper = renderer.paper,
                    options = renderer.options,
                    chartOptions = options.chart,
                    chartLeftMargin = chartOptions.marginLeft,
                    chartTopMargin = chartOptions.marginTop,
                    chartBottomMargin = chartOptions.marginBottom,
                    chartRightMargin = chartOptions.marginRight,
                    //canvas dimention
                    canvasWidth = renderer.canvasWidth,
                    canvasHeight = renderer.canvasHeight,
                    canvasTop = renderer.canvasTop,
                    canvasLeft = renderer.canvasLeft,
                    //start and end pixel of an axis
                    axisMin = axis.min = axisData.min,
                    axisMax = axis.max = axisData.max,
                    span = axis.span = (axisMax - axisMin),
                    axisStartX = axis.startX = pluckNumber(axisData.startX, canvasLeft),
                    axisStartY = axis.startY = pluckNumber(axisData.startY, canvasTop),
                    axisEndX = axis.endX = pluckNumber(axisData.endX, renderer.canvasRight),
                    axisEndY = axis.endY = pluckNumber(axisData.endY, renderer.canvasBottom),
                    startPixel = axis.startPixel = isReverse ?
                                (isVertical ? axisEndY : axisEndX) :
                                    (isVertical ? axisStartY : axisStartX),
                    pixelRatio = axis.pixelRatio = isVertical ?
                            (axisEndY - axisStartY) / span :
                                    (axisEndX - axisStartX) / span,
                    pixelValueRatio = axis.pixelValueRatio = isReverse ?
                                                -pixelRatio : pixelRatio,
                    relatedObjs = axis.relatedObj = {},
                    marginObj = relatedObjs.marginObj = {
                        top: axisStartY,
                        right: chartRightMargin,
                        bottom: chartBottomMargin,
                        left: axisStartX
                    },
                    canvasObj = relatedObjs.canvasObj = {
                        x: axisStartX,
                        y: axisStartY,
                        w: (axisEndX - axisStartX),
                        h: (axisEndY - axisStartY),
                        toX: axisEndX,
                        toY: axisEndY
                    };

                axis.primaryOffset = axis.secondaryOffset= 0;

                axis.cache = {
                    lowestVal: 0,
                    highestVal: 0,
                    indexArr: [],
                    hashTable: {}
                };

                //due to clipping of band elements while scrolling we need to
                //expose the below band group
                axis.elements = axis.elements || {};
                if(axis.belowBandGroup){
                    renderer.elements.axes = renderer.elements.axes || {};
                    renderer.elements.axes.belowBandGroup = axis.belowBandGroup;
                    //apply clip only for scroll charts
                    if(options && options.chart && options.chart.hasScroll){
                        axis.belowBandGroup.attr({
                            'clip-rect': renderer.elements['clip-canvas']
                        });
                    }

                }

                axis.poi = {};

            },
            draw: function(){
                var axis = this,
                    axisData = axis.axisData,
                    plotLines = axisData && axisData.plotLines || [],
                    plotBands = axisData && axisData.plotBands || [],
                    drawPlotLine = axisData && axisData.showLine,
                    tickLength = axisData && axisData.tickLength,
                    tickWidth = axisData && axisData.tickWidth,
                    title = axisData && axisData.title;

                title && axis.drawAxisName();
                plotLines && (plotLines.length > 0) && axis.drawPlotLine();
                plotBands && (plotBands.length > 0) && axis.drawPlotBands();
                //draw tick marks only if tickLength & tickWidth defined
                (!isNaN(tickLength) && tickLength != 0) &&
                        (!isNaN(tickWidth) && tickWidth != 0) && axis.drawTicks();
                //draw lines if axis lines are defined
                drawPlotLine && axis.drawLine();

            },
            scroll: function(){},
            setOffset : function(primaryOffset, secondaryOffset){
                var axis = this,
                    axisStartPixel = isVertical ? axis.startY : axis.startX,
                    axisEndPixel = isVertical ? axis.endY : axis.endX,
                    axisCache = axis.cache,
                    axisIndexedArr = axisCache.indexArr,
                    axisHashTable = axisCache.hashTable,
                    pOffsetVal = axis.primaryOffset = primaryOffset || axis.primaryOffset,
                    sOffsetVal = axis.secondaryOffset = secondaryOffset || axis.secondaryOffset,
                    isVertical = axis.isVertical,
                    newXPos,
                    newYPos,
                    group,
                    groups = [axis.topLabelGroup,
                              axis.belowLabelGroup,
                              axis.topLineGroup,
                              axis.belowLineGroup,
                              axis.topBandGroup,
                              axis.belowBandGroup],
                    i,
                    num,
                    prop,
                    pos,
                    obj,
                    elem;

                //now shift all the available groups of this axis
                //Zero could also be a valid value
                for(i = 0, num = groups.length; i < num; i += 1){
                    group = groups[i];
                    if(group){
                        newXPos = isVertical ? sOffsetVal : pOffsetVal;
                        newYPos = isVertical ? pOffsetVal : sOffsetVal;
                        group.attr({
                            transform: "t"+newXPos+","+newYPos
                        });
                    }
                }

                //Show / hide calculation - only for X-Axis
                

                if(!isVertical){
                    for(prop in axisHashTable){
                        pos = parseFloat(prop) + pOffsetVal;
                        if(pos < axisStartPixel || pos > axisEndPixel){
                            obj = axisHashTable[prop];
                            for(i = 0, num = obj.elements.length; i < num; i += 1){
                                elem = obj.elements[i];
                                elem.attr('visibility') === 'visible' && (elem.attr({visibility: 'hidden'}));
                            }
                        }
                        else if(pos > axisStartPixel && pos < axisEndPixel){
                            obj = axisHashTable[prop];
                            for(i = 0, num = obj.elements.length; i < num; i += 1){
                                elem = obj.elements[i];
                                elem.attr('visibility') === 'hidden' && (elem.attr({visibility: 'visible'}));
                            }
                        }
                    }
                }

            },
            update: function(){},
            drawTicks: function(){
                var axis = this,
                    axisData = axis.axisData,
                    renderer = axis.renderer,
                    paper = renderer.paper,
                    axisMin = axis.min,
                    axisMax = axis.max,
                    isVertical = axis.isVertical,
                    belowDatasetLayer = axis.layerBelowDataset,
                    tickGroup = axis.tickGroup = axis.tickGroup ||
                                        paper.group('axis-ticks', belowDatasetLayer),
                    axisElements = axis.elements || {},
                    canvasObj = axis.relatedObj.canvasObj,
                    axisOffset = axisData.offset,
                    isOpposite = axisData.opposite,
                    showAxis = axisData.showAxis,
                    tickInterval = axisData.tickInterval,
                    tickLength = axisData.tickLength,
                    tickWidth = axisData.tickWidth,
                    tickColor = axisData.tickColor,
                    //not sure about the usage of he below tow properties
                    startOnTick = axisData.startOnTick,
                    endOnTick = axisData.endOnTick,
                    startY,
                    endY,
                    xPos,
                    yPos,
                    tickEndX,
                    axisLineElem,
                    axisTickElem,
                    counter = axisMin;

                //draw the axis line with ticks only if vertical
                if(isVertical && showAxis){
                    startY = axis.getAxisPosition(axisMin);
                    endY = axis.getAxisPosition(axisMax);
                    xPos = !isOpposite ? canvasObj.x - axisOffset :
                                canvasObj.toX + axisOffset;
                    axisLineElem = paper.path(["M", xPos, startY, "L", xPos, endY], tickGroup)
                                    .attr({
                                        stroke: tickColor,
                                        'stroke-width': tickWidth
                                    });

                    while(mathFloor(counter) <= axisMax){
                        yPos = axis.getAxisPosition(counter);
                        tickEndX = !isOpposite ? xPos - tickLength :
                                            xPos + tickLength;
                        axisTickElem = paper.path(["M", xPos, yPos, "L", tickEndX, yPos], tickGroup)
                                .attr({
                                    stroke: tickColor,
                                    'stroke-width': tickWidth
                                });
                        counter += tickInterval;
                    }
                }
            },
            getAxisPosition: function (value, pixelToValue) {
                var axis = this,
                    ret;
                if (pixelToValue) {
                    ret = ((value - axis.startPixel) / axis.pixelValueRatio) +
                        axis.min;
                } else {
                    value = axis.axisData.reversed ? axis.min + (axis.max - value) : value;
                    ret = axis.startPixel + ((value - axis.min) *
                        axis.pixelValueRatio);
                }
                return ret;
            },
            drawPlotLine: function(){
                var axis = this,
                    renderer = axis.renderer,
                    paper = renderer.paper,
                    isVertical = axis.isVertical,
                    isHorizontal = +!isVertical,
                    isReverse  = axis.isReverse,
                    belowLineGroup = axis.belowLineGroup,
                    aboveLineGroup = axis.topLineGroup,
                    belowLabelGroup = axis.belowLabelGroup,
                    aboveLabelGroup = axis.topLabelGroup,
                    plotLines = axis.axisData.plotLines || [],
                    axisLines = axis.lines = axis.lines || [],
                    axisLabels = axis.labels = axis.labels || [],
                    canvasObj = axis.relatedObj.canvasObj,
                    globalOptions = axis.globalOptions || {},
                    axisElements = axis.elements || {},
                    axisCache = axis.cache || {},
                    cacheHashTable = axisCache.hashTable,
                    cacheIndexedArr = axisCache.indexArr,
                    axisStartPixel = isVertical ? axis.startY : axis.startX,
                    axisEndPixel = isVertical ? axis.endY : axis.endX,
                    primaryOffset = axis.primaryOffset,
                    canvasBorderWidth = parseFloat(renderer.canvasBorderWidth) || 0,
                    cacheObj,
                    // tooltip options
                    tooltipOptions = renderer.tooltip || {},
                    isTooltip = tooltipOptions.enabled !== false,
                    toolText,
                    lineElement,
                    labelElement,
                    trackerElement,
                    labelAlign,
                    isLineVisible,
                    plotLineObj,
                    isStackSum,

                    plotLabel,
                    plotLabelText,
                    plotLabelColor,
                    plotLabelStyle,
                    plotLabelFontSize,
                    plotLabelLineHeight,
                    plotLabeloffsetScaleIndex,
                    plotLabelOffsetScale,
                    plotLabelRotation,
                    plotLabelXPos = 0,
                    plotLabelYPos = 0,
                    plotLabelAlign,
                    plotLabelVAlign,
                    plotLabelTextAlign,

                    islabelVisisble,
                    xPos,
                    yPos,
                    toXPos,
                    toYPos,
                    labelXPos,
                    labelYPos,
                    xDepth = globalOptions.chart.xDepth || 0,
                    labelBorderWidth,
                    lineCordStr,
                    isSlanted,
                    isVLine,
                    isTrend,
                    isGrid,
                    plotValue,
                    plotLineColor,
                    plotLineWidth,
                    plotLineDashStyle,
                    plotLineTrendTo,
                    i,
                    num = mathMax(plotLines.length, (mathMax(axisLines.length, axisLabels.length))),
                    lineGroupToAdd,
                    labelGroupToAdd,
                    relatedYAxis,
                    relatedYAxis,
                    textVAlign,
                    keyStr,
                    labelFontSize,
                    labelLineHeight,
                    labelPadding,
                    stackSumLabels = [],
                    sumLength,
                    stackLabelElem,
                    animDuration;

                for (i = 0; i < num; i += 1) {
                    lineElement = labelElement = trackerElement = null;
                    //redife state
                    isLineVisible = 'visible',
                        islabelVisisble = 'visible',
                        //if line exists only update the dynamic attributes
                        lineElement = axisLines[i];
                    labelElement = axisLabels[i];

                    plotLineObj = plotLines[i];
                    plotLineWidth = plotLineObj && plotLineObj.width;

                    plotLabel = plotLineObj && plotLineObj.label;
                    plotLabelStyle = plotLabel && plotLabel.style;

                    //if line does not have any data
                    if (!lineElement && plotLineObj) {
                        //get the group for lines
                        lineGroupToAdd = plotLineObj.zIndex > 3 ? aboveLineGroup : belowLineGroup;
                        //only if width is visible
                        if (plotLineWidth > 0.1) {
                            //create with style as style never changes
                            lineElement = axisLines[i] = paper.path(lineGroupToAdd).css(plotLineObj.style);
                            //store in axis elements
                            axisElements.lines = axisElements.lines || [];
                            axisElements.lines.push(lineElement);
                        }
                    }
                    else if (!plotLineObj && (lineElement || labelElement)) {
                        //line exist but if no data to update; remove it
                        lineElement && lineElement.remove();
                        labelElement && labelElement.remove();
                        axisLines && (axisLines[i] = null);
                        axisLabels && (axisLabels[i] = null);
                        axisElements && axisElements.lines &&
                            (axisElements.lines[i] = null);
                        axisElements && axisElements.labels &&
                            (axisElements.labels[i] = null);
                    }

                    if (plotLineObj) {

                        //creation of label, skip stepped label
                        if (!labelElement && plotLabel && !plotLineObj.stepped) {
                            //we do not create any labels if blank text is passed
                            

                            if (plotLabel.text != BLANK && plotLabel.text != ' ') {
                                //get the group for labels
                                labelGroupToAdd = plotLineObj.zIndex >= 3 ? aboveLabelGroup : belowLabelGroup;
                                labelElement = axisLabels[i] = paper.text(labelGroupToAdd).css(plotLabelStyle);
                                if (lineElement) {
                                    lineElement.label = labelElement;
                                }
                                //store in axis elements
                                axisElements.labels = axisElements.labels || [];
                                axisElements.labels.push(labelElement);
                            }
                        }
                        //check for label removal
                        else if (labelElement) {
                            if (!plotLabel) {
                                labelElement.isRotationSet = false;
                                labelElement.remove();
                                delete labelElement;
                                axisLabels && (axisLabels[i] = null);
                                axisElements && axisElements.labels &&
                                    (axisElements.labels[i] = null);
                            }
                            else if (plotLabel.text === BLANK || plotLabel.text === ' ') {
                                labelElement.isRotationSet = false;
                                labelElement.remove();
                                delete labelElement;
                                axisLabels && (axisLabels[i] = null);
                                axisElements && axisElements.labels &&
                                    (axisElements.labels[i] = null);
                            }
                            else if (plotLineObj && plotLineObj.stepped) {
                                labelElement.isRotationSet = false;
                                labelElement.remove();
                                delete labelElement;
                                axisLabels && (axisLabels[i] = null);
                                axisElements && axisElements.labels &&
                                    (axisElements.labels[i] = null);
                            }

                        }

                        //if line & label both does not exist no need to do further process
                        if (!lineElement && !labelElement) {
                            //remove refernces
                            lineElement = labelElement = null;
                            continue;
                        }

                        if (plotLineObj.value === null) {
                            continue;
                        }
                        if (plotLineObj) {
                            isVLine = plotLineObj.isVline;
                            isTrend = plotLineObj.isTrend;
                            isGrid = plotLineObj.isGrid;
                            toolText = plotLineObj.tooltext;
                            plotValue = plotLineObj.value;
                            plotLineColor = plotLineObj.color;
                            plotLineDashStyle = plotLineObj.dashStyle;
                            plotLineTrendTo = isTrend ? plotLineObj.to : null;
                            isStackSum = plotLineObj._isStackSum;
                        }

                        if (plotLabel) {
                            plotLabelText = plotLabel.text;
                            plotLabelColor = plotLabelStyle && plotLabelStyle.color;
                            plotLabeloffsetScaleIndex = plotLabel.offsetScaleIndex || 0;
                            plotLabelOffsetScale = plotLabel.offsetScale;
                            plotLabelFontSize = plotLabelStyle && plotLabelStyle.fontSize;
                            plotLabelLineHeight = plotLabelStyle && plotLabelStyle.lineHeight;
                            plotLabelRotation = plotLabel.rotation;
                            plotLabelXPos = plotLabel.x || 0;
                            plotLabelYPos = plotLabel.y || 0;
                            plotLabelAlign = plotLabel.align;
                            plotLabelVAlign = plotLabel.verticalAlign;
                            plotLabelTextAlign = plotLabel.textAlign;
                        }


                        //get the font size is defined
                        if (plotLabelFontSize) {
                            labelFontSize = plotLabelFontSize;
                            if (labelFontSize.indexOf("px") !== -1) {
                                labelFontSize = labelFontSize.replace("px", "");
                                labelFontSize = parseFloat(labelFontSize);
                            }
                        }

                        //get the line height if defined
                        if (plotLabelLineHeight) {
                            labelLineHeight = plotLabelLineHeight;
                            if (labelLineHeight.indexOf("px") !== -1) {
                                labelLineHeight = labelLineHeight.replace("px", "");
                                labelLineHeight = parseFloat(labelLineHeight);
                            }
                        }

                        //Logic
                        if (isVertical) {
                            //Y axis calculation
                            yPos = axis.getAxisPosition(plotValue);
                            toYPos = isTrend ? axis.getAxisPosition(plotLineTrendTo) || yPos : yPos;
                            isSlanted = yPos !== toYPos ? true : false;
                            lineCordStr = [M, canvasObj.x, yPos, L, canvasObj.toX, toYPos];
                            if (isVLine) {
                                if (renderer.logic.isBar) {
                                    relatedYAxis = renderer.yAxis[plotLabeloffsetScaleIndex];
                                    if (!isNaN(plotLabelOffsetScale) && plotLabelOffsetScale >= 0 && plotLabelOffsetScale <= 1) {
                                        plotLabelOffsetScale = relatedYAxis.min + (relatedYAxis.max - relatedYAxis.min) * plotLabelOffsetScale;
                                    }
                                    toXPos = relatedYAxis.getAxisPosition(plotLabelOffsetScale || plotValue) + plotLabelXPos;
                                }
                            }
                            else {
                                //in case the plotLabel is not defined // Ex. Log Charts
                                if (plotLabel) {
                                    toXPos = xPos = (axis.axisData.isOpposite || plotLabelAlign === "right") ? canvasObj.toX + plotLabelXPos : canvasObj.x + plotLabelXPos;
                                }
                                else {
                                    toXPos = xPos = (axis.axisData.isOpposite) ? canvasObj.toX : canvasObj.x;
                                }
                            }
                        }
                        else {
                            // X axis calculation
                            

                            xPos = isTrend ? axis.getAxisPosition(plotValue) : axis.getAxisPosition(plotValue) || 0;
                            toXPos = isTrend ? axis.getAxisPosition(plotLineTrendTo) || xPos : xPos;
                            //Need to shift the div lines in Bar3D by xDepth value
                            //Shift only div lines
                            if (!isTrend && !isVLine && xDepth > 0) {
                                xPos += xDepth;
                                toXPos += xDepth;
                                //shift end pixel so that checking works perfect
                                axisEndPixel += xDepth;
                            }
                            isSlanted = (xPos !== toXPos ? true : false);
                            lineCordStr = [M + xPos, canvasObj.y, L, toXPos, canvasObj.toY];
                            //rotated labels need sligh adjustment for x axis end limit calculation
                            //plotLabelRotation && labelFontSize && (axisEndPixel += labelFontSize * 0.5);

                            isLineVisible = ((xPos + primaryOffset) < axisStartPixel || (xPos + primaryOffset) > axisEndPixel) ? 'hidden' : isLineVisible;
                            if (isVLine) {
                                //if no scale index is defined take the first one
                                relatedYAxis = renderer.yAxis[plotLabeloffsetScaleIndex];
                                //PATCH-FIX to get relative positions for Vline Label Postion
                                //This SHOULD HAVE BEEN PASSED AS AN ACTUAL VALUE , BUT THEY ARE PASSED
                                //AS PERCENTAGE BETWEEN 0-1
                                if (!isNaN(plotLabelOffsetScale) && plotLabelOffsetScale >= 0 && plotLabelOffsetScale <= 1) {
                                    plotLabelOffsetScale = relatedYAxis.min + (relatedYAxis.max - relatedYAxis.min) * (1 - plotLabelOffsetScale);
                                }
                                yPos = relatedYAxis.getAxisPosition(plotLabelOffsetScale || plotValue) + plotLabelYPos;
                                //in case of v line boder width should be deducted
                                yPos -= canvasBorderWidth + parseFloat(labelBorderWidth);
                            }
                            else {
                                //this is a very remote use case - when x axis labels are placed on top of canvas
                                if (axis.axisData.opposite || (plotLabelVAlign === 'top' && !isGrid)) {
                                    yPos = canvasObj.y + plotLabelYPos;
                                    textVAlign = 'bottom';
                                }
                                else {
                                    yPos = canvasObj.toY + plotLabelYPos;
                                }
                            }
                            toYPos = yPos;
                        }

                        //update dynamic part
                        if (labelElement) {
                            if (plotLabel && plotLabel.backgroundColor) {
                                plotLabel.labelBgClr = toRaphaelColor({
                                    'color': plotLabel.backgroundColor,
                                    'alpha': plotLabel.backgroundOpacity * 100
                                });
                            }


                            if (plotLabel && plotLabel.borderColor) {
                                plotLabel.labelBorderClr = toRaphaelColor({
                                    'color': plotLabel.borderColor,
                                    'alpha': '100'
                                });
                            }


                            //Now for trend lines depending its position
                            //(left or right) we need to set its y position
                            if (isTrend) {
                                labelYPos = plotLabelAlign === 'left' ? yPos : toYPos;
                            }
                            else {
                                labelYPos = toYPos;
                            }
                            labelXPos = toXPos - ((+!isVLine) * isHorizontal *  xDepth);
                            labelXPos = toXPos - ((+!isVLine) * isHorizontal *  xDepth) +
                                    (isHorizontal * (plotLabelXPos || 0));
                            labelBorderWidth = plotLabel && plotLabel.borderWidth;
                            labelBorderWidth = labelBorderWidth ? labelBorderWidth.indexOf("px") !== -1 ?
                                labelBorderWidth.replace("px", "") : 1 : 1;



                            labelPadding = labelFontSize ? labelFontSize * 0.2 : 2;

                            //We do not have y axis scroll feature
                            islabelVisisble = !isVertical ? ((toXPos + primaryOffset) < axisStartPixel || (toXPos + primaryOffset) > axisEndPixel) ?
                                'hidden' : islabelVisisble :
                                islabelVisisble;

                            labelAlign = plotLabelTextAlign === "left" ? 'start' :
                                plotLabelTextAlign === "right" ? 'end' : 'middle';

                            //All stack sum labels should have a vertical align set
                            //as bottom. Trend (stack100Percent) and Vline both are
                            //used to set stack sum
                            if (isStackSum) {
                                textVAlign = 'bottom';
                                

                                labelYPos += labelFontSize * 0.4;
                                stackSumLabels.push(labelElement);
                            }
                            else if (isHorizontal && axis.axisData.opposite) {
                                //HeatMap chart placeXAxisLabelsOnTop usage
                                textVAlign = POSITION_BOTTOM;
                                labelAlign = plotLabelRotation ? POSITION_START : POSITION_MIDDLE;
                            }
                            else {
                                textVAlign = plotLabelVAlign;
                            }


                            //for multiLine labels the labels should be aligned to top
                            if ((/\n|<br\s*?\/?>/ig).test(plotLabelText) && !plotLabelRotation) {
                                if (isGrid) {
                                    // HeatMap chart placeXAxisLabelsOnTop usage
                                    textVAlign = (isHorizontal &&
                                            axis.axisData.opposite &&
                                            !plotLabelRotation) ?
                                            POSITION_MIDDLE : POSITION_TOP;
                                    //but we also have to match the end of first line
                                    //to match previous implementation
                                    labelYPos -= labelLineHeight;
                                }
                            }


                            //remove all previous applied rotation / transformation
                            labelElement.attr({transform: ' '});
                            labelElement.attr({
                                text: plotLabelText,
                                fill: plotLabelColor || plotLineColor,
                                'text-bound': plotLabel && [plotLabel.labelBgClr, plotLabel.labelBorderClr,
                                    labelBorderWidth,
                                    labelPadding],
                                title: plotLabel && (plotLabel.originalText || ''),
                                x: labelXPos,
                                y: labelYPos,
                                'text-anchor': labelAlign,
                                'vertical-align': textVAlign,
                                visibility: islabelVisisble
                            });
                            if (plotLabelRotation) {
                                labelElement.rotate(plotLabelRotation, labelXPos, labelYPos);
                            }

                            //Cache - required only for scroll charts normally
                            keyStr = isVertical ? labelYPos.toString() : toXPos.toString();
                            cacheObj = cacheHashTable[keyStr];
                            if (!cacheObj) {
                                cacheObj = {
                                    counter: i,
                                    keyProp: keyStr,
                                    elements: [labelElement]
                                };
                                cacheHashTable[keyStr] = cacheObj;
                                cacheIndexedArr.push(cacheObj);
                            }
                            else {
                                cacheObj.elements.push(labelElement);
                            }

                        }


                        if (lineElement) {
                            lineElement.attr({
                                path: getCrispPath(lineCordStr, plotLineWidth),
                                stroke: plotLineColor,
                                'stroke-width': plotLineWidth,
                                'shape-rendering': !isSlanted && plotLineWidth >= 1 ? CRISP : undefined,
                                // Dash gap
                                'stroke-dasharray': plotLineDashStyle ? plotLineDashStyle : undefined,
                                visibility: isLineVisible
                            });
                            if (isTooltip && toolText && plotLineWidth < HTP && isLineVisible) {
                                trackerElement = paper.path(lineCordStr)
                                    .attr({
                                    stroke: TRACKER_FILL,
                                    'stroke-width': HTP,
                                    'ishot': true
                                });
                            }
                            trackerElement = trackerElement || lineElement;
                            isTooltip && trackerElement.tooltip(toolText);
                            //Store - required only for scroll charts normally
                            keyStr = isVertical ? yPos.toString() : xPos.toString();
                            cacheObj = cacheHashTable[keyStr];
                            if (!cacheObj) {
                                cacheObj = {
                                    counter: i,
                                    keyProp: keyStr,
                                    elements: [lineElement]
                                };
                                cacheHashTable[keyStr] = cacheObj;
                                cacheIndexedArr.push(cacheObj);
                            }
                            else {
                                cacheObj.elements.push(lineElement);
                            }
                        }

                        if (plotLineObj && plotLineObj.isMinLabel) {
                            axis.poi.min = {
                                label: labelElement,
                                index: i,
                                line: lineElement
                            };
                        } else if (plotLineObj && plotLineObj.isMaxLabel) {
                            axis.poi.max = {
                                label: labelElement,
                                index: i,
                                line: lineElement
                            };
                        } else if (plotLineObj && plotLineObj.isZeroPlane) {
                            axis.poi.zero = {
                                label: labelElement,
                                index: i,
                                line: lineElement
                            };
                        }
                        //remove refernces
                        lineElement = labelElement = null;
                    }

                }

                //iterate over all stack sum labels and initially hide them
                //show them after the animation complete
                sumLength = stackSumLabels.length;
                animDuration = pluckNumber(renderer.options.plotOptions.series.animation.duration, 0);

                if(sumLength > 0){
                    for(i = 0; i < sumLength; i += 1){
                        stackLabelElem = stackSumLabels[i];
                        stackLabelElem && (function (labelElem){
                            labelElem.hide();
                            setTimeout(function(){
                                labelElem.show();
                            }, animDuration);
                        }(stackLabelElem));
                    }
                }
            },
            drawPlotBands: function(){

                var axis = this,
                    renderer = axis.renderer,
                    paper = renderer.paper,
                    isVertical = axis.isVertical,
                    isReverse  = axis.isReverse,
                    hasScroll = renderer.options.chart.hasScroll,
                    belowBandGroup = axis.belowBandGroup,
                    aboveBandgroup = axis.topBandGroup,
                    belowLabelGroup = axis.belowLabelGroup,
                    aboveLabelGroup = axis.topLabelGroup,
                    plotBands = axis.axisData.plotBands || [],
                    axisBands = axis.bands = axis.bands || [],
                    axisLabels = axis.bandLabels = axis.bandLabels || [],
                    canvasObj = axis.relatedObj.canvasObj,
                    axisElements = axis.elements || {},
                    axisCache = axis.cache || {},
                    cacheHashTable = axisCache.hashTable,
                    cacheIndexedArr = axisCache.indexArr,
                    axisStartPixel = isVertical ? axis.startY : axis.startX,
                    axisEndPixel = isVertical ? axis.endY : axis.endX,
                    primaryOffset = axis.primaryOffset,
                    // tooltip options
                    tooltipOptions = renderer.tooltip || {},
                    isTooltip = tooltipOptions.enabled !== false,
                    toolText,
                    cacheObj,
                    bandElement,
                    isBandVisible,
                    labelElement,
                    isLabelVisible,
                    plotBandObj,
                    plotBandTo,
                    plotBandFrom,
                    plotBandValue,
                    plotBandWidth,
                    plotBandColor,

                    plotLabel,
                    plotLabelStyle,
                    plotLabelBorderWidth,
                    plotLabelAlign,
                    plotLabelX,
                    plotLabelY,
                    plotLabelFontSize,
                    plotLabelLineHeight,
                    plotLabelTextAlign,
                    plotLabelVAlign,
                    plotLabelText,
                    plotLabelOriginalText,
                    plotLabelColor,
                    plotLabelBGColor,
                    plotLabelBGOpacity,
                    plotLabelBorderColor,
                    plotLabelBorderType,
                    plotLabelRaphaelColor,
                    plotLabelRaphaelBorderColor,
                    labelBorderWidth,
                    labelFontSize,
                    labelLineHeight,
                    bandStartX,
                    bandStartY,
                    bandEndX,
                    bandEndY,
                    bandW,
                    bandH,
                    toPx,
                    fromPx,
                    labelXPos,
                    labelYPos,
                    bandGroupToAdd,
                    labelGroupToAdd,
                    i,
                    num = mathMax(plotBands.length, axisBands.length),
                    keyStr;

                for(i = 0; i < num; i += 1){
                    //refresh state
                    isBandVisible = 'visible';
                    isLabelVisible = 'visible';

                    bandElement = axisBands[i];
                    labelElement = axisLabels[i];
                    plotBandObj = plotBands[i];// || {};
                    plotLabel = plotBandObj && plotBandObj.label;
                    plotLabelStyle = plotLabel && plotLabel.style;

                    //if band does not exist create one
                    if(!bandElement && plotBandObj){
                        bandGroupToAdd = plotBandObj.zIndex > 3 ? aboveBandgroup : belowBandGroup;
                        labelGroupToAdd = plotBandObj.zIndex > 3 ? aboveLabelGroup : belowLabelGroup;
                        //create one rect element
                        // No style found on band objects
                        bandElement = axisBands[i] = paper.rect(bandGroupToAdd);
                        //store in axis elements
                        axisElements.bands = axisElements.bands || [];
                        axisElements.bands[i] = bandElement;
                        //create the corresponding label as well
                        if(plotLabel && plotLabel.text){
                            labelElement = axisLabels[i] = bandElement.label = paper.text(labelGroupToAdd).css(plotLabelStyle);
                            //store in axis elements
                            axisElements.labels = axisElements.labels || [];
                            axisElements.labels[i] = labelElement;
                        }
                    }
                    else{
                         //line exist but if no data to update; remove it
                         if(!plotBandObj && bandElement){
                            axisElements.labels && (axisLabels[i] = axisElements.labels[i] = null);
                            bandElement.label && bandElement.label.remove();
                            axisBands[i] = axisElements.bands[i] = null;
                            bandElement.remove();
                            delete bandElement;
                            //terminate further execution
                            continue;
                        }
                    }

                    if(plotBandObj){
                        toolText = plotBandObj.tooltext;
                        plotBandTo = plotBandObj.to;
                        plotBandFrom = plotBandObj.from;
                        plotBandValue = plotBandObj.value;
                        plotBandWidth = plotBandObj.width;
                        plotBandColor = plotBandObj.color;
                    }

                    if(plotLabel){
                        plotLabelFontSize = plotLabelStyle && plotLabelStyle.fontSize;
                        plotLabelLineHeight = plotLabelStyle && plotLabelStyle.lineHeight;
                        plotLabelBorderWidth = plotLabel.borderWidth;
                        plotLabelAlign = plotLabel.align;
                        plotLabelX = plotLabel.x;
                        plotLabelY = plotLabel.y;
                        plotLabelText = plotLabel.text;
                        plotLabelOriginalText = plotLabel.originalText;
                        plotLabelColor = plotLabelStyle && plotLabelStyle.color;
                        plotLabelBGColor = plotLabel.backgroundColor;
                        plotLabelBGOpacity = plotLabel.backgroundOpacity;
                        plotLabelBorderColor = plotLabel.borderColor;
                        plotLabelTextAlign = plotLabel.textAlign;
                        plotLabelVAlign = plotLabel.verticalAlign;
                        plotLabelBorderType = plotLabel.borderType;
                    }


                    //get the font size is defined
                    if(plotLabelFontSize){
                        labelFontSize = plotLabelFontSize;
                        if(labelFontSize.indexOf("px") !== -1){
                            labelFontSize = labelFontSize.replace("px", "");
                            labelFontSize = parseFloat(labelFontSize);
                        }
                    }

                    //get the line height if defined
                    if(plotLabelLineHeight){
                        labelLineHeight = plotLabelLineHeight;
                        if(labelLineHeight.indexOf("px") !== -1){
                            labelLineHeight = labelLineHeight.replace("px", "");
                            labelLineHeight = parseFloat(labelLineHeight);
                        }
                    }

                    //logic
                    // value might come for drawing lines on bands (HeatMap chart implementation)
                    toPx = axis.getAxisPosition(pluckNumber(plotBandTo, plotBandValue));
                    fromPx = axis.getAxisPosition(pluckNumber(plotBandFrom, plotBandValue));
                    bandStartX = (isVertical) ? canvasObj.x : fromPx;
                    bandStartY = (isVertical) ? toPx : canvasObj.y;
                    bandW = (isVertical) ? canvasObj.w : (!axis.axisData.reversed ? toPx - fromPx : fromPx - toPx) || plotBandWidth ||1;
                   // bandH = (isVertical) ? (!axis.axisData.reversed ? fromPx - toPx : toPx - fromPx) || plotBandWidth || 1 : canvasObj.h;
                    bandH = isVertical ? (fromPx - toPx) || 1 : canvasObj.h;
                    bandEndX = bandStartX + bandW;
                    bandEndY = bandStartY + bandH;

                    //to skip runtime error
                    //negative band width & height may fire error
                    bandW = mathAbs(bandW);
                    //bandH = mathAbs(bandH);
                    if(bandH < 0){
                        bandH = mathAbs(bandH);
                        bandStartY -= bandH;
                    }


                    if(!hasScroll){
                        //we do not have y axis scroll
                        isBandVisible = !isVertical ? ((bandStartX + primaryOffset) > axisEndPixel || (bandEndX + primaryOffset) < axisStartPixel) ?
                                                    'hidden' : isBandVisible :
                                                isBandVisible;
                    }
                    else{
                        //in case of scroll charts all bands are visible
                        isBandVisible = true;
                    }


                    if(bandElement){
                        bandElement.attr({
                            x: bandStartX,
                            y: bandStartY,
                            width: bandW,
                            height: bandH,
                            fill: toRaphaelColor(plotBandColor),
                            'stroke-width': 0,
                            visibility: isBandVisible
                        });
                        isTooltip && toolText && bandElement.tooltip(toolText);

                       //Store - required only for scroll charts normally
                       /*keyStr = isVertical ? bandEndY.toString() : bandEndX.toString();
                       cacheObj = cacheHashTable[keyStr];
                       if(!cacheObj){
                            cacheObj = {
                                counter: i,
                                keyProp: keyStr,
                                elements: [bandElement]
                            }
                            cacheHashTable[keyStr] = cacheObj;
                            cacheIndexedArr.push(cacheObj);
                        }
                        else{
                            cacheObj.elements.push(bandElement)
                        }*/

                    }

                    if(labelElement && plotLabel){

                        labelBorderWidth = plotLabelBorderWidth;
                        labelBorderWidth = labelBorderWidth ? labelBorderWidth.indexOf("px") !== -1 ?
                                labelBorderWidth.replace("px", "") : 1 : 1;
                        labelXPos = (isVertical) ? plotLabelAlign === 'right' ? (canvasObj.toX + plotLabelX) :
                                (canvasObj.x + plotLabelX) :
                                (bandStartX + bandW / 2);
                        labelYPos = (isVertical) ? (bandStartY + bandH / 2) : (canvasObj.toY + plotLabelY);

                        //we do not have y axis scrolling
                        isLabelVisible = !isVertical ? ((labelXPos + primaryOffset) < axisStartPixel ||  (labelXPos + primaryOffset) > axisEndPixel) ?
                                                         'hidden' : isLabelVisible :
                                                       isLabelVisible;

                         if(plotLabelBGColor){
                            plotLabelRaphaelColor = plotLabel.labelBgClr = toRaphaelColor({
                                'color': plotLabelBGColor,
                                'alpha': plotLabelBGOpacity * 100
                            });
                        };

                        if(plotLabelBorderColor){
                            plotLabelRaphaelBorderColor = plotLabel.labelBorderClr = toRaphaelColor({
                                'color': plotLabelBorderColor,
                                'alpha': '100'
                            });
                        };

                        plotLabelTextAlign = plotLabelTextAlign === "left" ? 'start' :
                                       plotLabelTextAlign === "right" ? 'end' : 'center';



                        labelElement.attr({
                            text: plotLabelText,
                            title: (plotLabelOriginalText || ''),
                            fill: plotLabelColor,
                            'text-bound': [plotLabelRaphaelColor, plotLabelRaphaelBorderColor,
                                                plotLabelBorderWidth,
                                                (plotLabelFontSize * 0.2),
                                                (plotLabelBorderType === 'solid') ? false : true],
                            x: labelXPos,
                            y: labelYPos,// - labelFontSize,
                            'text-anchor': plotLabelTextAlign,
                            'vertical-align': plotLabelVAlign,
                            visibility: isLabelVisible
                        });

                        //Store - required only for scroll charts normally
                       keyStr = isVertical ? labelYPos.toString() : labelXPos.toString();
                       cacheObj = cacheHashTable[keyStr];
                       if(!cacheObj){
                            cacheObj = {
                                counter: i,
                                keyProp: keyStr,
                                elements: [labelElement]
                            };
                            cacheHashTable[keyStr] = cacheObj;
                            cacheIndexedArr.push(cacheObj);
                        }
                        else{
                            cacheObj.elements.push(labelElement);
                        }

                    }
                }

                //remove refernces
                bandElement = labelElement = null;
            },
            drawAxisName: function(){
                var axis = this,
                    axisData = axis.axisData,
                    axisTitle = axisData.title || {},
                    axisTitleStyle = axisTitle && axisTitle.style,
                    titleAlign = axisTitle.align,
                    centerYAxisName = axisTitle.centerYAxisName || false,
                    paper = axis.renderer.paper,
                    isVertical = axis.isVertical,
                    canvasObj = axis.relatedObj.canvasObj,
                    axisOffset = pluckNumber(axisData.offset, 0),
                    axisDist = axisOffset + pluckNumber(axisTitle.margin, 0),
                    axisName = axisTitle.text || "",
                    axisNameElement = axis.name || undefined,
                    isOpposite = axisData.opposite,
                    belowDatasetLayer = axis.layerBelowDataset,
                    axisNameGroup = belowDatasetLayer.nameGroup = belowDatasetLayer.nameGroup || paper.group('axis-name', belowDatasetLayer),
                    rotation = pluckNumber(axisTitle.rotation, !isOpposite ? 270 : 90),
                    xPos = isVertical ? (isOpposite ? (canvasObj.toX + axisDist) : (canvasObj.x - axisDist)) : ((canvasObj.x + canvasObj.toX) / 2),
                    yPos,
                    fontSize,
                    axisTitleColor,
                    backgroundColor,
                    border,
                    borderUnits,
                    borderColor,
                    borderType,
                    borderWidth;

                if(axisTitleStyle){
                    axisTitleColor = axisTitleStyle.color;
                    backgroundColor = toRaphaelColor({
                        'color': axisTitleStyle.backgroundColor,
                        'alpha': 100
                    });
                    borderColor = toRaphaelColor({
                        'color': axisTitleStyle.borderColor,
                        alpha: 100
                    })
                    border = axisTitleStyle.border;
                    borderUnits = border && border.split(" ");

                    if(borderUnits && borderUnits.length > 0){
                         borderWidth = borderUnits[0].indexOf("px") != -1 ?
                        parseFloat(borderUnits[0].replace("px", "")) :
                                parseFloat(borderUnits[0]);
                        borderType = (borderUnits.length > 0) && borderUnits[1];
                    }
                }

                if(isVertical){
                    if(titleAlign === "low"){
                        yPos = canvasObj.toY;
                    }
                    else{
                        if(centerYAxisName){
                            yPos = (canvasObj.y + canvasObj.toY) / 2;
                        }else{
                            yPos = axis.renderer.chartHeight / 2;
                        }

                    }
                }
                else {
                    yPos = canvasObj.toY + axisDist;
                }

                //If name does not exist; create one
                if(!axisNameElement && axisName){
                    axisNameElement = axis.name = paper.text(axisNameGroup).css(axisTitle.style);
                }
                else{
                    //no eist but no data to update; remove the name
                    if(!axisName && axisNameElement){
                        axisNameElement.remove();
                    }
                }
                // in case of rotated vertical axis names & to match the default SVG
                // first line base as the YPos need to shift one line
                // no need to manage if rotation is 0.
                if(!isNaN(rotation) &&  rotation && isVertical){
                    fontSize = axisTitle.style.fontSize;
                    fontSize = fontSize.indexOf("px") != -1 ? fontSize.replace("px", "") : fontSize;
                    xPos = isOpposite ? xPos + parseFloat(fontSize) : xPos - parseFloat(fontSize);
                }
                //if element exist update.
                if(axisNameElement){
                    axisNameElement.attr({
                        text: axisName,
                        title: (axisTitle.originalText || ''),
                        fill: axisTitleColor || "#000000",
                        'text-bound': [backgroundColor, borderColor,
                                       borderWidth, (fontSize * 0.1)],
                        'text-anchor': titleAlign === "low" ?
                                    !isOpposite ? 'start' : 'end' :
                                            'middle',
                        'vertical-align': isVertical ? !rotation ? 'middle' : 'top' : isOpposite ? POSITION_BOTTOM : 'top',
                        transform: isVertical ? "t" + xPos + "," + yPos + "r" + rotation : "t" + xPos + "," + yPos
                    });
                }
                //store to elements
                axis.elements.name = axisNameElement;
            },
            drawLine: function(){
                var axis = this,
                      axisData = axis.axisData,
                      renderer = axis.renderer,
                      paper = renderer.paper,
                      axisMin = axis.min,
                      axisMax = axis.max,
                      isVertical = axis.isVertical,
                      isOpposite = axisData.opposite,
                      belowDatasetLayer = axis.layerBelowDataset,
                      axisLineGroup = axis.lineGroup = axis.lineGroup ||
                                          paper.group('axis-lines', belowDatasetLayer),
                      lineColor = axisData.lineColor,
                      lineThickness = axisData.lineThickness,
                      axisElements = axis.elements || {},
                      canvasObj = axis.relatedObj.canvasObj,
                      startY,
                      endY,
                      startX,
                      endX,
                      axisLineElem;

                //draw the axis lines
                if(isVertical){
                    startY = axis.getAxisPosition(axisMin);
                    endY = axis.getAxisPosition(axisMax);
                    //@todo: here we need to add the line padding
                    startX = endX = !isOpposite ? canvasObj.x : canvasObj.toX;
                }else{
                    startX = canvasObj.x;
                    endX = canvasObj.toX;
                    startY = endY = !isOpposite ? canvasObj.toY : canvasObj.y;
                }

                axisLineElem = paper.path(["M", startX, startY, "L", endX, endY], axisLineGroup)
                                      .attr({
                                          stroke: lineColor,
                                          'stroke-width': lineThickness
                                      });

                //store to elements
                axis.elements.axisLine = axisLineElem;
            },
            /*
             * update the drawing of the x axis during realtime update
             */
            realtimeUpdateX: function (shift) {
            if (shift > 0) {
                var axis = this,
                    axisData = axis.axisData,
                    plotBands = axisData.plotBands,
                    plotLines = axisData.plotLines,
                    min = axis.min,
                    virtualMin = min + shift,
                    plotElement,
                    ln,
                    i = plotBands.length,
                    xVal;
                //remove or reposition old bands
                while (i--) {
                    if ((plotElement = plotBands[i])) {
                        //do not shift divlines calcuted by numdivlines
                        if (!plotElement.isNumVDIV) {
                            //if this element would be removed
                            if (plotElement.value < virtualMin ||
                                plotElement.from < virtualMin || plotElement.to < virtualMin) {
                                plotBands.splice(i, 1);
                            }
                            else {//else change the position
                                if (plotElement.value !== undefined) {
                                    plotElement.value -= shift;
                                }
                                if (plotElement.from !== undefined) {
                                    plotElement.from -= shift;
                                }
                                if (plotElement.to !== undefined) {
                                    plotElement.to -= shift;
                                }
                            }
                        }
                    }
                }
                i = plotLines.length;
                axis.drawPlotLine();
                axis.drawPlotBands();

            }

        },
            realtimeUpdateY: function (newMin, newMax){
                var axis = this,
                    axisData = axis.axisData,
                    axisMin = axis.min = axisData.min = newMin,
                    axisMax = axis.max = axisData.max = newMax,
                    span = axis.span = (axisMax - axisMin),
                    pixelRatio = axis.pixelRatio = axis.isVertical ? axis.relatedObj.canvasObj.h / span : axis.relatedObj.canvasObj.w / span;
                    axis.pixelValueRatio = axis.isReverse ? -pixelRatio : pixelRatio;
                axis.drawPlotLine();
                axis.drawPlotBands();
            }
        };

        Axis.prototype.constructor = Axis;



    /**
    * Function that returns the arcTangent of a mouse-click with respect to a point.
    * @param {Array} center has the x,y point for which the tangent has to be
    * calculated.
    * @param {object} ref is the reference frame ofsset w.r.t the current page.
    * {left, top}
    */
    var getClickArcTangent = function (x, y, center, ref) {
           return mathATan2(y - center[1] - ref.top, x - center[0] - ref.left);
        };



    renderer('renderer.cartesian', {
        drawCanvas: function() {
            var chart = this,
                options = chart.options,
                optionsChart = options.chart || {},
                canvasBgColor = optionsChart.plotBackgroundColor,
                paper = chart.paper,
                elements = chart.elements,
                canvas = elements.canvas,
                canvas3DBase = elements.canvas3DBase,
                canvas3dbaseline = elements.canvas3dbaseline,
                canvasBorder = elements.canvasBorder,
                canvasBg = elements.canvasBg,
                canvasTop = chart.canvasTop,
                canvasLeft = chart.canvasLeft,
                canvasWidth = chart.canvasWidth,
                canvasHeight = chart.canvasHeight,
                canvasBorderRadius = pluckNumber(optionsChart.plotBorderRadius, 0),
                canvasBorderWidth = optionsChart.plotBorderWidth,
                borderWHlf = canvasBorderWidth * 0.5,
                canvasBorderColor = optionsChart.plotBorderColor,
                isBar = optionsChart.isBar,
                is3D = optionsChart.is3D,
                showCanvasBg = optionsChart.showCanvasBg,
                canvasBgDepth = optionsChart.canvasBgDepth,
                showCanvasBase = optionsChart.showCanvasBase,
                canvasBaseColor3D = optionsChart.canvasBaseColor3D,
                canvasBaseDepth = optionsChart.canvasBaseDepth,

                shadow = optionsChart.plotShadow,
                shadowOnCanvasFill = isVML && canvasBorderWidth === 0 &&
                        shadow && shadow.enabled,

                xDepth = optionsChart.xDepth || 0,
                yDepth = optionsChart.yDepth || 0,

                layers = chart.layers,
                backgroundLayer = layers.background,
                datasetlayer = layers.dataset,
                trackerLayer = layers.tracker = layers.tracker ||
                        paper.group('hot').insertAfter(datasetlayer),
                dataLabelLayer = layers.datalabels = layers.datalabels ||
                        paper.group('datalabels').insertAfter(datasetlayer),
                canvasLayer = layers.canvas = layers.canvas ||
                        paper.group('canvas').insertAfter(backgroundLayer);


            if (!canvasBorder) {
                canvasBorder = elements.canvasBorder = paper.rect(canvasLeft - borderWHlf,
                    canvasTop - borderWHlf, canvasWidth + canvasBorderWidth,
                    canvasHeight + canvasBorderWidth, canvasBorderRadius, canvasLayer)
                    .attr({
                    'stroke-width': canvasBorderWidth,
                    stroke: canvasBorderColor,
                    'stroke-linejoin': canvasBorderWidth > MAX_MITER_LINEJOIN ?
                                                        'round' : 'miter'
                })
                .shadow(shadow);

            }

            // create a clip-rect to clip canvas for later use
           elements["clip-canvas"] = [
                mathMax(0, canvasLeft - xDepth),
                mathMax(0, canvasTop - yDepth),
                mathMax(1, canvasWidth  + xDepth * 2),
                mathMax(1, canvasHeight + yDepth * 2)
            ];
            elements["clip-canvas-init"] = [
                mathMax (0, canvasLeft - xDepth),
                mathMax (0, canvasTop - yDepth),
                1,
                mathMax (1, canvasHeight + yDepth * 2)
            ];

            if (is3D) {
                if (showCanvasBg) {
                    // Vertical 3D Base
                    if (isBar) {

                        canvasBg = elements.canvasBg = paper.path([
                                M, canvasLeft, COMMA, canvasTop,
                                L, (canvasLeft + (canvasBgDepth * 1.2)),
                                    COMMA, (canvasTop - canvasBgDepth), COMMA,
                                (canvasLeft + canvasWidth - canvasBgDepth), COMMA,
                                    (canvasTop - canvasBgDepth), COMMA,
                                (canvasLeft + canvasWidth), COMMA, canvasTop,
                                Z
                            ], canvasLayer);
                    }
                    // Horizontal 3D Base
                    else {
                        canvasBg =
                            elements.canvasBg = paper.path([
                                M, (canvasLeft + canvasWidth),COMMA, canvasTop,
                                L, (canvasLeft + canvasWidth + canvasBgDepth), COMMA,
                                    (canvasTop + (canvasBgDepth * 1.2)), COMMA,
                                (canvasLeft + canvasWidth + canvasBgDepth), COMMA,
                                    (canvasTop + canvasHeight - canvasBgDepth), COMMA,
                                (canvasLeft + canvasWidth), COMMA, (canvasTop + canvasHeight),
                                Z
                            ], canvasLayer);
                    }
                    canvasBg.attr({
                        'stroke-width': 0,
                        'stroke': NONE,
                        fill: toRaphaelColor(canvasBgColor)
                    });

                }

                if (showCanvasBase) {
                    if (isBar) {
                        canvas3DBase = elements.canvas3DBase = paper.cubepath(
                                canvasLeft - xDepth - canvasBaseDepth - 1,
                                canvasTop + yDepth + 1,
                                canvasBaseDepth,
                                canvasHeight,
                                xDepth + 1,
                                yDepth + 1,
                                canvasLayer);
                    }
                    else {
                        canvas3DBase = elements.canvas3DBase = paper.cubepath(
                                canvasLeft - xDepth - 1,
                                canvasTop + canvasHeight + yDepth + 1,
                                canvasWidth,
                                canvasBaseDepth,
                                xDepth + 1,
                                yDepth + 1,
                                canvasLayer);
                    }
                    canvas3DBase.attr({
                        'stroke': NONE,
                        'stroke-width': 0,
                        'fill': canvasBaseColor3D.replace(dropHash, HASHSTRING)
                    });

                    if (!canvas3dbaseline) { // to give 3d feel
                        canvas3dbaseline = elements.canvas3dbaseline =
                                paper.path(undefined, canvasLayer);
                    }

                    canvas3dbaseline.attr({
                        path: isBar ? [M, canvasLeft, canvasTop, V, canvasHeight + canvasTop] :
                                [M, canvasLeft, canvasTop + canvasHeight,
                                H, canvasWidth + canvasLeft],
                        stroke: R.tintshade(canvasBaseColor3D.replace(dropHash, HASHSTRING), .05).rgba
                    });
                }

            }

            if (!canvas) {
                if (canvasBgColor) {
                    canvas = elements.canvas = paper.rect(canvasLeft,
                        canvasTop, canvasWidth, canvasHeight,
                        canvasBorderRadius, canvasLayer)
                        .attr({
                            'stroke-width': 0,
                            'stroke': NONE,
                            fill: toRaphaelColor(canvasBgColor)
                        })
                        .shadow(shadowOnCanvasFill);

                }

            }

        },

        drawAxes: function () {
            var chart = this,
                chartisan,
                logic = chart.logic,
                options = chart.options,
                paper = chart.paper,
                layers = chart.layers,
                datasetLayer = layers.dataset,
                layerBelowDataset = layers.layerBelowDataset = layers.layerBelowDataset ||
                                            paper.group('axisbottom'),
                layerAboveDataset = layers.layerAboveDataset = layers.layerAboveDataset ||
                                            paper.group('axistop'),
                xAxis = chart.xAxis = [],
                yAxis = chart.yAxis = [],
                i,
                l;

            layerBelowDataset.insertBefore(datasetLayer);
            layerAboveDataset.insertAfter(datasetLayer);

            if (options.xAxis && options.xAxis.length) {
                for (i = 0, l = options.xAxis.length; i < l; i += 1) {
                    xAxis[i] = chart.xAxis[i] = new Axis(options.xAxis[i],
                        chart, logic.isBar);
                }
            } else {
                xAxis[0] = chart.xAxis[0] = new Axis(options.xAxis, chart,
                    logic.isBar);
            }

            

            if (options.yAxis) {
                for (i = 0, l = options.yAxis.length; i < l; i += 1) {
                    yAxis[i] = chart.yAxis[i] = new Axis(
                            options.yAxis[i],
                            chart,
                            !logic.isBar,
                            !logic.isBar);
                }
            }

            //render all Y axis first
            for(i = 0, l = yAxis.length; i < l; i += 1) {
                yAxis[i].draw();
            }
            //render all X axis
            for(i = 0, l = xAxis.length; i < l; i += 1) {
                xAxis[i].draw();
            }
        },

        drawScroller: function() {

            var chart = this,
                options = chart.options,
                paper = chart.paper,
                layers = chart.layers,
                axis = chart.xAxis['0'] || {},

                axisData = axis['axisData'] || {},
                scroll = axisData['scroll'] || {},
                canvasTop = chart.canvasTop,
                canvasLeft = chart.canvasLeft,
                canvasWidth = chart.canvasWidth,
                canvasHeight = chart.canvasHeight,
                canvasBorderWidth = chart.canvasBorderWidth,
                canvasBorderPadding = mathMin(canvasBorderWidth, 2),

                // actual scale
                fullCanvasWidth,
                windowedCanvasWidth,
                offset,
                // scroll properties
                ratio,
                startPercent,
                viewMax,
                viewMin,
                vxLength,
                vxLengthCeil,
                buttonPadding,
                buttonWidth,
                height,
                padding,
                color,
                scrollDisplayStyle,
                scrollBar3DLighting,

                reflowData,
                reflowUpdate,
                reflowScroll,

                datasetGroup = layers.dataset,
                datalabelsGroup = layers.datalabels,
                hotGroup = layers.tracker,
                referenceLayer = layers.layerAboveDataset,
                scrollLayer,
                i;

                if (scroll.enabled) {
                   scrollLayer = layers.scroll = layers.scroll ||
                        paper.group('scroll').insertAfter(referenceLayer),

                    ratio = scroll.scrollRatio;
                    startPercent = pluckNumber(options[CONFIGKEY].xAxisScrollPos,
                            scroll.startPercent);
                    viewMax = scroll.viewPortMax;
                    viewMin = scroll.viewPortMin;
                    vxLength = scroll.vxLength;
                    vxLengthCeil = mathCeil(vxLength);
                    buttonPadding = scroll.buttonPadding;
                    buttonWidth = scroll.buttonWidth;
                    height = scroll.height;
                    padding = scroll.padding;
                    color = scroll.color;
                    scrollDisplayStyle = scroll.flatScrollBars;
                    scrollBar3DLighting = scroll.scrollBar3DLighting;
                    windowedCanvasWidth = scroll.windowedCanvasWidth =
                            axis.getAxisPosition(vxLength);
                    fullCanvasWidth = scroll.fullCanvasWidth =
                            axis.getAxisPosition(viewMax - viewMin)
                                - windowedCanvasWidth,
                    offset = mathRound(startPercent * fullCanvasWidth);

                    reflowData = chart.fusionCharts.jsVars._reflowData;
                    reflowUpdate = {hcJSON: { _FCconf: { xAxisScrollPos: 0 }}};
                    reflowScroll = reflowUpdate.hcJSON._FCconf;


                    layers.scroller = paper.scroller(
                            canvasLeft - canvasBorderPadding,
                            canvasTop + canvasHeight + padding,
                            canvasWidth + canvasBorderPadding * 2,
                            height, true, {
                                showButtons: true,
                                displayStyleFlat: scrollDisplayStyle,
                                buttonWidth: buttonWidth,
                                scrollRatio: ratio,
                                scrollPosition: startPercent
                            },
                            scrollLayer)

                        .data ("fullCanvasWidth", fullCanvasWidth)
                        .data ("windowedCanvasWidth", windowedCanvasWidth)
                        .attr({
                            'scroll-display-style': scrollDisplayStyle,
                            'fill': color
                        })

                        .scroll(function (pos) {
                            offset = - mathRound(pos * fullCanvasWidth);
                            datasetGroup && datasetGroup.transform(['T', offset, 0]);
                            datalabelsGroup && datalabelsGroup.transform(['T',offset, 0]);
                            hotGroup && hotGroup.transform(['T',offset, 0]);
                            axis.setOffset && axis.setOffset(offset);
                            // save state
                            scrollStateObj = {
                                    position: pos,
                                    direction: pos - scroll.lastPos || 0,
                                    vxLength: vxLengthCeil
                                };

                             reflowScroll.xAxisScrollPos = scroll.lastPos = pos;
                             extend2(reflowData, reflowUpdate, true);

                             if (scrollStateObj.direction !== 0) {
                                for (i = 0; i < chart.datasets.length; i++) {
                                    chart[chart.datasets[i].drawPlot + "Scroll"] &&
                                    chart[chart.datasets[i].drawPlot + "Scroll"]
                                        .call(chart,
                                            chart.plots[i],
                                            chart.datasets[i],
                                            scrollStateObj
                                        );
                                }
                             }
                        });


                }
                return scroll.enabled;
        },

        finalizeScrollPlots: function () {
            var chart = this,
                options = chart.options,
                container = chart.container,
                elements = chart.elements,

                layers = chart.layers,
                scroller = layers.scroller,
                datasetGroup = layers.dataset,
                datalabelsGroup = layers.datalabels,
                hotGroup = layers.tracker,
                chartPosition,
                config = {},
                touchScrollBodyEventHandler,
                canvasLeft = chart.canvasLeft,
                canvasRight = chart.canvasRight,
                canvasTop = chart.canvasTop,
                canvasBottom = chart.canvasBottom,
                isDraggedInsideCanvas,

                axis = chart.xAxis['0'] || {},
                axisData = axis['axisData'] || {},
                scroll = axisData['scroll'] || {},
                startPercent = pluckNumber(options[CONFIGKEY].xAxisScrollPos,
                            scroll.startPercent),

                // actual scale
                fullCanvasWidth = scroll.fullCanvasWidth,
                offset,
                // scroll properties
                viewMax,
                viewMin,
                vxLength;

                if (scroll.enabled) {
                    datasetGroup.attr ({
                        'clip-rect': elements["clip-canvas"]
                    });

                    datalabelsGroup.attr ({
                        'clip-rect': elements["clip-canvas"]
                    });

                    hotGroup.attr ({
                        'clip-rect': elements["clip-canvas"]
                    });


                    touchScrollBodyEventHandler = function (event) {

                        var canvas = chart.elements.canvas,
                            chartPosLeft = chartPosition.left,
                            chartPosTop = chartPosition.top,

                            type = event.type,
                            touchEvent = (hasTouch && lib.getTouchEvent(event)) ||
                                stubEvent,

                            layerX = (event.layerX || touchEvent.layerX) ||
                                ((event.pageX || touchEvent.pageX) - chartPosLeft),
                            layerY = (event.layerY || touchEvent.layerY) ||
                                ((event.pageY || touchEvent.pageY) - chartPosTop),

                            dx;

                        switch (type) {
                            case DRAGSTART: // DragStart
                                isDraggedInsideCanvas = canvas.isPointInside(layerX, layerY);
                                config.ox = isDraggedInsideCanvas && layerX || null;
                                if (!isDraggedInsideCanvas) {
                                    return false;
                                }
                            break;

                            case DRAGEND:  // DragEnd
                                isDraggedInsideCanvas = false;
                                config = {};
                            break;

                            default: // DragMove
                                if (!isDraggedInsideCanvas) {
                                    return;
                                }

                                dx = layerX - config.ox;
                                config.ox = layerX;
                                config.scrollPosition = scroller.attrs['scroll-position']
                                        - dx / fullCanvasWidth;
                                scroller.attr({
                                    'scroll-position': config.scrollPosition
                                });

                            break;
                        }

                    };
                    // bind touch scroll on canvas
                    if (hasTouch) {
                        chartPosition = lib.getPosition(container);

                        if (container) {
                            removeEvent(container, 'dragstart drag dragend', touchScrollBodyEventHandler);
                            addEvent(container, 'dragstart drag dragend', touchScrollBodyEventHandler);
                        }
                    }

                    // offset layers based on scroll initial position
                    if (startPercent > 0) {
                        offset =  - mathRound(startPercent * fullCanvasWidth);
                        datasetGroup && datasetGroup.transform(['T',offset, 0]);
                        datalabelsGroup && datalabelsGroup.transform(['T',offset, 0]);
                        hotGroup && hotGroup.transform(['T',offset, 0]);
                        axis.setOffset && axis.setOffset(offset);
                    }

                }

        },


        drawPlotColumn: function (plot, dataOptions, sconfig) {
            var chart = this,
                data = plot.data,
                ln = data.length,
                plotItems = plot.items,
                plotIndex = plot.index,
                datasetGraphics = plot.graphics || (plot.graphics = []),
                paper = chart.paper,
                plots = chart.plots,
                logic = chart.logic,
                layers = chart.layers,
                options = chart.options,
                elements = chart.elements,
                chartOptions = options.chart,

                // tooltip options
                tooltipOptions = options.tooltip || {},
                isTooltip = tooltipOptions.enabled !== false,
                toolText,

                // Directly Accessing chart definition JSON Data
                chartAttributes = chart.definition.chart,
                seriesOptions = options.plotOptions.series,
                xAxis = chart.xAxis[dataOptions.xAxis || 0],
                yAxis = chart.yAxis[dataOptions.yAxis || 0],

                // is inverse chart
                isInverseAxis = yAxis.axisData.reversed,

                // is log chart
                isLog = logic.isLog,


                // is 3D
                is3D = logic.is3D,

                // is stacked chart
                isStacked = logic.isStacked,

                // is waterfall
                isWaterfall = logic.isWaterfall,

                // is candlestick
                isCandleStick = logic.isCandleStick,

                // is scroll chart
                scrollObj = pluck(xAxis['axisData']['scroll'], {}),
                scrollConfig = sconfig || {},
                isScroll =  scrollObj.enabled,
                scrollPosition = pluckNumber(scrollConfig.position,
                            options[CONFIGKEY].xAxisScrollPos,
                            scrollObj.startPercent),
                scrollVxLength = scrollConfig.vxLength || mathCeil(scrollObj.vxLength),
                scrollStart = scrollConfig.scrollStart ||
                        mathMax(0, mathRound((ln - scrollVxLength) *
                                            scrollPosition) - 1) || 0,
                scrollEnd = scrollConfig.scrollEnd ||
                        mathMin(ln, scrollStart + scrollVxLength + 2) || ln,

                canvasBorderOpacity = chartOptions.canvasBorderOpacity =
                    R.color(chartOptions.plotBorderColor).opacity,

                canvasBorderWidth = chart.canvasBorderWidth,
                hasValidCanvasBorder = chartOptions.isCanvasBorder =
                            canvasBorderOpacity !== 0 && canvasBorderWidth > 0,

                columnBaseHotFixDelta,
                // chart name
                chartName = getSentenceCase(logic.name),

                animationDuration = sconfig !== UNDEFINED ? 0 :
                    isNaN(+seriesOptions.animation) &&
                        seriesOptions.animation.duration ||
                        seriesOptions.animation * 1000,

                numColumns = dataOptions.numColumns || 1,
                columnPosition = dataOptions.columnPosition || 0,

                use3DLighting = chartOptions.use3DLighting,
                seriesVisibility = dataOptions.visible === false ?
                        'hidden': 'visible',
                overlapColumns = chartOptions.overlapColumns,

                xAxisZeroPos = xAxis.getAxisPosition(0),
                xAxisFirstPos = xAxis.getAxisPosition(1),
                groupMaxWidth = xAxisFirstPos - xAxisZeroPos,
                definedGroupPadding = chartAttributes &&
                        chartAttributes.plotspacepercent,
                definedMaxColWidth = chartAttributes.maxcolwidth,
                plotPaddingPercent = pluckNumber(chartAttributes &&
                            chartAttributes.plotpaddingpercent),
                groupPadding = seriesOptions.groupPadding,
                maxColWidth = seriesOptions.maxColWidth,
                groupNetWidth = (1 - definedGroupPadding * .01) * groupMaxWidth ||
                    mathMin(
                        groupMaxWidth * (1 - groupPadding * 2),
                        maxColWidth * numColumns
                    ),
                groupNetHalfWidth = groupNetWidth / 2,
                columnWidth = groupNetWidth / numColumns,
                plotPadding = numColumns > 1 ?
                            !overlapColumns && plotPaddingPercent === UNDEFINED ?
                                4:
                                plotPaddingPercent > 0 ? (columnWidth * plotPaddingPercent / 100) : 0
                            : 0,
                plotEffectivePadding = mathMin(columnWidth - 1, plotPadding),
                xPosOffset = (columnPosition * columnWidth) - groupNetHalfWidth
                            + plotEffectivePadding / 2,

                yMax = yAxis.max,
                yMin = yAxis.min,
                isAllPositive = yMax > 0 && yMin > 0,
                isAllPositiveZero = yMax > 0 && yMin >= 0,
                isAllNegative = yMax < 0 && yMin < 0,
                isAllNegativeZero = yMax <= 0 && yMin < 0,
                isPositiveNegative = yMax > 0 && yMin < 0,

                yBase = isAllNegativeZero ||
                            (isInverseAxis && isAllPositiveZero)  ? yMax :
                        isLog || isAllPositiveZero ? yMin : 0,

                yBasePos = yAxis.yBasePos = yAxis.getAxisPosition(yBase),

                plotRadius = pluckNumber(chartOptions.useRoundEdges, 0),

                placeValuesInside = chartOptions.placeValuesInside,
                style = seriesOptions.dataLabels.style,
                rotateValues = chartOptions.rotateValues === 1 ? 270 : 0,
                valuePadding = chartOptions.valuePadding + GUTTER_2,

                datasetLayer = layers.dataset = layers.dataset ||
                        paper.group('dataset-orphan'),
                dataLabelsLayer = layers.datalabels = layers.datalabels ||
                            paper.group('datalabels').insertAfter(datasetLayer),
                trackerLayer = layers.tracker,

                canvasTop = chart.canvasTop,
                canvasLeft = chart.canvasLeft,
                canvasWidth = chart.canvasWidth,
                canvasHeight = chart.canvasHeight,
                canvasBottom = chart.canvasBottom,
                canvasRight = chart.canvasRight,

                // Zero plane settings
                zeroPlaneColor,
                zeroPlaneBorderColor,

                MINHEIGHT = 1,
                xDepth,
                yDepth,
                yAdjust,
                colBBox,
                textHeight,
                insideColSpace,
                outsideColSpace,
                textY,
                textX,
                lineHeight = pInt(style.lineHeight, 10),
                bBoxObj,
                isNegative,
                valueBelowPlot,
                displayValue,
                plotItem,
                i,
                set,
                setLink,
                setBorderWidth,
                x,
                y,
                previousY,
                xPos,
                yPos,
                previousYPos,
                valEle,
                height,
                width,

                // marimekko variables
                fixedWidth,
                fixedXPosOffset,

                origTextHeight,
                setElem,
                hotElem,

                clickEventHandler,
                hoverEventHandler,
                group,
                plotGroup,
                plotNegativeGroup,
                plotNegativeGroupArray,
                zeroPlaneGroup,
                plotPositiveGroup,
                plotPositiveGroupArray,
                targetGroup,
                shadowGroup,
                labelAttr,
                crispBox;

            // hide the data labels group. Will be visible after animation completes
            !sconfig && dataLabelsLayer.hide();

            // adjust column width based on plotPadding
            columnWidth = columnWidth - plotEffectivePadding;

            //adjust scroll start
            if (isScroll && scrollStart > scrollEnd - scrollVxLength - 2) {
                scrollStart = mathMax(0, scrollEnd - scrollVxLength - 2);
            }

            // define groups
            group = datasetLayer;
            if (isStacked) {
                shadowGroup = group.shadows || (group.shadows = paper.group('shadows', group).toBack());
            }

            plotGroup = group.column || (group.column = paper.group('columns', group));

            // clip column inside canvas
            if (!isCandleStick && !is3D && !isScroll){
                if (!plotGroup.attrs['clip-rect']) {
                    plotGroup.attr({
                        'clip-rect': elements["clip-canvas"]
                    });
                }
            }

            // put column group below connector line group in waterfall chart
            if (isWaterfall) {
                plotGroup.toBack();
            }
            // Assign target group(s)
            // In 3D chart separate groups for positive and negative values
            // Additionally draw 3D Zero Plane if 3D
            if (is3D) {

                xDepth = chartOptions.xDepth || 0;
                yDepth = chartOptions.yDepth || 0;

                plotNegativeGroup = plotGroup.negative =
                    (plotGroup.negative || paper.group('negative-values', plotGroup));

                plotPositiveGroup = plotGroup.column =
                    (plotGroup.column || paper.group('positive-values', plotGroup));

                // Draw zero plane
                zeroPlaneGroup = plotGroup.zeroPlane;
                if (!zeroPlaneGroup && yMin < 0 && yMax >= 0) {

                    zeroPlaneGroup = plotGroup.zeroPlane =
                            paper.group('zero-plane', plotGroup)
                                .insertBefore(plotPositiveGroup);

                    zeroPlaneColor = chartOptions.zeroPlaneColor;
                    zeroPlaneBorderColor = chartOptions.zeroPlaneBorderColor;

                    elements.zeroplane = paper.cubepath(
                        canvasLeft - xDepth, yBasePos + yDepth,
                        canvasWidth, MINHEIGHT, xDepth, yDepth,
                        zeroPlaneGroup
                    )
                    .attr({
                        'fill' : [zeroPlaneColor, !use3DLighting],
                        'stroke' : NONE,
                        'stroke-width': 1
                    });

                }


                if (!(plotNegativeGroupArray = plotNegativeGroup.data('categoryplots'))) {
                    plotNegativeGroup.data('categoryplots', Array(ln));
                    plotNegativeGroupArray = plotNegativeGroup.data('categoryplots');
                }
                if (!(plotPositiveGroupArray = plotPositiveGroup.data('categoryplots'))) {
                    plotPositiveGroup.data('categoryplots', Array(ln));
                    plotPositiveGroupArray = plotPositiveGroup.data('categoryplots');

                }

                for (i = 0; i < ln; i += 1) {
                    plotNegativeGroupArray[i] = plotNegativeGroupArray[i] ||
                        paper.group(plotNegativeGroup);
                    plotPositiveGroupArray[i] = plotPositiveGroupArray[i] ||
                        paper.group(plotPositiveGroup);
                }
            }
            else {
                targetGroup = plotGroup;
            }

            //draw columns
            for (i = scrollStart; i < scrollEnd; i += 1) {
                set = data[i];
                y = set.y;
                toolText = set.toolText;

                setElem = hotElem = null;

                if (y === null){
                     if ((plotItem = plotItems[i])) {
                         setElem = plotItem.graphic;
                         if (!is3D) {
                             setElem.attr({
                                height: 0
                             });
                         }
                    }
                }
                // when valid value
                else {
                    isNegative = false;

                    x = pluckNumber(set.x, i);
                    setLink = set.link;
                    setBorderWidth = toFloat(set.borderWidth) || 0;

                    // for marimekko
                    

                    fixedWidth = set._FCW * groupMaxWidth;

                    xPos = xAxis.getAxisPosition(set._FCX) ||
                            xAxis.getAxisPosition(x) + xPosOffset;

                    previousY = set.previousY;

                    previousYPos = yAxis.getAxisPosition(previousY || yBase);
                    yPos = yAxis.getAxisPosition(y + (previousY || 0));

                    height = mathAbs(yPos - previousYPos);
                    width = fixedWidth || columnWidth;

                    if (is3D) {

                        if (y < 0) {
                            yPos = previousYPos;
                            isNegative = true;
                        }

                        // manage positive and negative group
                        targetGroup = y < 0 ? plotNegativeGroupArray :
                            plotPositiveGroupArray;

                        if (!(plotItem = plotItems[i])) {
                            plotItem = plotItems[i] = {
                                index: i,
                                value: y,
                                graphic: paper.cubepath(targetGroup[i]),
                                dataLabel: null,
                                tracker: null,
                                hot: null
                            };
                        }
                        setElem = plotItem.graphic;
                        setElem.attr({
                            cubepath: [
                                xPos - xDepth,
                                yBasePos + yDepth,
                                width,
                                0,
                                xDepth,
                                yDepth
                            ],
                            'fill': [toRaphaelColor(set.color), !use3DLighting],
                            stroke: setBorderWidth &&
                                    toRaphaelColor(set.borderColor) || 'NONE',
                            'stroke-width': setBorderWidth,
                            'visibility': seriesVisibility
                            })
                            .shadow(seriesOptions.shadow && set.shadow, shadowGroup)
                            .animate({
                                cubepath: [
                                    xPos - xDepth,
                                    yPos + yDepth,
                                    width,
                                    height,
                                    xDepth,
                                    yDepth
                                ]}, animationDuration, 'normal',
                                    function() {
                                        dataLabelsLayer.show();
                                })
                            .data("BBox", {
                                    height: height,
                                    width: width,
                                    x: xPos,
                                    y: yPos
                                });

                        if (setLink || isTooltip) {
                            if (!isStacked && height < HTP) {
                                yPos -= (HTP - height) / 2;
                                height = HTP;
                            }

                            if (!plotItem.tracker) {
                                plotItem.tracker = paper.cubepath(trackerLayer);
                            }
                            hotElem = plotItem.tracker;

                            hotElem.attr({
                                    cubepath: [
                                        xPos - xDepth,
                                        yPos + yDepth,
                                        width,
                                        height,
                                        xDepth,
                                        yDepth
                                    ],
                                    'cursor': setLink ? 'pointer' : '',
                                    stroke: setBorderWidth && TRACKER_FILL || 'NONE',
                                    'stroke-width': setBorderWidth,
                                    'fill': TRACKER_FILL,
                                    'ishot': !!setLink,
                                    'visibility': seriesVisibility
                                })
                                .click( function () {
                                    var link = this.data("link");
                                    link && chart.linkClickFN.call({
                                        link: link }, chart);
                                })
                                .tooltip(toolText)
                                .data("link", setLink);

                            hotElem._.cubetop
                                .click( function () {
                                    var link = this.data("link");
                                    link && chart.linkClickFN.call({
                                        link: link }, chart);
                                })
                                .tooltip(toolText)
                                .data("link", setLink);

                            hotElem._.cubeside
                                .click( function () {
                                    var link = this.data("link");
                                    link && chart.linkClickFN.call({
                                        link: link }, chart);
                                })
                                .tooltip(toolText)
                                .data("link", setLink);

                        }

                        if (isStacked && isNegative) {
                            setElem.toBack();
                            hotElem && hotElem.toBack();
                        }


                    }
                    // 2D column
                    else {
                        valueBelowPlot = false;

                        // set correct yPos for all plots drawn from top to bottom
                        if ((!isLog && !isInverseAxis && y < 0) ||
                                (!isLog && isInverseAxis && y > 0)){
                            yPos = previousYPos;
                            valueBelowPlot = true;
                        }
                        if ((isInverseAxis && !isPositiveNegative && y > 0)) {
                            yPos = previousYPos - height;
                            valueBelowPlot = false;
                        }
                        // inverse direction management for waterfall charts
                        if (isWaterfall && y < 0 && defined(previousY)) {
                            yPos -= height;
                            valueBelowPlot = true;
                        }


                        if (!isCandleStick && !isScroll) {

                            /* hotfixes start */
                            // in case yPos is above canvas-top position -
                            // normalize
                            if (toInt(yPos) <= canvasTop) {
                                height -= canvasTop - yPos -
                                        (+hasValidCanvasBorder);
                                yPos = canvasTop - (+hasValidCanvasBorder);
                            }
                            // in case plot exceeds canvas-bottom position -
                            // normalize height
                            if (mathRound(yPos + height) >= canvasBottom) {

                                height -= mathRound(yPos + height) -
                                        canvasBottom +
                                        ((+!!setBorderWidth)) +
                                        (+hasValidCanvasBorder);
                            }

                            if (setBorderWidth <= 1) {
                                // in case xPos is right of canvas-left position -
                                // normalize
                                if (mathRound(xPos) <= canvasLeft) {
                                    width += xPos;
                                    xPos = canvasLeft - (setBorderWidth / 2) +
                                            (+!!setBorderWidth) - (+hasValidCanvasBorder);
                                    width -= xPos;
                                }
                                // in case plot exceeds canvas-right position -
                                // normalize width
                                if (mathRound(xPos + width) >= canvasRight) {
                                    width = canvasRight - xPos + (setBorderWidth / 2) -
                                            (+!!setBorderWidth) + (+hasValidCanvasBorder);
                                }
                            }
                        }
                        /* hotfixes end */

                        // crisp column
                        crispBox = R.crispBound(xPos, yPos, width, height,
                                                                setBorderWidth);
                        xPos = crispBox.x;
                        yPos = crispBox.y;
                        width = crispBox.width;
                        height = crispBox.height;

                        // start base hotfix
                        if (!isCandleStick && hasValidCanvasBorder &&
                                (!defined(previousY) ||
                                        (isWaterfall && previousY === y && y === set._FCY))) {

                            // hotfix top when all columns are drawn from top
                            if (isAllNegativeZero && !isInverseAxis) {

                                columnBaseHotFixDelta = yPos - (canvasTop -
                                        setBorderWidth / 2);
                                height += columnBaseHotFixDelta;
                                yBasePos = yPos = yPos - columnBaseHotFixDelta;

                            }

                            // hotfix bottom when all columns are drawn from bottom
                            else if (isLog || isAllPositiveZero ||
                                    (isInverseAxis && isAllNegativeZero)) {

                                height = (canvasBottom - yPos) + setBorderWidth / 2;
                                yBasePos = yPos + height;

                            }
                        }

                        // end base hotfix

                        // special treatment of columns in waterfall when
                        // connector lines are dashed and only 1px thick:
                        // reduce the height of the columns to 1px to show the
                        // 1px dashed connector lines
                        // adjust y of the column  if required
                        if (isWaterfall) {

                            if (previousY && setBorderWidth > 0 &&
                                    seriesOptions.connectorOpacity !== 0 &&
                                    seriesOptions.connectorWidth === 1 &&
                                    seriesOptions.connectorDashStyle) {

                                height -= 1;
                                if (y < 0) {
                                    yPos += 1;
                                }
                            }
                        }

                        if (height <= MINHEIGHT) {
                            height = MINHEIGHT;
                            yPos += y < 0 ? 0: - height;
                        }

                        dataOptions._columnWidth = width;

                    if (!(plotItem = plotItems[i])) {
                            plotItem = plotItems[i] = {
                                index: i,
                                value: y,
                                width: width,
                                graphic: paper.rect(targetGroup),
                                valueBelowPlot: valueBelowPlot,
                                dataLabel: null,
                                tracker: null
                            };

                        setElem = plotItem.graphic;

                        setElem.attr({
                            x: xPos,
                            y: yBasePos,
                            width: width,
                            height: 0,
                            r: plotRadius,
                            fill: toRaphaelColor(set.color),
                            stroke: toRaphaelColor(set.borderColor),
                            'stroke-width': setBorderWidth,
                            'stroke-dasharray': set.dashStyle,
                            'stroke-linejoin': 'miter',
                            'visibility': seriesVisibility
                        })
                        .shadow(seriesOptions.shadow && set.shadow, shadowGroup)
                        .animate({
                                    y: yPos,
                                    height: height || 1
                                },
                                animationDuration, 'normal',
                            function() {
                                dataLabelsLayer.show();
                            })
                        .data ("BBox", crispBox);

                        if (setLink || isTooltip) {
                            if (!plotItem.tracker) {
                                plotItem.tracker = paper.rect(trackerLayer);
                            }

                            if (!isStacked && height < HTP) {
                                yPos -= (HTP - height) / 2;
                                height = HTP;
                            }

                            hotElem = plotItem.tracker;
                            hotElem.attr({
                                x: xPos,
                                y: yPos,
                                width: width,
                                height: height,
                                r: plotRadius,
                                'cursor': setLink ? 'pointer' : '',
                                stroke: TRACKER_FILL,
                                'stroke-width': setBorderWidth,
                                'fill': TRACKER_FILL,
                                'ishot': !!setLink,
                                'visibility': seriesVisibility
                            })
                            .click( function () {
                                var link = this.data("link");
                                link && chart.linkClickFN.call({
                                    link: link }, chart);
                            })
                            .tooltip(toolText)
                            .data("link", setLink);

                        }
                    }

                    }

                    // Drawing of displayValue
                    valEle = chart.drawPlotColumnLabel(plot, dataOptions,
                            i, xPos, yPos);

                }


                valEle && datasetGraphics.push(valEle);
                setElem && datasetGraphics.push(setElem);
                hotElem && datasetGraphics.push(hotElem);

                chart.drawTracker &&
                        chart.drawTracker.call(chart, plot, dataOptions, i);
            }

            plot.visible = (dataOptions.visible !== false);

            return plot;
        },

        drawPlotColumnScroll: function (plot, dataOptions, config) {
            var chart = this,
                data = plot.data,
                ln = data.length,
                plotItems = plot.items,
                plotItem,
                i,
                scrollRequired = false,
                scrollPosition = config.position,
                scrollDirection = config.direction,
                scrollVxLength = config.vxLength,
                scrollStart = mathMax(0,
                    mathRound((ln - scrollVxLength) * scrollPosition) - 1) || 0,
                scrollEnd = mathMin(ln, scrollStart + scrollVxLength + 2) || ln;

            //adjust scroll start
            if (scrollStart > scrollEnd - scrollVxLength - 2) {
                scrollStart = mathMax(0, scrollEnd - scrollVxLength - 2);
            }

            config.scrollEnd = scrollEnd;

            for (i = scrollStart; i < scrollEnd; i++) {
                if (!plotItems[i]) {
                    config.scrollStart = i;
                    chart.drawPlotColumn(plot, dataOptions, config);
                    break;
                }
            }



        },

        drawPlotColumnLabel: function (plot, dataOptions, i, xPos, yPos, dataLabelsLayer) {
            var chart = this,
                options = chart.options,
                logic = chart.logic,
                chartOptions = options.chart,
                seriesOptions = options.plotOptions.series,
                paper = chart.paper,
                elements = chart.elements,
                layers = chart.layers,
                style = seriesOptions.dataLabels.style,
                rotateValues = chartOptions.rotateValues === 1 ? 270 : 0,
                canvasHeight = chart.canvasHeight,
                canvasTop = chart.canvasTop,
                plotItems = plot.items,
                data = plot.data,
                set = data[i],
                plotItem = plotItems[i],
                valuePadding = chartOptions.valuePadding + GUTTER_2,
                setElem = plotItem.graphic,
                valEle = plotItem.dataLabel,
                isNegative = pluck(plotItem.valueBelowPlot, set.y < 0),
                // is stacked chart
                isStacked = logic.isStacked,
                // is 3D
                is3D = logic.is3D,
                xDepth = chartOptions.xDepth || 0,
                yDepth = chartOptions.yDepth || 0,
                displayValue = set.displayValue,
                seriesVisibility = dataOptions.visible === false ?
                        'hidden': 'visible',
                placeValuesInside = chartOptions.placeValuesInside,
                isNewElement = false,
                height,
                colBBox,
                yAdjust,
                yAdjust,
                insideColSpace,
                outsideColSpace,
                textHeight,
                origTextHeight,
                textY,
                textX,
                bBoxObj;

            dataLabelsLayer = dataLabelsLayer || layers.datalabels;

            // Drawing of displayValue
            if (defined(displayValue) && displayValue !== BLANK && set.y !== null) {
                if (!valEle) {

                    

                    valEle = plotItem.dataLabel = paper.text().attr({
                        text: displayValue
                    })
                    .css(style);
                    isNewElement = true;
                } else {
                    rotateValues && valEle.rotate(360 - rotateValues);
                }

                // get the bBox to find height and width of
                // the text.
                bBoxObj = valEle.getBBox();
                colBBox = setElem.data("BBox");
                height = colBBox.height;

                // If rotated values we use the width of
                // the text as height
                textHeight = origTextHeight = (rotateValues ? bBoxObj.width :
                        bBoxObj.height);
                textHeight +=  valuePadding;
                // in case of negative value place the value text below the
                insideColSpace = height;
                yAdjust = (origTextHeight * 0.5) + valuePadding;
                textY = yPos - yAdjust;
                textX = colBBox.x + (colBBox.width * 0.5);

                if (isNegative) {
                    outsideColSpace = (canvasTop + canvasHeight)
                            - (yPos + height);
                    textY = yPos + height;
                }
                else {
                    outsideColSpace = yPos - canvasTop;
                }

                // Stacked Chart always display values inside
                // and center of the column.
                if (isStacked) {
                    textY = yPos + (height * 0.5) + (yDepth || 0);
                    textX -= xDepth;
                }
                else {
                    if (placeValuesInside) {
                        // If space available inside column
                        if (insideColSpace >= textHeight) {
                            textY = yPos + (isNegative ? height - yAdjust : yAdjust);
                            set._valueBelowPoint = 1;
                            if (is3D) {
                                textX -= xDepth;
                                textY += yDepth;
                            }
                        }
                        // If space not available inside column
                        // Try to fit the label outside column
                        else if (outsideColSpace >= textHeight) {
                            textY = yPos + (isNegative ? height + yAdjust : -yAdjust);
                            if (is3D && isNegative) {
                                textX -= xDepth;
                                textY += yDepth;
                            }
                        } else {
                            textY = yPos + (isNegative ? height - yAdjust : yAdjust);
                            set._valueBelowPoint = 1;
                            if (is3D) {
                                textX -= xDepth;
                                textY += yDepth;
                            }
                        }
                        // If space not available inside or outside column
                        // find the larger space available and place the column
                    }
                    else {
                        // If space is available inside column
                        if (outsideColSpace >= textHeight) {
                            textY = yPos + (isNegative ? height + yAdjust : -yAdjust);
                            //textX += xDepth || 0;
                            if (is3D && isNegative) {
                                textX -= xDepth;
                                textY += yDepth;
                            }
                        }
                        else if (insideColSpace >= textHeight) {
                            textY = yPos + (isNegative ? height - yAdjust : yAdjust);
                            set._valueBelowPoint = 1;
                            if (is3D) {
                                textX -= xDepth;
                                textY += yDepth;
                            }
                        } else {
                            textY = yPos + (isNegative ? height - yAdjust : yAdjust);
                            set._valueBelowPoint = 1;
                            if (is3D) {
                                textX -= xDepth;
                                textY += yDepth;
                            }
                        }
                    }
                }
                valEle.attr({
                    x: textX,
                    y: textY,
                    visibility: seriesVisibility
                });
                rotateValues && valEle.attr('transform', 'T0,0,R' + rotateValues);
                isNewElement && dataLabelsLayer.appendChild(valEle);
                if(isNewElement && pluck(style.backgroundColor, style.borderColor) !== BLANK ) {
                    valEle.attr({
                        'text-bound': [style.backgroundColor, style.borderColor, 1, 2]
                    });
                }
            }
            else if (valEle) {
                valEle.attr({
                    text: BLANK
                });
            }

            return valEle;
        },

        

        drawPlotFloatedcolumn: function (plot, dataOptions) {
            this.drawPlotColumn.call(this, plot, dataOptions);
        },
        drawPlotColumn3d: function (plot, dataOptions) {
            this.drawPlotColumn.call(this, plot, dataOptions);
        },

        drawPlotBar: function (plot, dataOptions) {
            var chart = this,
                data = plot.data,
                ln = data.length,
                plotItems = plot.items,
                plotIndex = plot.index,
                datasetGraphics = plot.graphics = [],

                paper = chart.paper,
                plots = chart.plots,
                logic = chart.logic,
                layers = chart.layers,
                options = chart.options,
                elements = chart.elements,
                chartOptions = options.chart,

                // tooltip options
                tooltipOptions = options.tooltip || {},
                isTooltip = tooltipOptions.enabled !== false,
                toolText,

                // Directly Accessing chart definition JSON Data
                chartAttributes = chart.definition.chart,
                seriesOptions = options.plotOptions.series,
                xAxis = chart.xAxis[dataOptions.xAxis || 0],
                yAxis = chart.yAxis[dataOptions.yAxis || 0],

                // is 3D
                is3D = logic.is3D,

                // is stacked chart
                isStacked = logic.isStacked,

                canvasBorderOpacity = chartOptions.canvasBorderOpacity =
                    R.color(chartOptions.plotBorderColor).opacity,

                canvasBorderWidth = chart.canvasBorderWidth,
                hasValidCanvasBorder = chartOptions.isCanvasBorder =
                            canvasBorderOpacity !== 0 && canvasBorderWidth > 0,

                // chart name
                chartName = getSentenceCase(logic.name),

                animationDuration = isNaN(+seriesOptions.animation) &&
                        seriesOptions.animation.duration ||
                        seriesOptions.animation * 1000,

                numColumns = dataOptions.numColumns || 1,
                columnPosition = dataOptions.columnPosition || 0,

                use3DLighting = chartOptions.use3DLighting,
                seriesVisibility = dataOptions.visible === false ?
                        'hidden': 'visible',
                overlapColumns = chartOptions.overlapColumns,

                xAxisZeroPos = xAxis.getAxisPosition(0),
                xAxisFirstPos = xAxis.getAxisPosition(1),
                groupMaxWidth = xAxisFirstPos - xAxisZeroPos,
                definedGroupPadding = chartAttributes &&
                        chartAttributes.plotspacepercent,
                definedMaxColWidth = chartAttributes.maxcolwidth,
                plotPaddingPercent = pluckNumber(chartAttributes &&
                            chartAttributes.plotpaddingpercent),
                groupPadding = seriesOptions.groupPadding,
                maxColWidth = seriesOptions.maxColWidth,
                groupNetWidth = (1 - definedGroupPadding * .01) * groupMaxWidth ||
                    mathMin(
                        groupMaxWidth * (1 - groupPadding * 2),
                        maxColWidth * numColumns
                    ),

                groupNetHalfWidth = groupNetWidth / 2,
                columnWidth = groupNetWidth / numColumns,
                plotPadding = numColumns > 1 ?
                            (!overlapColumns && plotPaddingPercent === UNDEFINED ?
                                4:
                                (plotPaddingPercent > 0 ? (columnWidth * plotPaddingPercent / 100) : 0))
                            : 0,
                plotEffectivePadding = mathMin(columnWidth - 1, plotPadding),
                height = columnWidth - plotEffectivePadding,

                yPosFactor = (columnPosition * columnWidth) - groupNetHalfWidth +
                            plotEffectivePadding / 2,

                yMax = yAxis.max,
                yMin = yAxis.min,

                isAllPositive = yMax > 0 && yMin > 0,
                isAllPositiveZero = yMax > 0 && yMin >= 0,
                isAllNegative = yMax < 0 && yMin < 0,
                isAllNegativeZero = yMax <= 0 && yMin < 0,
                isPositiveNegative = yMax > 0 && yMin < 0,

                yBase = isAllNegative ? yMax :
                            (isAllPositive ? yMin : 0),

                yBasePos = yAxis.getAxisPosition(yBase),
                barBaseHotFixDelta,

                plotRadius = pluckNumber(chartOptions.useRoundEdges, 0),

                placeValuesInside = chartOptions.placeValuesInside,
                style = seriesOptions.dataLabels.style,
                rotateValues = chartOptions.rotateValues === 1 ? 270 : 0,

                canvasTop = chart.canvasTop,
                canvasLeft = chart.canvasLeft,
                canvasWidth = chart.canvasWidth,
                canvasHeight = chart.canvasHeight,
                canvasBottom = chart.canvasBottom,
                canvasRight = chart.canvasRight,

                MINWIDTH = 1,
                xDepth,
                yDepth,
                width,

                textHeight,
                textWidth,
                insideColSpace,
                outsideColSpace,
                textY,
                textX,
                verticalAlign,
                textAnchor,
                textGutter,
                bBoxObj,
                isNegative,
                displayValue,
                valEle,

                plotItem,
                i,
                fi,
                set,
                setLink,
                setBorderWidth,

                x,
                y,
                previousY,
                xPos,
                yPos,
                previousYPos,

                // Zero plane settings
                zeroPlaneColor,
                zeroPlaneBorderColor,

                layers = chart.layers,
                datasetLayer = layers.dataset = layers.dataset ||
                                                paper.group('dataset-orphan'),
                dataLabelsLayer = layers.datalabels = layers.datalabels ||
                            paper.group('datalabels').insertAfter(datasetLayer),
                trackerLayer = layers.tracker,

                valuePadding = chartOptions.valuePadding + GUTTER_2,
                origTextWidth,
                xAdjust,
                setElem,
                hotElem,

                clickEventHandler,
                hoverEventHandler,
                group,
                plotGroup,
                plotNegativeGroup,
                plotNegativeGroupArray,
                zeroPlaneGroup,
                plotPositiveGroup,
                plotPositiveGroupArray,
                targetGroup,
                shadowGroup,
                crispBox;

             // hide the data labels group. Will be visible after animation completes
            dataLabelsLayer.hide();

            // create plot group
            group = datasetLayer;
            if (isStacked) {
                shadowGroup = group.shadows || (group.shadows = paper.group('shadows', group).toBack());
            }
            plotGroup = group.column = (group.column || paper.group('bars',group));

            if (is3D) {

                xDepth = chartOptions.xDepth || 0;
                yDepth = chartOptions.yDepth || 0;

                plotNegativeGroup = plotGroup.negative =
                    (plotGroup.negative || paper.group('negative-values', plotGroup));

                plotPositiveGroup = plotGroup.column =
                    (plotGroup.column || paper.group('positive-values', plotGroup));

                // Draw zero plane
                zeroPlaneGroup = plotGroup.zeroPlane;
                if (!zeroPlaneGroup && yMin < 0 && yMax >= 0) {

                    zeroPlaneGroup = plotGroup.zeroPlane =
                            paper.group('zero-plane', plotGroup)
                                .insertBefore(plotPositiveGroup);

                    zeroPlaneColor = chartOptions.zeroPlaneColor;
                    zeroPlaneBorderColor = chartOptions.zeroPlaneBorderColor;

                    elements.zeroplane = paper.cubepath(
                            yBasePos - xDepth,
                            canvasTop + yDepth,
                            MINWIDTH,
                            canvasHeight,
                            xDepth,
                            yDepth,
                            zeroPlaneGroup
                        )
                        .attr({
                            'fill' : [zeroPlaneColor, !use3DLighting],
                            'stroke' : NONE,
                            'stroke-width': 0
                        });

                }

                if (!(plotNegativeGroupArray = plotNegativeGroup.data('categoryplots'))) {
                    plotNegativeGroup.data('categoryplots', Array(ln));
                    plotNegativeGroupArray = plotNegativeGroup.data('categoryplots');

                }
                if (!(plotPositiveGroupArray = plotPositiveGroup.data('categoryplots'))) {
                    plotPositiveGroup.data('categoryplots', Array(ln));
                    plotPositiveGroupArray = plotPositiveGroup.data('categoryplots');

                }

                for (i = 0; i < ln; i += 1) {
                    plotNegativeGroupArray[i] = plotNegativeGroupArray[i] ||
                        paper.group(plotNegativeGroup);
                    plotPositiveGroupArray[i] = plotPositiveGroupArray[i] ||
                        paper.group(plotPositiveGroup);
                }

            } else {

                // clip bars inside canvas
                if (!plotGroup.attrs['clip-rect']) {
                    plotGroup.attr({
                       'clip-rect': elements["clip-canvas"]
                    });
                }

                targetGroup = plotGroup;
            }

            //draw data
            for (i = 0, fi = ln - 1; i < ln; i += 1, fi -= 1) {
                set = data[i];
                y = set.y;

                setElem = hotElem = null;

                if (y === null) {
                    if ((plotItem = plotItems[i])) {

                        setElem = plotItem.graphic;
                         if (!is3D) {
                             setElem. attr({
                                width: 0
                             });
                         }
                    }
                }
                // when valid value
                else {
                    x = pluckNumber(set.x, i);
                    setLink = set.link,
                    toolText = set.toolText;
                    setBorderWidth = toFloat(set.borderWidth) || 0;

                    yPos = xAxis.getAxisPosition(x) + yPosFactor;

                    previousY = set.previousY;
                    previousYPos = yAxis.getAxisPosition(previousY || yBase);
                    xPos = yAxis.getAxisPosition(y + (previousY || 0));
                    width = mathAbs(xPos - previousYPos);

                    isNegative = true;
                    if (y > 0) {
                        xPos = previousYPos;
                        isNegative = false;
                    }


                    if (is3D) {

                        // manage positive and negative group
                        targetGroup = y < 0 ? plotNegativeGroupArray :
                            plotPositiveGroupArray;

                        if (!(plotItem = plotItems[i])) {
                            plotItem = plotItems[i] = {
                                index: i,
                                value: y,
                                graphic: paper.cubepath(targetGroup[fi]),
                                dataLabel: null,
                                tracker: null
                            };
                        }

                        setElem = plotItem.graphic;

                        setElem.attr({
                           cubepath: [
                                yBasePos - xDepth,
                                yPos + yDepth,
                                0,
                                height,
                                xDepth,
                                yDepth
                            ],
                            'fill': [toRaphaelColor(set.color), !use3DLighting],
                            stroke: setBorderWidth &&
                                    toRaphaelColor(set.borderColor) || 'NONE',
                            'stroke-width': setBorderWidth,
                            'stroke-dasharray': set.dashStyle,
                            'cursor': setLink ? 'pointer' : '',
                            'visibility': seriesVisibility
                        })
                        .shadow(seriesOptions.shadow && set.shadow, shadowGroup)
                        .animate({
                            cubepath: [
                                xPos - xDepth,
                                yPos + yDepth,
                                width,
                                height,
                                xDepth,
                                yDepth
                            ]}, animationDuration, 'normal',
                                function() {

                                    dataLabelsLayer.show();

                            })
                            .data("BBox", {
                                    height: height,
                                    width: width,
                                    x: xPos,
                                    y: yPos
                                });

                        if (setLink || isTooltip) {
                            if (!isStacked && width < HTP) {
                                xPos -= (HTP - width) / 2;
                                width = HTP;
                            }
                            if (!plotItem.tracker) {
                                plotItem.tracker = paper.cubepath(trackerLayer);
                            }
                            hotElem = plotItem.tracker;

                            hotElem.attr({
                                    cubepath: [
                                        xPos - xDepth,
                                        yPos + yDepth,
                                        width,
                                        height,
                                        xDepth,
                                        yDepth
                                    ],
                                    'cursor': setLink ? 'pointer' : '',
                                    stroke: setBorderWidth &&
                                        TRACKER_FILL || 'NONE',
                                    'stroke-width': setBorderWidth,
                                    'fill': TRACKER_FILL,
                                    'ishot': !!setLink
                                })
                                .click( function () {
                                    var link = this.data("link");
                                    link && chart.linkClickFN.call({
                                        link: link }, chart);
                                })
                                .tooltip(toolText)
                                .data("link", setLink);

                            hotElem._.cubetop
                                .click( function () {
                                    var link = this.data("link");
                                    link && chart.linkClickFN.call({
                                        link: link }, chart);
                                })
                                .tooltip(toolText)
                                .data("link", setLink);

                            hotElem._.cubeside
                                .click( function () {
                                    var link = this.data("link");
                                    link && chart.linkClickFN.call({
                                        link: link }, chart);
                                })
                                .tooltip(toolText)
                                .data("link", setLink);

                        }

                        if (!isStacked || (isStacked && y < 0)) {
                            setElem.toBack();
                            hotElem &&hotElem.toBack();
                        }

                    }
                    // 2D bars
                    else {


                        /* hotfixes start */
                        // in case xPos is right of canvas-left position -
                        // normalize
                        if (toInt(xPos) <= canvasLeft) {
                            width += xPos;
                            xPos = canvasLeft - (setBorderWidth / 2) +
                                    (+!!setBorderWidth) - (+hasValidCanvasBorder);
                            width -= xPos - (setBorderWidth / 2) + (+!!setBorderWidth);
                        }
                        // in case plot exceeds canvas-right position -
                        // normalize width
                        if (mathRound(xPos + width) >= canvasRight) {
                            xPos -= (setBorderWidth / 2) +
                                    (+!setBorderWidth);
                            width = canvasRight - xPos + (setBorderWidth / 2) -
                                    (+!!setBorderWidth) + (+hasValidCanvasBorder);
                        }

                        /* hotfixes end */

                        // crisp column
                        crispBox = R.crispBound(xPos, yPos, width, height,
                                setBorderWidth);
                        xPos = crispBox.x;
                        yPos = crispBox.y;
                        width = crispBox.width;
                        height = crispBox.height;

                        if (width <= MINWIDTH) {
                            width = MINWIDTH;
                            xPos += y < 0 ? - width: 0;
                        }

                        if (!(plotItem = plotItems[i])) {
                            plotItem = plotItems[i] = {
                                index: i,
                                value: y,
                                height: height,
                                graphic: paper.rect(targetGroup),
                                dataLabel: null,
                                tracker: null
                            };
                        }
                        setElem = plotItem.graphic;

                        setElem.attr({
                            x: yBasePos,
                            y: yPos,
                            width: 0,
                            height: height,
                            r: plotRadius,
                            fill: toRaphaelColor(set.color),
                            stroke: toRaphaelColor(set.borderColor),
                            'stroke-width': setBorderWidth,
                            'stroke-dasharray': set.dashStyle,
                            'stroke-linejoin': 'miter',
                            'cursor': setLink ? 'pointer' : '',
                            'visibility': seriesVisibility
                        })
                        .shadow(seriesOptions.shadow && set.shadow, shadowGroup)
                        .animate({
                                x: xPos,
                                width: width || MINWIDTH
                            }, animationDuration, 'normal',
                            function() {
                                dataLabelsLayer.show();
                            })
                            .data("BBox", crispBox);


                        if (setLink || isTooltip) {
                            if (!isStacked && width < HTP) {
                                xPos -= (HTP - width) / 2;
                                width = HTP;
                            }
                            if (!plotItem.tracker) {
                                plotItem.tracker = paper.rect(trackerLayer);
                            }
                            hotElem = plotItem.tracker;

                            hotElem.attr({
                                x: xPos,
                                y: yPos,
                                width: width,
                                height: height,
                                r: plotRadius,
                                'cursor': setLink ? 'pointer' : '',
                                stroke: TRACKER_FILL,
                                'stroke-width': setBorderWidth,
                                'fill': TRACKER_FILL,
                                'ishot': !!setLink
                            })
                            .click( function () {
                                var link = this.data("link");
                                link && chart.linkClickFN.call({
                                    link: link }, chart);
                            })
                            .tooltip(toolText)
                            .data("link", setLink);
                        }

                    }

                    // Drawing of displayValue
                    valEle = chart.drawPlotBarLabel(plot, dataOptions, i, xPos, yPos);
                }

                valEle && datasetGraphics.push(valEle);
                setElem && datasetGraphics.push(setElem);
                hotElem && datasetGraphics.push(hotElem);

                chart.drawTracker &&
                       chart.drawTracker.call(chart, plot, dataOptions, i);

            }

            plot.visible = (dataOptions.visible !== false);

            return plot;
        },

        drawPlotBarLabel: function (plot, dataOptions, i, xPos, yPos, dataLabelsLayer) {
            var chart = this,
                options = chart.options,
                logic = chart.logic,
                chartOptions = options.chart,
                seriesOptions = options.plotOptions.series,
                paper = chart.paper,
                elements = chart.elements,
                layers = chart.layers,
                style = seriesOptions.dataLabels.style,
                rotateValues = chartOptions.rotateValues === 1 ? 270 : 0,
                canvasHeight = chart.canvasHeight,
                canvasTop = chart.canvasTop,
                canvasLeft = chart.canvasLeft,
                canvasWidth = chart.canvasWidth,
                plotItems = plot.items,
                data = plot.data,
                set = data[i],
                plotItem = plotItems[i],
                valuePadding = chartOptions.valuePadding + GUTTER_2,
                setElem = plotItem.graphic,
                valEle = plotItem.dataLabel,
                isNegative = set.y < 0,
                // is stacked chart
                isStacked = logic.isStacked,
                // is 3D
                is3D = logic.is3D,
                xDepth = chartOptions.xDepth || 0,
                yDepth = chartOptions.yDepth || 0,
                displayValue = set.displayValue,
                seriesVisibility = dataOptions.visible === false ?
                        'hidden': 'visible',
                placeValuesInside = chartOptions.placeValuesInside,
                isNewElement = false,
                height,
                colBBox,
                yAdjust,
                yAdjust,
                insideColSpace,
                outsideColSpace,
                textHeight,
                origTextHeight,
                textY,
                textX,
                bBoxObj,
                origTextWidth,
                textWidth,
                textGutter,
                width,
                xAdjust;

            dataLabelsLayer = dataLabelsLayer || layers.datalabels;

            if (defined(displayValue) && displayValue !== BLANK && set.y !== null) {
                // First render the value text
                if (!valEle) {
                    valEle = plotItem.dataLabel = paper.text();
                    isNewElement = true;
                }
                valEle.attr({
                    text: displayValue,
                    title: (set.originalText || ''),
                    fill: style.color
                })
                .css(style);

                // get the bBox to find height and width of the
                // text.
                bBoxObj = valEle.getBBox();
                colBBox = setElem.data("BBox");
                height = colBBox.height;
                width = colBBox.width;

                // If rotated values we use the width of the
                // text as height
                textHeight = rotateValues ? bBoxObj.width :
                        bBoxObj.height;
                textWidth = origTextWidth = bBoxObj.width;
                textWidth += valuePadding;
                // in case of negative value place the value
                // text below the
                insideColSpace = height;
                textY = yPos + (height * 0.5);
                textX = xPos + (isNegative ? 0 : width);
                textGutter = GUTTER_4;
                xAdjust = (origTextWidth * 0.5) + valuePadding;

                if (isNegative) {
                    outsideColSpace = xPos - canvasLeft;
                } else {
                    outsideColSpace = (canvasLeft + canvasWidth)
                            - (xPos + width);
                }

                // Space-management of dataValues
                if (isStacked) {
                    textX += (isNegative ? width : -width) * 0.5;
                    textX -= is3D ? xDepth : 0;
                    textY += is3D ? yDepth : 0;
                } else {
                    if (placeValuesInside) {
                        if (width >= textWidth) {
                            textX += isNegative ? xAdjust : -xAdjust;
                            if (is3D) {
                                textX -= xDepth;
                                textY += yDepth;
                            }
                        } else {
                            textX += isNegative ? -xAdjust : xAdjust;
                            if (is3D && isNegative) {
                                textX -= xDepth;
                            }
                        }
                    } else {
                        if (outsideColSpace >= textWidth) {
                            textX += isNegative ? -xAdjust : xAdjust;
                            if (is3D && isNegative) {
                                textX -= xDepth;
                                textY += xDepth;
                            }
                        } else {
                            textX += isNegative ? xAdjust : -xAdjust;
                            if (is3D) {
                                textX -= xDepth;
                                textY += yDepth;
                            }
                        }
                    }
                    // Adjust if the text is going outside the canvas Area.
                    if (textX > (canvasLeft + canvasWidth)) {
                        textX = (canvasLeft + canvasWidth) -
                                (bBoxObj.width * 0.5) - GUTTER_4;
                    }
                    if (textX < canvasLeft) {
                        textX = canvasLeft + (bBoxObj.width * 0.5) + GUTTER_4;
                    }
                }

                valEle.attr({
                    x: textX,
                    y: textY,
                    visibility: seriesVisibility
                });
                isNewElement && dataLabelsLayer.appendChild(valEle);
                if(isNewElement && pluck(style.backgroundColor, style.borderColor) !== BLANK ) {
                    valEle.attr({
                        'text-bound': [style.backgroundColor, style.borderColor, 1, 2]
                    });
                }
            }
            else if (valEle) {
                valEle.attr({
                    text: BLANK
                });
            }
            return valEle;
        },

        drawPlotBar3d: function (plot, dataOptions) {
            this.drawPlotBar.call(this, plot, dataOptions);
        },

        drawPlotLine: function (plot, dataOptions) {
            var chart = this,
                paper = chart.paper,
                elements = chart.elements,
                options = chart.options,
                chartOptions = options.chart,
                logic = chart.logic,
                seriesOptions = options.plotOptions.series,
                plotItems = plot.items,
                plotIndex = plot.index,
                datasetGraphics = plot.graphics = (plot.graphics || []),

                plotItem,
                xAxis = chart.xAxis[dataOptions.xAxis || 0],
                yAxis = chart.yAxis[dataOptions.yAxis || 0],

                // force segmeneted lines
                isForceSegmentedLine = logic.multisetRealtime || logic.dragExtended,

                // is waterfall
                isWaterfall = logic.isWaterfall,
                definedGroupPadding,
                chartAttributes,
                groupPadding,
                maxColWidth,
                groupNetWidth,
                groupNetHalfWidth = 0,
                canvasLeft = chart.canvasLeft,
                canvasRight = chart.canvasLeft + chart.canvasWidth,


                // tooltip options
                tooltipOptions = options.tooltip || {},
                isTooltip = tooltipOptions.enabled !== false,
                toolText,

                animationDuration = isNaN(+seriesOptions.animation) &&
                        seriesOptions.animation.duration ||
                        seriesOptions.animation * 1000,
                lineAnimation,

                xDepth = chartOptions.xDepth || 0,
                yDepth = chartOptions.yDepth || 0,
                series2D3Dshift = chartOptions.series2D3Dshift,
                logic = chart.logic,
                isStepLine = dataOptions.step,
                stepLineDrawVerticalJoins = dataOptions.drawVerticalJoins,
                stepLineUseForwardSteps = dataOptions.useForwardSteps,
                chartName = getSentenceCase(logic.name),

                data = plot.data,

                seriesVisibility = dataOptions.visible === false ?
                        'hidden': 'visible',
                i,
                ln = data.length,

                xAxisZeroPos = xAxis.getAxisPosition(0),
                xAxisFirstPos = xAxis.getAxisPosition(1),
                pointDistance = xAxisFirstPos - xAxisZeroPos,
                totalCanvasWidth = pointDistance * ln,

                scroll = xAxis.axisData.scroll || {},
                isScroll = chartOptions.hasScroll || false,
                scrollPosition,

                connectNullData = seriesOptions.connectNullData,
                set,
                setLink,
                markerRadius,
                x,
                y,
                previousY,
                lastXPos,
                lastYPos = null,
                xPos,
                yPos,
                crispBox,
                seriesLineWidth = seriesOptions.connectorWidth =
                                        toFloat(dataOptions.lineWidth),
                plotColor = dataOptions.color,
                lineOpacity = seriesOptions.connectorOpacity =
                        R.color(plotColor).opacity,
                setColor,
                setDashStyle,
                seriesDashStyle = seriesOptions.connectorDashStyle =
                        dataOptions.dashStyle,
                marker,
                symbol,
                dip,
                setMarkerElem,
                hotElem,
                setLineElem,
                seriesType = chart.logic.defaultSeriesType,

                layers = chart.layers,
                datasetLayer = layers.dataset = layers.dataset ||
                        paper.group('dataset-orphan'),
                dataLabelsLayer = layers.datalabels = layers.datalabels ||
                        paper.group('datalabels').insertAfter(datasetLayer),
                trackerLayer = layers.tracker,
                clipCanvasInit = elements['clip-canvas-init'].slice(0),
                clipCanvas = elements['clip-canvas'].slice(0),
                isReverse = yAxis.axisData.reversed,
                yMax = yAxis.max,
                yMin = yAxis.min,
                yBase = yMax > 0 && yMin > 0 ? !isReverse ? yMin : yMax :
                (yMax < 0 && yMin < 0 ? !isReverse ? yMax : yMin : !isReverse ? 0 : yMax),
                yBasePos = yAxis.getAxisPosition(yBase) +
                            (series2D3Dshift ? yDepth : 0),
                linePath = [],
                group,
                lineGroup,
                markerGroup,
                anchorShadowGroup,
                anchorShadow,
                lineSegmentChange,
                lscthash,
                valEle;

             yAxis.yBasePos = yBasePos;

             if (isWaterfall) {
               // column calculation for waterfall chart
               // Directly Accessing chart definition JSON Data
               chartAttributes = chart.definition.chart;
               definedGroupPadding = chartAttributes &&
                       chartAttributes.plotspacepercent;
               groupPadding = seriesOptions.groupPadding;
               maxColWidth = seriesOptions.maxColWidth;
               groupNetWidth = (1 - definedGroupPadding * .01) * pointDistance ||
                   mathMin(
                       pointDistance * (1 - groupPadding * 2),
                       maxColWidth * 1
                   );
               groupNetHalfWidth = groupNetWidth / 2;
             }

            // hide the data labels group. Will be visible after animation completes
            dataLabelsLayer.hide();

            //create series group
            group = datasetLayer;
            lineGroup = group.line || (group.line = paper.group('line-connector', group));
            markerGroup = group.anchors || (group.anchors = paper.group('line-anchors', group));
            markerGroup.hide();
            anchorShadowGroup = group.anchorShadows ||
                        (group.anchorShadows = paper.group('anchor-shadows', group).toBack());
            anchorShadowGroup.hide();

            //draw data
            for (i = 0; i < ln; i += 1) {
                set = data[i];
                y = set.y;
                previousY = set.previousY  || 0;
                toolText  = set.toolText;

                setLineElem = valEle = setMarkerElem = hotElem = null;
                plotItem = plotItems[i] = {
                    index: i,
                    value: null,
                    graphic: null,
                    connector: null,
                    dataLabel: null,
                    shadowGroup: anchorShadowGroup,
                    tracker: null
                };

                if (y === null) {
                    if (connectNullData === 0) {
                        lastYPos = null;
                    }
                }
                else {

                    x = pluckNumber(set.x, i);
                    setLink = set.link;
                    /*
                     * BoxAndWhisker chart uses line to draw its other related seris
                     * and its anchor. Due to this and BoxAndWhisker being a
                     * multiSeries chart. We have to take few extra measures
                     */
                    if(dataOptions.relatedSeries === 'boxandwhisker'){
                        //a displacemnet value defined in box and whisker
                        dataOptions.pointStart && (x += dataOptions.pointStart);
                    }

                    //Multi series related management.
                    yPos = yAxis.getAxisPosition(y + previousY) +
                            (series2D3Dshift ? yDepth : 0);
                    xPos = xAxis.getAxisPosition(x) - xDepth;

                    // crisp line positions
                    xPos = getCrispValues(xPos, seriesLineWidth, seriesLineWidth).position;
                    yPos = getCrispValues(yPos, seriesLineWidth, seriesLineWidth).position;

                    marker = set.marker;
                    if (marker && marker.enabled) {
                        symbol = marker.symbol.split('_');
                        dip = symbol[0] === 'spoke' ? 1 : 0;
                        markerRadius = marker.radius;

                        setMarkerElem = plotItem.graphic = paper.polypath(symbol[1] || 2, xPos, yPos,
                                 markerRadius, marker.startAngle,
                                 dip,
                            markerGroup)
                            .attr({
                                fill: toRaphaelColor(marker.fillColor),
                                'stroke-width': marker.lineWidth,
                                stroke: toRaphaelColor(marker.lineColor),
                                'cursor': setLink ? 'pointer' : '',
                                'visibility': seriesVisibility
                            });

                        if (setLink || isTooltip) {
                            if (markerRadius < HTP) {
                                markerRadius = HTP;
                            }

                            hotElem = plotItem.tracker = paper.circle(xPos, yPos,
                                markerRadius, trackerLayer)
                                .attr({
                                     'cursor': setLink ? 'pointer' : '',
                                     stroke: TRACKER_FILL,
                                     'stroke-width': marker.lineWidth,
                                    'fill': TRACKER_FILL,
                                    ishot: !!setLink,
                                    'visibility': seriesVisibility
                                })
                                .click( function () {
                                    var link = this.data("link");
                                    link && chart.linkClickFN.call({
                                        link: link }, chart);
                                })
                                .tooltip(toolText)
                                .data("link", setLink);

                         }

                    }

                    lineSegmentChange = (lscthash !== [
                        toRaphaelColor(set.color || plotColor),
                        set.dashStyle || seriesDashStyle].join(":"));

                    if (lastYPos !== null) {
                        // move to the starting position of the line segment
                        if (isForceSegmentedLine || isWaterfall || !linePath.join("")){
                            linePath.push(M, lastXPos, lastYPos);
                        }

                        isWaterfall && linePath.push('m', - groupNetHalfWidth, 0);

                        // Management for Step Line
                        if (isStepLine) {
                            if (stepLineUseForwardSteps) {
                                // When asked to use forwardSteps, draw horizontally first
                                linePath.push(H, xPos);

                                isWaterfall && linePath.push('h', groupNetHalfWidth);

                                if (stepLineDrawVerticalJoins) {
                                    // and then draw vertically
                                    // Applicable only if drawVerticalJoins is true
                                    linePath.push(V, yPos);
                                } else {
                                    linePath.push('m', 0, yPos - lastYPos);
                                }
                            }
                            else {
                                // When forwardSteps is false, draw vertically first
                                // Applicable only if drawVerticalJoins is true
                                if (stepLineDrawVerticalJoins) {
                                    linePath.push(V, yPos);
                                }
                                // Draw horizontally after verical drawing
                                // Move to the vertical position as a safegurd
                                // when drawVerticalJoins is false
                                linePath.push(M, lastXPos, yPos, H, xPos);
                            }
                        }
                        // Drawing for normal line drawing
                        else {
                          // Draw line to end position
                          linePath.push(L, xPos, yPos);
                        }

                        if (isForceSegmentedLine || lineSegmentChange){
                            // draw line path

                            setLineElem = plotItem.connector = paper.path(linePath, lineGroup)
                                .attr({
                                'stroke-dasharray': setDashStyle,
                                'stroke-width': seriesLineWidth,
                                'stroke': setColor,
                                'stroke-linecap': 'round',
                                'stroke-linejoin': seriesLineWidth > MAX_MITER_LINEJOIN ? 'round' : 'miter',
                                'visibility': seriesVisibility
                            })
                            .shadow(seriesOptions.shadow && set.shadow);
                            linePath = [];
                        }
                    }
                    else {
                        !isForceSegmentedLine && linePath.push(M, xPos, yPos);
                    }


                    valEle = plotItem.dataLabel = chart.drawPlotLineLabel(plot, dataOptions, i,
                        xPos, yPos);

                    lastXPos = xPos;
                    lastYPos = yPos;
                    setColor = toRaphaelColor(set.color || plotColor);
                    setDashStyle = set.dashStyle || seriesDashStyle;

                    lscthash = [setColor, setDashStyle].join(":");
                }

                valEle && datasetGraphics.push(valEle);
                setMarkerElem && datasetGraphics.push(setMarkerElem);
                setLineElem && datasetGraphics.push(setLineElem);
                hotElem && datasetGraphics.push(hotElem);

                chart.drawTracker &&
                        chart.drawTracker.call(chart, plot, dataOptions, i);

            }

            // draw final line path after iterating all points
            if (!isForceSegmentedLine && linePath.join('')) {
                setLineElem = paper.path(linePath, lineGroup)
                    .attr({
                    'stroke-dasharray': setDashStyle,
                    'stroke-width': seriesLineWidth,
                    'stroke': setColor,
                    'stroke-linecap': 'round',
                    'stroke-linejoin': seriesLineWidth > MAX_MITER_LINEJOIN ? 'round' : 'miter',
                    'visibility': seriesVisibility
                })
                 .shadow(seriesOptions.shadow && set.shadow);
                setLineElem && datasetGraphics.push(setLineElem);
            }

            // Animation from right when scrollToEnd is 1
            if (isScroll) {
                scrollPosition = scroll.startPercent;
                clipCanvas[2] =  totalCanvasWidth + clipCanvasInit[0];
                if (scrollPosition === 1){
                    clipCanvasInit[0] = clipCanvas[2];
                    clipCanvas[0] = 0;
                }

            }


            // clip-canvas animation to line chart
            lineAnimation = R.animation({ 'clip-rect': clipCanvas },
                    animationDuration,
                    isScroll ? 'easeIn' : 'normal',
                    function () {
                        lineGroup.attr({ 'clip-rect': null });
                        anchorShadowGroup.show();
                        markerGroup.show();
                        dataLabelsLayer.show();

                    });

            lineGroup.attr({ 'clip-rect': clipCanvasInit })
                 .animate(isWaterfall ?
                    lineAnimation.delay(animationDuration): lineAnimation);

            plot.visible = (dataOptions.visible !== false);
            return plot;
        },

        drawPlotArea: function(plot, dataOptions) {
            var chart = this,
                paper = chart.paper,
                options = chart.options,
                chartOptions = options.chart,
                logic = chart.logic,
                seriesOptions = options.plotOptions.series,
                elements = chart.elements,
                plotItems = plot.items,
                plotIndex = plot.index,
                datasetGraphics = plot.graphics = (plot.graphics || []),
                plotItem,

                xAxis = chart.xAxis[dataOptions.xAxis || 0],
                yAxis = chart.yAxis[dataOptions.yAxis || 0],

                isReverse = yAxis.axisData.reversed,
                xDepth = chartOptions.xDepth || 0,
                yDepth = chartOptions.yDepth || 0,

                // is stacked chart
                isStacked = logic.isStacked,

                // tooltip options
                tooltipOptions = options.tooltip || {},
                isTooltip = tooltipOptions.enabled !== false,
                toolText,

                animationDuration = isNaN(+seriesOptions.animation) &&
                        seriesOptions.animation.duration ||
                        seriesOptions.animation * 1000,

                series2D3Dshift = chartOptions.series2D3Dshift,

                // Directly Accessing chart definition JSON Data
                chartAttributes = chart.definition.chart,
                // decides whether a separate line over area will be drawn and
                // area boder will be hidden
                isOnlyLineBorder = chartAttributes.drawfullareaborder === '0',

                data = plot.data,

                seriesVisibility = dataOptions.visible === false ?
                        'hidden': 'visible',
                i,
                ln = data.length,

                xAxisZeroPos = xAxis.getAxisPosition(0),
                xAxisFirstPos = xAxis.getAxisPosition(1),
                pointDistance = xAxisFirstPos - xAxisZeroPos,
                totalCanvasWidth = pointDistance * ln,

                scroll = xAxis.axisData.scroll || {},
                isScroll = chartOptions.hasScroll || false,
                scrollPosition,

                connectNullData = seriesOptions.connectNullData,
                set,
                setLink,
                anchorRadius,
                x,
                y,
                previousY,
                previousYPos,
                yMax = yAxis.max,
                yMin = yAxis.min,

                isAllPositive = yMax > 0 && yMin > 0,
                isAllPositiveZero = yMax > 0 && yMin >= 0,
                isAllNegative = yMax < 0 && yMin < 0,
                isAllNegativeZero = yMax <= 0 && yMin < 0,
                isPositiveNegative = yMax > 0 && yMin < 0,

                yBase = isPositiveNegative ? 0 :
                        !isReverse && isAllPositiveZero ? yMin : yMax,

                yBasePos = yAxis.getAxisPosition(yBase) +
                            (series2D3Dshift ? yDepth : 0),

                optimalYPos,
                lastXPos,
                lastYPos = null,
                xPos,
                yPos,

                lineWidth = dataOptions.lineWidth,
                dashStyle = dataOptions.dashStyle,
                fillColor = toRaphaelColor(dataOptions.fillColor),
                lineColor = toRaphaelColor(dataOptions.lineColor),

                // This variable stores number of datapoints joined by the area
                // A valid area required minimum of 2 data points
                validPointsJoined = 0,

                anchor,
                symbol,
                anchorElement,
                hotElem,

                areaPath = [],
                areaReversePath = [],

                areaElement = null,

                linePath = [],
                lineElement,

                layers = chart.layers,
                datasetLayer = layers.dataset = layers.dataset ||
                        paper.group('dataset-orphan'),
                dataLabelsLayer = layers.datalabels = layers.datalabels ||
                        paper.group('datalabels').insertAfter(datasetLayer),
                trackerLayer = layers.tracker,
                clipCanvasInit = elements['clip-canvas-init'].slice(0),
                clipCanvas = elements['clip-canvas'].slice(0),
                group,
                lineGroup,
                areaGroup,
                anchorGroup,
                shadowGroup,
                areaAnimation,
                valEle;

             yAxis.yBasePos = yBasePos;

            // hide the data labels group. Will be visible after animation completes
            dataLabelsLayer.hide();

            //create series group
            group = datasetLayer;
            if (isStacked) {
                shadowGroup = group.shadows || (group.shadows = paper.group('shadows', group).toBack());
            }
            areaGroup = group.area = (group.area || paper.group('area', group));
            lineGroup = group.arealine = (group.arealine || paper.group('area-connector', group));
            anchorGroup = group.areaanchors = (group.areaanchors || paper.group('area-anchors', group));
            anchorGroup.hide();

            //draw data
            for (i = 0; i < ln; i += 1) {
                set = data[i];
                y = set.y;
                x = pluckNumber(set.x, i);
                xPos = xAxis.getAxisPosition(x) - xDepth;

                anchorElement = valEle = hotElem = null;

                // null value
                if (y === null) {
                    if (connectNullData === 0) {
                        lastYPos = null;

                        if (validPointsJoined > 0) {
                            if (validPointsJoined === 1) {
                                areaPath.splice(-8, 8);
                            }
                            else {
                                areaPath = areaPath.concat(areaReversePath);
                                areaPath.push(Z);
                            }

                            areaReversePath = [];

                        }

                    }
                    plotItems[i] = {
                        chart: chart,
                        index: i,
                        value: y
                    };
                }
                // valid value
                else {
                    setLink = set.link;
                    toolText = set.toolText;

                    previousY = set.previousY;
                    previousYPos = yAxis.getAxisPosition(previousY) || null;
                    optimalYPos = previousYPos || yBasePos;
                    yPos = yAxis.getAxisPosition(y + (previousY || 0)) +
                            (series2D3Dshift ? yDepth : 0);

                    anchor = set.marker;
                    if (anchor && anchor.enabled) {
                        symbol = anchor.symbol.split('_');
                        anchorRadius = anchor.radius;

                        anchorElement = paper.polypath(symbol[1] || 2, xPos, yPos,
                                 anchorRadius, anchor.startAngle, 0,
                            anchorGroup)
                            .attr({
                                fill: toRaphaelColor(anchor.fillColor),
                                'stroke-width': anchor.lineWidth,
                                stroke: toRaphaelColor(anchor.lineColor),
                                'cursor': setLink ? 'pointer' : '',
                                'visibility': seriesVisibility
                            });


                         if (setLink || isTooltip) {
                            if (!isStacked && anchorRadius < HTP) {
                                anchorRadius = HTP;
                            }

                            hotElem = paper.circle(xPos, yPos,
                                anchorRadius, trackerLayer)
                                .attr({
                                    'cursor': setLink ? 'pointer' : '',
                                    stroke: TRACKER_FILL,
                                    'stroke-width': anchor.lineWidth,
                                    'fill': TRACKER_FILL,
                                    ishot: !!setLink,
                                    'visibility': seriesVisibility
                                })
                                .click( function () {
                                    var link = this.data("link");
                                    link && chart.linkClickFN.call({
                                        link: link }, chart);
                                })
                                .tooltip(toolText)
                                .data("link", setLink);

                         }

                    }

                    // First initial valid value or  valid value after null
                    if (lastYPos === null) {

                        // start/restart line path
                        linePath.push(M, xPos, COMMA, yPos);

                        // start area
                        // move to base position
                        areaPath.push(M, xPos, COMMA, optimalYPos);

                        // initialted count of  the number of valid points joined
                        validPointsJoined = 0;


                    }
                    else {

                            linePath.push(L, xPos, COMMA, yPos);

                    }

                    // continue drawing area path
                            areaPath.push(L, xPos, COMMA, yPos);
                            // draw reverse path for the base of staacked chart
                            areaReversePath.unshift(L, xPos, COMMA, optimalYPos);

                    // counts the number of valid points joined
                    validPointsJoined++;

                    lastXPos = xPos;
                    lastYPos = yPos;

                    plotItems[i] = {
                        chart: chart,
                        index: i,
                        value: y,
                        graphic: anchorElement,
                        dataLabel: valEle,
                        tracker: hotElem
                    };
                    valEle = chart.drawPlotLineLabel(plot, dataOptions, i, xPos, yPos);
                }


                valEle && datasetGraphics.push(valEle);
                anchorElement && datasetGraphics.push(anchorElement);
                hotElem && datasetGraphics.push(hotElem);

                chart.drawTracker &&
                        chart.drawTracker.call(chart, plot, dataOptions, i);

            }


            if (validPointsJoined > 0) {
                // Remove single line thickness area arising out of single value
                if (validPointsJoined === 1) {
                    areaPath.splice(-8, 8);
                }
                // Join reverse path, required mostly in stacked  chart
                else {
                    areaPath = areaPath.concat(areaReversePath);
                    areaPath.push(Z);
                }
            }

            areaElement = plot.graphic = paper.path(areaPath, areaGroup)
                .attr({
                fill: fillColor,
                'stroke-dasharray': dashStyle,
                'stroke-width': isOnlyLineBorder ? 0 : lineWidth,
                'stroke': lineColor,
                'stroke-linecap': 'round',
                'stroke-linejoin': lineWidth > MAX_MITER_LINEJOIN ?
                                    'round' : 'miter',
                'visibility': seriesVisibility
            })
            .shadow(seriesOptions.shadow && set.shadow, shadowGroup);

            areaElement && datasetGraphics.push(areaElement);

            // Animation from right when scrollToEnd is 1
            if (isScroll) {
                scrollPosition = scroll.startPercent;
                clipCanvas[2] =  totalCanvasWidth + clipCanvasInit[0];
                if (scrollPosition === 1){
                    clipCanvasInit[0] = clipCanvas[2];
                    clipCanvas[0] = 0;
                }

            }


            // clip-canvas animation to area chart
            areaAnimation = areaGroup.attr({
                    'clip-rect': clipCanvasInit
                })
                .animate(
                    { 'clip-rect': clipCanvas },
                    animationDuration,
                    isScroll ? 'easeIn' : 'normal',
                    function () {
                        areaGroup.attr({ 'clip-rect': null });
                        anchorGroup.show();
                        dataLabelsLayer.show();

                    }
                );

            if (shadowGroup) {

                shadowGroup.attr({
                        'clip-rect': clipCanvasInit
                    })
                    .animateWith(
                        areaGroup, areaAnimation,
                        { 'clip-rect': clipCanvas },
                        animationDuration,
                        isScroll ? 'easeIn' : 'normal',
                        function () {
                            shadowGroup.attr({ 'clip-rect': null });
                        }
                    );

            }

            if (isOnlyLineBorder) {

                lineElement = plot.connector = paper.path(linePath, lineGroup)
                    .attr({
                    'stroke-dasharray': dashStyle,
                    'stroke-width': lineWidth,
                    'stroke': lineColor,
                    'stroke-linecap': 'round',
                    'stroke-linejoin': lineWidth > MAX_MITER_LINEJOIN ?
                                        'round' : 'miter',
                    'visibility': seriesVisibility
                });

                lineGroup.attr({
                        'clip-rect': clipCanvasInit
                    })
                    .animateWith(
                        areaGroup, areaAnimation,
                        { 'clip-rect': clipCanvas },
                        animationDuration,
                        isScroll ? 'easeIn' : 'normal',
                        function () {
                            lineGroup.attr({ 'clip-rect': null });
                        }
                    );

                lineElement && datasetGraphics.push(lineElement);
            }

            plot.visible = (dataOptions.visible !== false);

            return plot;
        },

        drawPlotScatter: function (plot, dataOptions) {
           var  chart = this,
                options = chart.options,
                chartOptions = options.chart,
                seriesOptions = options.plotOptions.series,
                paper = chart.paper,
                elements = chart.elements,
                plotItems = plot.items,
                plotIndex = plot.index,
                plotItem,
                datasetGraphics = plot.graphics = (plot.graphics || []),
                xAxis = chart.xAxis[dataOptions.xAxis || 0],
                yAxis = chart.yAxis[dataOptions.yAxis || 0],
                data = plot.data,
                seriesVisibility = dataOptions.visible === false ?
                        'hidden': 'visible',

                // tooltip options
                tooltipOptions = options.tooltip || {},
                isTooltip = tooltipOptions.enabled !== false,
                toolText,

                animationDuration = isNaN(+seriesOptions.animation) &&
                        seriesOptions.animation.duration ||
                        seriesOptions.animation * 1000,
                i,
                ln,
                set,
                setLink,
                setTooltip,
                x,
                y,
                lastXPos,
                lastYPos,
                xPos,
                yPos,

                lineWidth = dataOptions.lineWidth,
                isLine = lineWidth > 0,
                lineColor = dataOptions.color,
                dashStyle = dataOptions.dashStyle,
                connectNullData = seriesOptions.connectNullData,
                linePath = [],
                isLinePositioned = false,

                marker,
                markerRadius,
                symbol,
                setElem,
                connectorElem,
                hotElem,

                layers = chart.layers,
                datasetLayer = layers.dataset || (layers.dataset =
                        paper.group('dataset-orphan')),
                dataLabelsLayer = layers.datalabels || (layers.datalabels =
                        paper.group('datalabels').insertAfter(datasetLayer)),
                trackerLayer = layers.tracker,
                group,
                anchorGroup,
                lineGroup,
                anchorAnimation,
                valEle;


            // initially hide data values
            dataLabelsLayer.hide();

           //create series group
            group = datasetLayer;

            lineGroup = group.line || (group.line = paper.group('connector', group));
            anchorGroup = group.anchor || (group.anchor = paper.group('anchor', group));

           //draw data
           for (i = 0, ln = data.length; i < ln; i += 1) {
               set = data[i];
               marker = set.marker;
               xPos = yPos = setElem = valEle = hotElem = null;

               y = set.y;
               x = set.x;

               if (y !== null && x !== null) {

                   if (marker && marker.enabled) {
                        setLink = set.link;
                        toolText = set.toolText;
                        markerRadius = marker.radius;

                        yPos = yAxis.getAxisPosition(y);
                        xPos = xAxis.getAxisPosition(x);

                        symbol = marker.symbol.split('_');
                        setElem = paper.polypath(symbol[1] || 2, xPos, yPos,
                                  markerRadius, marker.startAngle, 0,
                                  anchorGroup)
                            .attr({
                                fill: toRaphaelColor(marker.fillColor),
                                'stroke-width': marker.lineWidth,
                                stroke: toRaphaelColor(marker.lineColor),
                                'cursor': setLink ? 'pointer' : '',
                                'visibility': seriesVisibility
                            })
                            .shadow(seriesOptions.shadow && set.shadow);

                         if (setLink || isTooltip) {
                            if (markerRadius < HTP) {
                                markerRadius = HTP;
                            }
                            hotElem = paper.circle(xPos, yPos,
                                markerRadius, trackerLayer)
                                .attr({
                                     'cursor': setLink ? 'pointer' : '',
                                     stroke: TRACKER_FILL,
                                     'stroke-width': marker.lineWidth,
                                     'fill': TRACKER_FILL,
                                     'ishot': !!setLink
                                })
                                .tooltip(toolText)
                                .data("link", setLink)
                                .click( function () {
                                    var link = this.data("link");
                                    link && chart.linkClickFN.call({
                                            link: link
                                        }, chart);
                                });

                         }

                   }

                    if (isLine) {
                        if (lastYPos === undefined ||
                                (lastYPos === null && connectNullData===0)) {
                            // move to the starting position of the line segment
                            xPos && yPos && linePath.push(M, xPos, COMMA, yPos);
                        }

                        xPos && yPos && linePath.push(L, xPos, COMMA, yPos);

                        lastXPos = xPos;
                        lastYPos = yPos;

                    }

                    plotItems[i] = {
                         index: i,
                         x: x,
                         y: y,
                         value: y,
                         graphic: setElem,
                         dataLabel: valEle,
                         tracker: hotElem
                    };
                    // Draw the dataLabel
                    valEle = chart.drawPlotLineLabel(plot, dataOptions, i, xPos, yPos);

               }
               else {
                    if (isLine && connectNullData === 0) {
                        lastXPos = lastYPos = null;
                    }
                    plotItems[i] = {
                        chart: chart,
                        index: i,
                        x: x,
                        y: y
                    };
               }

                valEle && datasetGraphics.push(valEle);
                setElem && datasetGraphics.push(setElem);
                hotElem && datasetGraphics.push(hotElem);

                chart.drawTracker &&
                        chart.drawTracker.call(chart, plot, dataOptions, i);

           }


            if (linePath.length) {
                connectorElem = plot.graphic = paper.path(linePath, lineGroup)
                    .attr({
                        'stroke-dasharray': dashStyle,
                        'stroke-width': lineWidth,
                        'stroke': lineColor,
                        'stroke-linecap': 'round',
                        'stroke-linejoin': lineWidth > MAX_MITER_LINEJOIN ?
                                                            'round' : 'miter',
                        'visibility': seriesVisibility
                    })
                    .shadow(seriesOptions.shadow && set.shadow);
                // clip-canvas animation to line
                lineGroup.attr({ 'clip-rect': elements['clip-canvas-init'] })
                     .animate(
                            { 'clip-rect': elements['clip-canvas'] },
                            animationDuration,
                            'normal'
                    );

                datasetGraphics.push(connectorElem);

            }

            // animation to anchors
            anchorAnimation = anchorGroup.attr({
                    'opacity': 0
                })
                .animate(
                    { 'opacity': 1 },
                    animationDuration,
                    'normal',
                    function () {
                        dataLabelsLayer.show();
                    }
                );

           plot.visible = (dataOptions.visible !== false);

           return plot;
        },

        drawPlotLineLabel: function (plot, dataOptions, i, xPos, yPos, dataLabelsLayer) {

            var chart = this,
                options = chart.options,
                chartOptions = options.chart,
                seriesOptions = options.plotOptions.series,
                paper = chart.paper,
                elements = chart.elements,
                layers = chart.layers,
                style = seriesOptions.dataLabels.style,
                rotateValues = chartOptions.rotateValues === 1 ? 270 : 0,
                canvasHeight = chart.canvasHeight,
                canvasTop = chart.canvasTop,
                plotItems = plot.items,
                data = plot.data,
                set = data[i],
                plotItem = plotItems[i],
                valuePosition = getValidValue(set.valuePosition,
                    'auto').toLowerCase(),
                seriesType = chart.logic.defaultSeriesType,
                valuePadding = chartOptions.valuePadding + GUTTER_2,
                seriesVisibility = dataOptions.visible === false ?
                        'hidden': 'visible',
                isNewElement = false,
                valEle = plotItem.dataLabel,
                yAdjust,
                yAdjust,
                topSpace,
                bottomSpace,
                prevDataObj,
                nextDataObj,
                placeValuesInside,
                textHeight,
                origTextHeight,
                textY,
                bBoxObj,
                displayValue;

            dataLabelsLayer = dataLabelsLayer || layers.datalabels;

            switch (valuePosition) {
                case 'above':
                    placeValuesInside = 0;
                break;
                case 'below':
                    placeValuesInside = 1;
                break;
                default:
                    prevDataObj = data[i - 1] || {};
                    nextDataObj = data[i + 1] || {};

                    placeValuesInside = !i ? 0 : prevDataObj.y >= set.y ? 1 :
                        (prevDataObj.y == null && nextDataObj.y) > set.y ? 1 : 0;
                break;
            }

            // Drawing of displayValue
            displayValue = set.displayValue;

            if (defined(displayValue) && displayValue !== BLANK) {
                // First render the value text

                if (!valEle) {

                    valEle = plotItem.dataLabel = paper.text()
                        .attr({
                            text: displayValue
                        })
                        .css(style);
                    isNewElement = true;
                }
                else {
                    rotateValues && valEle.rotate(360 - rotateValues);
                }

                valEle.attr({
                    title: (set.originalText || ''),
                    fill: style.color
                });

                // get the bBox to find height and width of the text.
                bBoxObj = valEle.getBBox();

                // If rotated values we use the width of the text as
                // height
                textHeight = origTextHeight = (rotateValues ? bBoxObj.width :
                    bBoxObj.height);
                textHeight += valuePadding;
                topSpace = yPos - canvasTop;
                bottomSpace = (canvasTop + canvasHeight) - yPos;
                textY = yPos;

                textHeight = textHeight + GUTTER_4;
                yAdjust = (origTextHeight * 0.5) + valuePadding;

                if (!/bubble/i.test(seriesType)) {
                    if (placeValuesInside) {
                        if (bottomSpace > textHeight) {
                            textY += yAdjust;
                            set._valueBelowPoint = 1;
                        }
                        else if (topSpace > textHeight) {
                            textY -= yAdjust;
                        }
                    } else {
                        if (topSpace > textHeight) {
                            textY -= yAdjust;
                        }
                        else if (bottomSpace > textHeight) {
                            textY += yAdjust;
                            set._valueBelowPoint = 1;
                        }
                    }
                }

                valEle.attr({
                    x: xPos,
                    y: textY,
                    visibility: seriesVisibility
                });

                rotateValues && valEle.attr('transform', 'T0,0,R' + rotateValues);
                isNewElement && dataLabelsLayer.appendChild(valEle);
                if(isNewElement && pluck(style.backgroundColor, style.borderColor) !== BLANK ) {
                    valEle.attr({
                        'text-bound': [style.backgroundColor, style.borderColor, 1, 2]
                    });
                }
            }
            else if (valEle) {
                valEle.attr({
                    text: BLANK
                });
            }
            return valEle;
        },

        drawLabels: function () {
            var chart = this,
                paper = chart.paper,
                options = chart.options,
                items = options.labels && options.labels.items &&
                    options.labels.items,
                ln = items && items.length,
                aboveDataset = chart.layers.layerAboveDataset,
                quadran = chart.elements.quadran || (chart.elements.quadran = []),
                marginTop = chart.canvasTop,
                marginLeft = chart.canvasLeft,
                textAnchor = {
                    right: POSITION_END,
                    left: POSITION_START,
                    'undefined': POSITION_START
                },
                style,
                textEle,
                labelObj;

            while (ln--) {
                labelObj = items[ln];
                style = labelObj.style;
                if (defined(labelObj.html) && labelObj.html !== BLANK) {
                    textEle = quadran[ln] = paper.text(aboveDataset)
                    .attr({
                        text: labelObj.html,
                        x: pInt(style.left, 10) + marginLeft,
                        y: pInt(style.top, 10) + marginTop,
                        fill: style.color,
                        'text-anchor': textAnchor[labelObj.textAlign],
                        'vertical-align': labelObj.vAlign
                    })
                    .css(style);
                }
            }
        }

    }, renderer['renderer.root']);

    /**
     * The renderering definition for pie series charts.
     *
     * @id TypeAPI['renderer.pie']
     * @returns TypeAPI
     */
    renderer('renderer.piebase', {
        drawCaption: function () {
            var chart = this,
                optionsChart = chart.options.chart,
                optionsCap = chart.options.title,
                optionsSubcap = chart.options.subtitle,
                paper = chart.paper,
                elements = chart.elements,
                layers = chart.layers,
                captionGroup = layers.caption,
                caption = elements.caption,
                subcaption = elements.subcaption,
                interCaptionGap = 2,
                hasCaption = (optionsCap && optionsCap.text),
                hasSubcaption = (optionsSubcap && optionsSubcap.text),
                canvasCentre = (paper.width / 2),
                captionX = optionsCap.x,
                subcaptionX = (optionsSubcap && optionsSubcap.x);

            // if captions are needed, then we need to ensure that it is placed
            // within a group.
            if (hasCaption || hasSubcaption) {
                if (!captionGroup) {
                    captionGroup = layers.caption = paper.group('caption');

                    if (layers.tracker) {
                        captionGroup.insertBefore(layers.tracker);
                    }
                    else {
                        captionGroup.insertAfter(layers.dataset);
                    }
                }
            }

            // if definition has caption, we proceed creating one and if there
            // is no caption we remove any previously created caption element.
            // captions are center aligned with respect to canvas and we
            // position them (cap and subcap) vertically one after another
            // and keep their v-align as top.
            if (hasCaption) {
                if (!caption) {
                    caption = elements.caption = paper.text(captionGroup);
                }

                if (captionX === undefined) {
                    captionX = canvasCentre;
                    optionsCap.align = POSITION_MIDDLE;
                }

                caption.css(optionsCap.style).attr({
                    text: optionsCap.text,
                    fill: optionsCap.style.color,
                    x: captionX,
                    y: (optionsCap.y || optionsChart.spacingTop || 0),
                    'text-anchor': (optionsCap.align) || POSITION_MIDDLE,
                    'vertical-align': 'top',
                    visibility: 'visible',
                    title: (optionsCap.originalText || '')
                });

            }
            else if (caption) {
                caption = elements.caption = caption.remove();
            }

            if (hasSubcaption) {
                if (!subcaption) {
                    subcaption = elements.subcaption = paper.text(captionGroup);
                }

                if (subcaptionX === undefined) {
                    subcaptionX = canvasCentre;
                    optionsSubcap.align = POSITION_MIDDLE;
                }

                subcaption.css(optionsSubcap.style).attr({
                    text: optionsSubcap.text,
                    title: (optionsSubcap.originalText || ''),
                    fill: optionsSubcap.style.color,
                    x: subcaptionX,
                    y: hasCaption ?
                        (caption.attrs.y + caption.getBBox().height + interCaptionGap) :
                        (optionsCap.y || optionsChart.spacingTop || 0),

                    'text-anchor': optionsSubcap.align || 'middle',
                    'vertical-align': 'top',
                    visibility: 'visible'
                });
            }
            else if (subcaption) {
                subcaption = elements.subcaption = subcaption.remove();
            }

            // if neither caption or subcaption is needed, we need to dump the
            // group as well.
            if (!(hasCaption || hasSubcaption || !captionGroup)) {
                captionGroup = layers.caption = captionGroup.remove();
            }
        },
        redrawDataLabels: function (chart) {
            var plot = chart.elements.plots[0];
            chart.placeDataLabels(true, plot.items, plot);
            return {};
        },
        plotGraphicClick: function () {
            var o = this,
                plotItem = o.graphic && o || o.data('plotItem'),
                //plotItem = o.data('plotItem'),
                seriesData = plotItem.seriesData,
                chart = plotItem.chart,
                index = plotItem.index,
                graphic,
                connector,
                dataLabel,
                sliced,
                slicedTranslation,
                connectorPath,
                transX,
                transY,
                reflowData,
                reflowUpdate;

            if (seriesData.isRotating  || seriesData.singletonCase) {
                return;
            }

            graphic = plotItem.graphic;
            connector = plotItem.connector;
            dataLabel = plotItem.dataLabel;
            sliced = plotItem.sliced;
            slicedTranslation = plotItem.slicedTranslation;
            connectorPath = plotItem.connectorPath;
            transX = (sliced ? -1 : 1) * plotItem.transX;
            transY = (sliced ? -1 : 1) * plotItem.transY;

            graphic.animate({
                transform: sliced ? 't0,0' : slicedTranslation
            }, 200, 'easeIn');

            if (dataLabel && dataLabel.x) {
                dataLabel.animate({
                    x: dataLabel.x + (sliced ? 0 : transX)
                }, 200, 'easeIn');
            }

            if (connectorPath) {
                connectorPath[1] += transX;
                connectorPath[2] += transY;
                connectorPath[4] += transX;
                connectorPath[6] += transX;

                connector.animate({
                    path: connectorPath
                }, 200, 'easeIn');
            }

            sliced = plotItem.sliced = !sliced;

            // save state
            reflowUpdate = {
                hcJSON: {
                    series: []
                }
            };
            reflowUpdate.hcJSON.series[0] = {
                data: reflowData = []
            };
            reflowData[index] = {sliced: sliced};
            extend2(chart.logic.chartInstance.jsVars._reflowData,
                        reflowUpdate, true);
            return sliced;
        },
        plotDragStart: function (x, y, evt) {
            var o = this,
                plotItem = o.data('plotItem'),
                chart = plotItem.chart,
                seriesData = plotItem.seriesData,
                datasets = chart.options.series,
                angle;

            if (!datasets[0].enableRotation) {
                return;
            }
            angle = getClickArcTangent.call(evt, x, y, seriesData.pieCenter,
                                                     seriesData.chartPosition);
            seriesData.dragStartAngle = angle;
            chart._pierotateActive = true;
        },
        plotDragEnd: function () {
            var o = this,
                plotItem = o.data('plotItem'),
                chart = plotItem.chart,
                // save state
                reflowUpdate = {
                    hcJSON: {
                        series: [{
                            startAngle: -chart.datasets[0].startAngle * 180 / pi
                        }]
                    }
                };
            if (!chart.disposed) {
                extend2(chart.logic.chartInstance.jsVars._reflowData,
                            reflowUpdate, true);

                chart.rotate(plotItem.seriesData, chart.options.series[0]);
            }
            /* The events mouseup, dragend and click are raised in order. In order
             * to update the flag isRotating to false post click event, setTimeout
             * called, to take immediate effect, is programmed to update the flag.
             * Thus, the flag gets updated post the series of events, in effect.
             * NB: Click event is subscribed conditionally.
             */
            setTimeout(function () {
                plotItem.seriesData.isRotating = false;
            }, 0);
        },
        plotDragMove: function (dx, dy, x, y, evt) {

            var o = this,
                plotItem = o.data('plotItem'),
                chart = plotItem.chart,
                seriesData = plotItem.seriesData,
                datasets = chart.options.series,
                angle;

            if (!datasets[0].enableRotation || seriesData.singletonCase) {
                return;
            }
            seriesData.isRotating = true;

            angle = getClickArcTangent.call(evt, x, y, seriesData.pieCenter,
                                                      seriesData.chartPosition);

            datasets[0].startAngle += (angle - seriesData.dragStartAngle);
            seriesData.dragStartAngle = angle;
            seriesData.moveDuration = 0;

            var currentTime = new Date().getTime();

            if (!seriesData._lastTime || (seriesData._lastTime + seriesData.timerThreshold < currentTime)) {
                setTimeout(function () {
                    chart.rotate(seriesData, datasets[0]);
                }, 0 );
                seriesData._lastTime  = currentTime;
            }
        },
        plotMouseDown: function (evt, x, y) {
             var o = this,
                plotItem = o.data('plotItem'),
                seriesData = plotItem.seriesData;

            seriesData.isRotating = false;
        },
        plotMouseUp: function (evt, x, y) {
             var o = this,
                plotItem = o.data('plotItem'),
                chart = plotItem.chart,
                seriesData = plotItem.seriesData;

            !seriesData.isRotating && chart.linkClickFN.call({
                link: seriesData.data[plotItem.index].link
            }, chart);

            if (R._supportsTouch && !seriesData.isRotating) {
                chart.plotGraphicClick.call(plotItem);
            }
        },
        legendClick: function(plot, isVisible, restrainEvent) {
            var chart = plot.chart,
                plots = chart.elements.plots[0];
            plots.isRotating = false;
            chart.plotGraphicClick.call(plot.graphic);

            if (restrainEvent !== true) {
                // fire legenditemclicked event
                eventArgs = {
                    datasetName: plot.label,
                    datasetIndex: plot.originalIndex,
                    id: plot.userID,
                    visible: isVisible,
                    label: plot.label,
                    value: plot.value,
                    percentValue: plot.percentage,
                    tooltext: plot.toolText,
                    link: plot.link,
                    sliced: !plot.sliced
                };
                global.raiseEvent('legenditemclicked', eventArgs, chart.logic.chartInstance);
            }
        },
        placeDataLabels: (function () {
            /*
             * Pie Helper Functions.
             */

            var sortArrayByPoint = function (a, b) {
                    return a.point.value - b.point.value;
                },
                sortArrayByAngle = function (a, b) {
                    return a.angle - b.angle;
                },
                alignments = ['start', 'start', 'end', 'end'],
                alignCenter = 'middle',
                ySign = [-1, 1, 1, -1],
                xSign = [1, 1, -1, -1];

            return function (isRotating, plotItems, plot, seriesData) {
                var chart = this,
                    plotOptions = chart.options.plotOptions,
                    piePlotOptions = plotOptions.pie,
                    cx = chart.canvasLeft + chart.canvasWidth * 0.5,
                    cy = chart.canvasTop + chart.canvasHeight * 0.5,
                    smartLabel = chart.smartLabel,
                    dataLabelsOptions = plotOptions.series.dataLabels,
                    style = dataLabelsOptions.style,
                    lineHeight = pluckNumber(mathCeil(parseFloat(style.lineHeight)), 12),
                    placeInside = getFirstValue(
                                    dataLabelsOptions.placeInside, false),
                    skipOverlapLabels = dataLabelsOptions.skipOverlapLabels,
                    manageLabelOverflow = dataLabelsOptions.manageLabelOverflow,
                    connectorPadding = dataLabelsOptions.connectorPadding,
                    distanceOption = dataLabelsOptions.distance,
                    

                    softConnector = getFirstValue(
                                        dataLabelsOptions.softConnector, true),
                    remainingHeight,
                    seriesCenter = seriesData && seriesData.metrics || [cx,
                                    cy,
                                    piePlotOptions.size,
                                    (piePlotOptions.innerSize || 0)],
                    centerY = seriesCenter[1],
                    centerX = seriesCenter[0],
                    radius = seriesCenter[2] * 0.5,
                    // divide the points into quarters for anti collision
                    quarters = [
                    [], // top right
                    [], // bottom right
                    [], // bottom left
                    [] // top left
                    ],
                    plotLeft = chart.canvasLeft,
                    plotTop = chart.canvasTop,
                    plotWidth = chart.canvasWidth,
                    dataLabelsRadius = plot.labelsRadius ||
                            (plot.labelsRadius = radius + distanceOption),
                    labelFontSize = parseInt(style.fontSize, 10),
                    labelHeight = labelFontSize,
                    halfLabelHeight = labelHeight / 2,
                    xDisplacement = [connectorPadding,
                                     connectorPadding,
                                     -connectorPadding,
                                     -connectorPadding],
                    maxLabels = plot.labelsMaxInQuadrant ||
                                (plot.labelsMaxInQuadrant = mathFloor(
                                           dataLabelsRadius / labelHeight)),
                    isSmartLineSlanted = dataLabelsOptions.isSmartLineSlanted,
                    innerRadius = seriesCenter[3] / 2,
                    align,
                    i,
                    labelWidth,
                    labelStr,
                    j,
                    oriY,
                    maxYmayHave,
                    spaceRequired,
                    length,
                    k,
                    sliced,
                    x1,
                    x2,
                    x3,
                    x4,
                    y1,
                    y2,
                    y3,
                    points,
                    point,
                    angle,
                    connector,
                    connectorPath,
                    excess,
                    excessArr,
                    labelQuadrantHeight,
                    maxQuadrantLabel,
                    dataLabel,
                    quarter,
                    transX,
                    transY,
                    smartLabelObj;

                // run parent method
                /**^
                 * Introduced the isRotating argument too to detect
                 * whether this is called during rotation.
                 */
                if (!isRotating) {
                    //do not set the style every time
                    // Do it for first time
                    smartLabel.setStyle(style);
                }

                // arrange points for detection collision
                // Creates an array of quarter containing labels of each
                // quarter if there has only one label the draw it inside
                if (plotItems.length == 1 && !innerRadius) {
                    point = plotItems[0];
                    dataLabel = point.dataLabel;
                    dataLabel.show();

                    point.slicedTranslation = [plotLeft, plotTop];
                    if (dataLabel) {
                        dataLabel.attr({
                            visibility: VISIBLE,
                            align: alignCenter,
                            transform: "t" + centerX + "," + (centerY
                                                      + halfLabelHeight - 2)
                        });
                        dataLabel.x = centerX;
                    }
                }
                else {
                    if (placeInside){
                        var centerDistance = innerRadius + ((radius
                                                        - innerRadius) / 2);
                        each(plotItems, function (point) {
                            dataLabel = point.dataLabel;
                            dataLabel.show();

                            if (dataLabel) {
                                var angle = point.angle;
                                y3 = centerY + (centerDistance *
                                      mathSin(angle)) + halfLabelHeight - 2;
                                x3 = centerX + (centerDistance * mathCos(angle));
                                dataLabel.x = x3;
                                // storing original x value
                                // to use while slicing in (IE Issue original
                                //  x get changed form animate)
                                dataLabel._x = x3;

                                dataLabel.y = y3;
                                if (point.sliced) {
                                    var slicedTranslation = point.slicedTranslation,
                                    transX = slicedTranslation[0] - plotLeft,
                                    transY = slicedTranslation[1] - plotTop;
                                    x3 = x3 + transX;
                                    y3 = y3 + transY;
                                }
                                dataLabel.attr({
                                    visibility: VISIBLE,
                                    align: alignCenter,
                                    transform: "t" + x3 + "," + y3
                                });
                            }
                        });
                    }
                    else {//outside
                        each(plotItems ,function(point) {
                            dataLabel = point.dataLabel;
                            dataLabel && dataLabel.show();

                            if (dataLabel) {
                                angle = point.angle % pi2;

                                if (angle < 0) {
                                    angle = pi2 + angle;
                                }
                                // Calculate bottom right quarter labels
                                if (angle >= 0 && angle < piBy2) {
                                    quarter = 1;
                                } else
                                // Calculate bottom left quarter labels
                                if (angle < pi) {
                                   quarter = 2;
                                } else
                                // Calculate top left quarter labels
                                if (angle < pi3By2) {
                                    quarter = 3;
                                }
                                // Calculate top right quarter labels
                                else {
                                    quarter = 0;
                                }

                                // Now put labels according to each quarter
                                quarters[quarter].push({
                                    point : point,
                                    angle : angle
                                });
                            }
                        });

                        i = k = 4;
                        //if excess then remove the low value slice first
                        while (i --) {
                            if (skipOverlapLabels) {
                                // Find labels can fit into the quarters or not
                                excess = quarters[i].length - maxLabels;
                                if (excess > 0) {
                                    // sort by point.value
                                    quarters[i].sort(sortArrayByPoint);
                                    // remove extra data form the array
                                    // which labels can not be fitted into
                                    // the quarters
                                    excessArr = quarters[i].splice(0, excess);
                                    //hide all removed labels
                                    for (j = 0, length = excessArr.length;
                                                       j < length; j += 1) {
                                        point = excessArr[j].point;
                                        point.dataLabel.attr({
                                            visibility: HIDDEN
                                        });
                                        if (point.connector) {
                                            point.connector.attr({
                                                visibility: HIDDEN
                                            });
                                        }
                                    }
                                }
                            }
                            // now we sort the data labels by its label angle
                            quarters[i].sort(sortArrayByAngle);
                        }

                        maxQuadrantLabel = mathMax(
                                quarters[0].length,
                                quarters[1].length,
                                quarters[2].length,
                                quarters[3].length
                            );
                        labelQuadrantHeight = mathMax(
                                mathMin(maxQuadrantLabel, maxLabels) * labelHeight,
                                dataLabelsRadius + labelHeight
                            );

                        // reverse 1st and 3rd quardent points
                        quarters[1].reverse();
                        quarters[3].reverse();

                        while (k --) {
                            points = quarters[k];
                            length = points.length;

                            if (!skipOverlapLabels) {
                                if (length > maxLabels) {
                                    labelHeight = labelQuadrantHeight / length;
                                }
                                else {
                                    labelHeight = labelFontSize;
                                }
                                halfLabelHeight = labelHeight / 2;
                            }


                            //1st pass
                            //place all labels at 1st quarter

                            // calculate the total available space to put labels
                            spaceRequired = length * labelHeight;
                            // calculate the remaining height
                            remainingHeight = labelQuadrantHeight;
                            //place all child point
                            for (i = 0; i < length; i += 1, spaceRequired -= labelHeight) {
                                // Get the y position of the label (radius
                                // where data label is to draw)
                                oriY = mathAbs(labelQuadrantHeight * mathSin(points[i].angle));

                                if (remainingHeight < oriY) {
                                    oriY = remainingHeight;
                                }
                                else if (oriY < spaceRequired) {
                                    oriY = spaceRequired;
                                }

                                remainingHeight = (points[i].oriY = oriY) - labelHeight;
                            }

                            //2nd pass(reverse)
                            align = alignments[k];
                            //place all labels at 1st quarter
                            maxYmayHave = labelQuadrantHeight - ((length - 1) * labelHeight);
                            remainingHeight = 0;

                            //place all child point
                            for (i = points.length - 1; i >= 0; i -= 1, maxYmayHave += labelHeight) {
                                point = points[i].point;
                                angle = points[i].angle;
                                sliced = point.sliced;
                                dataLabel = point.dataLabel;

                                oriY = mathAbs(labelQuadrantHeight * mathSin(angle));

                                if (oriY < remainingHeight) {
                                    oriY = remainingHeight;
                                }
                                else if (oriY > maxYmayHave) {
                                    oriY = maxYmayHave;
                                }

                                remainingHeight = oriY + labelHeight;

                                y1 = ((oriY + points[i].oriY) / 2);
                                x1 = centerX + xSign[k] * dataLabelsRadius * mathCos(math.asin(y1 / labelQuadrantHeight));
                                y1 *= ySign[k];
                                y1 += centerY;

                                y2 = centerY + (radius * mathSin(angle));
                                x2 = centerX + (radius * mathCos(angle));

                                // Relation: centerX <= connectorStartX <= connectorEndX (for right half and vice versa for left half)
                                (k < 2 && x1 < x2 || k > 1 && x1 > x2) && (x1 = x2);

                                x3 = x1 + xDisplacement[k];
                                y3 = y1 - halfLabelHeight - 2;
                                x4 = x3 + xDisplacement[k];

                                dataLabel.x = x4;
                                // storing original x value
                                // to use while slicing in (IE Issue original
                                // x get changed form animate)
                                dataLabel._x = x4;

                                if (manageLabelOverflow) {
                                    labelWidth = k > 1 ? x4 - chart.canvasLeft: chart.canvasLeft + plotWidth - x4;
                                    smartLabelObj = smartLabel.getSmartText(point.labelText,
                                                labelWidth, lineHeight);
                                    dataLabel.attr({
                                        text: smartLabelObj.text,
                                        title: (smartLabelObj.tooltext || '')
                                    });
                                }

                                dataLabel.y = y3;
                                if (sliced) {
                                        transX = point.transX;
                                        transY = point.transY;
                                        x3 = x3 + transX;
                                        x1 = x1 + transX;
                                        x2 = x2 + transX;
                                        y2 = y2 + transY;
                                        x4 = x4 + transX;
                                }

                                dataLabel.attr({
                                    visibility: VISIBLE,
                                    'text-anchor': align,
                                    vAlign: 'middle',
                                    x: x4,
                                    y: y1
                                });

                                // draw the connector
                                if ((connector = point.connector)) {
                                    point.connectorPath = connectorPath = [
                                    M,
                                    x2, y2, // base
                                    L,
                                    // first break, next to the label
                                    isSmartLineSlanted ? x1 : x2, y1,
                                    x3, y1  // end of the string at the label
                                    ];

                                    connector.attr({
                                        path: connectorPath,
                                        'visibility': VISIBLE
                                    });
                                }
                            }
                        }
                    }
                }
            };
        }())
    }, renderer['renderer.root']);

}]);
(function () {
    // Register the module with FusionCharts and also get access to a global
    // variable within the core's scope.
    var global = FusionCharts(['private', 'modules.renderer.js-interface']);
    // Check whether the module has been already registered. If true, then
    // do not bother to re-register.
    if (global === undefined) {
        return;
    }

    var

    STUB = 'stub',

    /**
     * Get a reference to the renderer specific global library store.
     */
    lib = global.hcLib,
    /**
     * Get a reference to the JavaScript renderer.
     */
    renderer = global.renderer.getRenderer('javascript'),
    hasModule = lib.hasModule,
    loadModule = lib.loadModule,
    moduleCmdQueue = lib.moduleCmdQueue,
    executeWaitingCommands = lib.executeWaitingCommands,
    injectModuleDependency = lib.injectModuleDependency,

    /**
     * List of chart types that are dependent on each module. There has to be
     * a one-to-one mapping to ensure that module is requested for loading
     * when it is rendered.
     */
    moduleDependencies = lib.moduleDependencies,

    /**
     * Find the relevant required module names from a given chart type.
     *
     * @param {string} type depermines the chart type (alias) that needs to
     * be looked up for dependent module names
     *
     * @type Array
     */
    getDependentModuleName = lib.getDependentModuleName,

    /**
     * List of events that has an equivalent legacy event. Used by the
     * raiseEvent method to check whether a particular event raised
     * has any corresponding legacy event.
     *
     * @type object
     */
    eventList = lib.eventList = {
        loaded: 'FC_Loaded',
        dataloaded: 'FC_DataLoaded',
        rendered: 'FC_Rendered',
        drawcomplete: 'FC_DrawComplete',
        resized: 'FC_Resized',
        dataxmlinvalid: 'FC_DataXMLInvalid',
        nodatatodisplay: 'FC_NoDataToDisplay',
        exported: 'FC_Exported'
    },

    /**
     * This method allows to uniformly raise events of FusionCharts
     * Framework.
     *
     * @param {string} name specifies the name of the event to be raised.
     * @param {object} args allows to provide an arguments object to be
     * passed on to the event listeners.
     * @param {FusionCharts} obj is the FusionCharts instance object on
     * behalf of which the event would be raised.
     * @param {Array} legacyArgs is an array of arguments to be passed on
     * to the equivalent legacy event.
     * @param {Event} source
     * @param {function} defaultFn
     *
     * @type undefined
     */
    raiseEvent = lib.raiseEvent = function (name, args, obj, legacyArgs,
            source, defaultFn) {
        var legacy = eventList[name];
        global.raiseEvent(name, args, obj, source, defaultFn);
        if (legacy && typeof window[legacy] === 'function') {
            setTimeout(function () {
                window[legacy].apply(window, legacyArgs);
            }, 0);
        }
    },

    /**
     * Function to check charts that are pending render process and are marked
     * as error in loading.
     */
    probeLoadErrorMessage = function (key) {
        var item,
            vars,
            type,
            modules,
            terminalModule,
            affectedModules = {},
            module;
        for (item in global.core.items) {
            item = global.core.items[item];
            type = item.chartType();
            vars = item.jsVars;

            if (vars && vars.waitingModule && item.__state.rendering &&
                    lib.needsModule(key, type)) {
                vars.waitingModuleError = true;
                modules = getDependentModuleName(type).concat(vars.userModules);
                if (modules.length) {
                    terminalModule = modules[modules.length - 1];
                    affectedModules[terminalModule] =
                        lib.moduleCmdQueue[terminalModule];
                }
            }
        }

        // Execute all the waiting queues that are affected due to lack of one
        // module.
        for (module in affectedModules) {
            executeWaitingCommands(affectedModules[module]);
        }

        // raise a global event
        global.raiseError(global.core, '11171116151', 'run', 'HC-interface~renderer.load',
            'Unable to load required modules and resources: ' + key);
    },

    /**
     * Function to display chart not supported message
     */
    showUnsupportedChartMessage = function (chartObj, container, callback) {
        global.hcLib.createChart(chartObj, container, STUB, callback,
                chartObj.jsVars.msgStore.ChartNotSupported);
    };

    /**
     * List of chart types for individual modules with corresponding load order
     * for the resource.
     * This is the default chart types under the "charts" group.
     *
     * @type object
     */
    moduleDependencies.charts = global.extend(moduleDependencies.charts || {}, {
        column2d: 0,
        column3d: 0,
        bar2d: 0,
        bar3d: 0,
        pie2d: 0,
        pie3d: 0,
        line: 0,
        bar2d: 0,
        area2d: 0,
        doughnut2d: 0,
        doughnut3d: 0,
        pareto2d: 0,
        pareto3d: 0,
        mscolumn2d: 0,
        mscolumn3d: 0,
        msline: 0,
        msarea: 0,
        msbar2d: 0,
        msbar3d: 0,
        stackedcolumn2d: 0,
        marimekko: 0,
        stackedcolumn3d: 0,
        stackedarea2d: 0,
        stackedcolumn2dline: 0,
        stackedcolumn3dline: 0,
        stackedbar2d: 0,
        stackedbar3d: 0,
        msstackedcolumn2d: 0,
        mscombi2d: 0,
        mscombi3d: 0,
        mscolumnline3d: 0,
        mscombidy2d: 0,
        mscolumn3dlinedy: 0,
        stackedcolumn3dlinedy: 0,
        msstackedcolumn2dlinedy: 0,
        scatter: 0,
        bubble: 0,
        ssgrid: 0,
        scrollcolumn2d: 0,
        scrollcolumn3d: 0,
        scrollline2d: 0,
        scrollarea2d: 0,
        scrollstackedcolumn2d: 0,
        scrollcombi2d: 0,
        scrollcombidy2d: 0,
        zoomline: 0
    });

    /**
     * List of chart types for individual modules with corresponding load order
     * for the resource.
     * This is the default chart types under the "powercharts" group.
     *
     * @type object
     */
    moduleDependencies.powercharts = global.extend(moduleDependencies.powercharts || {}, {
        spline: 0,
        splinearea: 0,
        msspline: 0,
        mssplinearea: 0,
        multiaxisline: 0,
        multilevelpie: 0,
        waterfall2d: 0,
        msstepline: 0,
        inversemsline: 0,
        inversemscolumn2d: 0,
        inversemsarea: 0,
        errorbar2d: 0,
        errorscatter: 0,
        errorline: 0,
        logmsline: 0,
        logmscolumn2d: 0,
        radar: 0,
        dragnode: 0,
        candlestick: 0,
        selectscatter: 0,
        dragcolumn2d: 0,
        dragline: 0,
        dragarea: 0,
        boxandwhisker2d: 0,
        kagi: 0,
        heatmap: 0
    });

    /**
     * List of chart types for individual modules with corresponding load order
     * for the resource.
     * This is the default chart types under the "widgets" group.
     *
     * @type object
     */
    moduleDependencies.widgets = global.extend(moduleDependencies.widgets || {}, {
        angulargauge: 0,
        bulb: 0,
        cylinder: 0,
        drawingpad: 0,
        funnel: 0,
        hbullet: 0,
        hled: 0,
        hlineargauge: 0,
        vlineargauge: 0,
        pyramid: 0,
        realtimearea: 0,
        realtimecolumn: 0,
        realtimeline: 0,
        realtimelinedy: 0,
        realtimestackedarea: 0,
        realtimestackedcolumn: 0,
        sparkcolumn: 0,
        sparkline: 0,
        sparkwinloss: 0,
        thermometer: 0,
        vbullet: 0,
        gantt: 0,
        vled: 0
    });

    /**
     * List of chart types for individual modules with corresponding load order
     * for the resource.
     * This is the default chart types under the "maps" group.
     *
     * @type object
     */
    moduleDependencies.maps = global.extend(moduleDependencies.maps || {}, { });

    // Update renderer functions with functions that are intended to
    global.extend(renderer, {

        render: function (container, callback) {
            /* algorithm:
             * 1. If JS Renderer is not ready then queue the chart.
             * 2. Prepare the chart DOM element
             * 3. Send the chart for rendering if JS Renderer is ready
             */

            var chartObj = this,
                chartType = chartObj.chartType(),
                vars = chartObj.jsVars,
                state = chartObj.__state,
                chartAPI = lib.chartAPI,
                objModuleNames,
                cmdQueue;

            // vars.userModules has been validated from renderer's
            // BeforeInitialize event and is also part of policy
            objModuleNames = getDependentModuleName(chartType)
                    .concat(vars.userModules);

            // If chart is resizing... prevent it.
            if (vars.isResizing) {
                vars.isResizing = clearTimeout(vars.isResizing);
            }

            // Destroy old chart if needed during update.
            vars.hcObj && vars.hcObj.destroy && vars.hcObj.destroy();

            if (!chartAPI[chartType]) { // check presence of API

                // Set command queue based on stock modules or dynamic modules
                if (hasModule(objModuleNames)) {
                    // Try loading the filename and see if that works!
                    if (!vars.drLoadAttempted) {
                        // Add a commandqueue and corresponding dummy dynamic
                        // dependency definition for this chart.
                        if (injectModuleDependency(chartType)) {
                            // since injection took place for first time, we
                            // need to correct the present dependency list.
                            objModuleNames = getDependentModuleName(chartType)
                                .concat(vars.userModules);
                        };

                        vars.drLoadAttempted = true;
                    }
                    else {
                        // If chart api is absent but all modules are present, we
                        // assume charts are not supported, provided a dynamic load
                        // has been attempted.
                        global.raiseError(chartObj, 11112822001, 'run',
                            'HC-interface~renderer.render',
                            'Chart runtimes not loaded even when resource is present');
                        showUnsupportedChartMessage(chartObj, container, callback);
                        return;
                    }
                }
                // Check whether this is a valid chart type as per static
                // dependency list (this block will be executed when dynamic
                // resource load is not attempted)
                else if (!objModuleNames.length) {
                    showUnsupportedChartMessage(chartObj, container, callback);
                    return;
                }
                else if (vars.waitingModuleError) {
                    showUnsupportedChartMessage(chartObj, container, callback);
                    // If error is displayed wrt module absence, clear all
                    // flags wrt module load wait. This is done so that next
                    // re-render tries to execute the same load algo.
                    delete vars.waitingModule;
                    delete vars.waitingModuleError;
                    return;
                }

                // Get reference to the command queue for the terminal module.
                cmdQueue = moduleCmdQueue[objModuleNames[objModuleNames.length - 1]];

                if (cmdQueue) {
                    cmdQueue.push({
                        cmd: 'render',
                        obj: chartObj,
                        args: arguments
                    });
                }
                // In case a reference to the command queue has not been found,
                // raise an error.
                else {
                    global.raiseError(chartObj, 12080515551, 'run',
                        'HC-interface~renderer.render',
                        'Unregistered module in dependentModule definition.');
                    global.hcLib.createChart(chartObj, container, STUB, undefined,
                        vars.msgStore.RenderChartErrorText);
                    return;
                }

                if (!vars.waitingModule) {
                    // Show loading message if not already shown
                    global.hcLib.createChart(chartObj, container, STUB, undefined,
                        vars.msgStore.PBarLoadingText || vars.msgStore.LoadingText);
                    renderer.load.call(chartObj);
                }
                return;
            }

            // Need to delete earlier eiMethods.
            if (chartAPI[state.lastRenderedType] &&
                    state.lastRenderedType !== chartType) {
                for (var eiMethod in chartAPI[state.lastRenderedType].eiMethods) {
                    delete chartObj[eiMethod];
                }

            }
            // Updated last-rendererd type to current type.
            state.lastRenderedType = chartType;

            // Store a copy of the currently rendered src value for later
            // use while comparing during update.
            state.lastRenderedSrc = chartObj.src;
            delete vars.waitingModule;
            delete vars.waitingModuleError;
            delete vars.drLoadAttempted; // remove flag for next.

            // Call renderer to generate FusionCharts.
            global.hcLib.createChart(chartObj, container, chartType, callback);
        },

        update: function (param) {
            var chartObj = this,
                chart = chartObj.ref, vars = chartObj.jsVars;

            // Destroy old chart if needed during update.
            vars.hcObj && vars.hcObj.destroy && vars.hcObj.destroy();

            if (vars.isResizing) {
                vars.isResizing = clearTimeout(vars.isResizing);
            }

            // Check whether there was an error or not.
            if (param.error === undefined) {
                delete vars.stallLoad;
                delete vars.loadError;
                // Call ExternalInterface method and update the data
                if (this.isActive()) {
                    if (chartObj.src !== chartObj.__state.lastRenderedSrc) {
                        chartObj.render();
                    }
                    else {
                        // Call renderer to generate FusionCharts.
                        global.hcLib.createChart(chartObj, vars.container, vars.type);
                    }
                }
            }
            // Show error message.
            else {
                // Call ExternalInterface method to show message
                if (this.isActive() && typeof chart.showChartMessage === 'function') {
                    chart.showChartMessage('InvalidXMLText');
                }
                delete vars.loadError;
            }
        },

        resize: function (size) {
            var container = this.ref,
            cssSize,
            vars = this.jsVars;

            // Set the sizes of the DOM elements for the resize and fire related
            // commands needed for resize.
            if (!(container && container.resize)) {
                return;
            }

            if (vars.isResizing) { // need to be cleared on other interface fns
                vars.isResizing = clearTimeout(vars.isResizing);
            }

            // resize chart async so that consecutive resizes can be blocked
            vars.isResizing = setTimeout(function () {
                cssSize = global.normalizeCSSDimension(size.width, size.height,
                    container);
                if (size.width !== undefined) {
                    container.style.width = cssSize.width;
                }
                if (size.height !== undefined) {
                    container.style.height = cssSize.height;
                }

                container.resize();
                delete vars.isResizing;
            }, 0);
        },

        dispose: function () {
            var container,
                vars = this.jsVars,
                hcObj = vars.hcObj || {};

            if (vars.isResizing) {
                vars.isResizing = clearTimeout(vars.isResizing);
            }

            // do chartAPI instance cleanup
            vars.instanceAPI && vars.instanceAPI.dispose &&
                vars.instanceAPI.dispose();

            // Proceed with disposal only when the HTML element exists.
            if ((container = this.ref)) {
                global.purgeDOM(container);
                // Delete DOM element
                if (container.parentNode) {
                    container.parentNode.removeChild(container);
                }
            }

            // On dispose remove any waiting commands.
            lib.cleanupWaitingCommands(this);

            return hcObj && hcObj.destroy && hcObj.destroy();
        },

        load: function () {
            var chart = this,
                vars = chart.jsVars,
                type = chart.chartType(),
                api = global.hcLib.chartAPI[type],
                // merge with user modules while loading dependencies
                modules = getDependentModuleName(type).concat(vars.userModules),
                terminalModule = modules[modules.length - 1];

            if (api || !modules || (modules && modules.length === 0)) {
                delete vars.waitingModule;
                return;
            }

            // Request load of the specific chart module
            if (!vars.waitingModule) {
                // Mark the object that it is waiting for module load.
                vars.waitingModule = true;
                delete vars.waitingModuleError;

                loadModule(modules, function () {
                    delete vars.waitingModule;
                    executeWaitingCommands(lib.moduleCmdQueue[terminalModule]);
                }, probeLoadErrorMessage, chart);
                // Above: Since this may not be the terminal module for all
                // charts, we need to check and raise error on all modules.
            }
        }
    });


})();


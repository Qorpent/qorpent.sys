using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Xml.Linq;
using Qorpent.BSharp;
using Qorpent.Utils.Extensions;

namespace Qorpent.Scaffolding.Orm{
	/// <summary>
	/// Задача по генерации Poko-классов модели на основе DataMapping,
	/// данные классы являются PurePOKO, то есть даже не наследуют никаких интерфейсов
	/// </summary>
	/// <remarks>Единственная опциональная завязка на Qorpent в этой генерации - отключаемые атрибуты Serialize</remarks>
	public class GeneratePokoClasses: CodeGeneratorTaskBase
	{
		private StringBuilder o;

		/// <summary>
		/// 
		/// </summary>
		public GeneratePokoClasses()
			: base()
		{
			ClassSearchCriteria = "dbtable";
			DefaultOutputName = "Orm";
		}

		/// <summary>
		/// 
		/// </summary>
		private const string Header = "/*" + Production.AUTOGENERATED_MASK + "*/\r\n" + @"
//////////////////////////////////////////////////////////////////////
////       AUTO-GENERATED WITH  GeneratePokoClasses     ////
//////////////////////////////////////////////////////////////////////
";
		/// <summary>
		/// 
		/// </summary>
		/// <param name="targetclasses"></param>
		/// <returns></returns>
		protected override IEnumerable<Production> InternalGenerate(IBSharpClass[] targetclasses){
			foreach (var targetclass in targetclasses){
				var prod = new Production{
					FileName = "DataTypes/" +targetclass.Name + ".cs",
					GetContent = () => GenerateSingleClass(targetclass)
				};
				yield return prod;
			}
		}

	

		/// <summary>
		/// Формирует POKO класс на основе мапинга
		/// </summary>
		/// <param name="targetclass"></param>
		/// <returns></returns>
		private string GenerateSingleClass(IBSharpClass targetclass){
			o = new StringBuilder();
			var x = targetclass.Compiled;
			WriteStartClass(targetclass, x);	
			GenerateOwnFields(targetclass, x);
			GenerateIncomeReferences(targetclass);
			WriteEndClass();
			return o.ToString();
		}

		private void GenerateIncomeReferences(IBSharpClass targetclass){
			var incomerefs = FindIncomeRefes(targetclass).OrderBy(_ => _.Item1.Name).ThenBy(_ => _.Item2.Attr("code")).ToArray();
			foreach (var incomeref in incomerefs){
				var name = incomeref.Item2.Attr("code");
				var basename = incomeref.Item1.Name + (incomeref.Item1.Name.EndsWith("s") ? "es" : "s");
				if (name == targetclass.Name){
					name = basename;
				}
				else{
					name = basename + "By" + incomeref.Item2.Attr("code");
				}
				var clsname = incomeref.Item1.Name;
				if (incomeref.Item1.Namespace != targetclass.Namespace){
					clsname = incomeref.Item1.FullName;
				}
				GenerateField(incomeref.Item2, "IList<" + clsname + ">", name, "(" + incomeref.Item1.Name + "  привязка )",
				              "?? (_" + name.ToLower() + " = new List<" + clsname + ">())");
			}
		}

		private void GenerateOwnFields(IBSharpClass targetclass, XElement x){
			foreach (var of in targetclass.GetOrmFields()){
				var e = of.Item2;
				var dtype = of.Item3;
				var name = e.Attr("code");
				if (e.Name.LocalName == "ref")
				{
					GenerateRef(targetclass, e, name);
					if (e.Attr("code") == "Parent")
					{
						GenerateField(e, "IList<" + targetclass.Name + ">", "Children", "Дочерние объекты",
									  " ?? (_children = new List<" + targetclass.Name + ">())");
					}
				}
				else
				{
					if (name == "Idx")
					{
						name = "Index";
					}
					GenerateField(e, dtype, name);
				}
			}

		}

		

		private IEnumerable<Tuple<IBSharpClass, XElement>> FindIncomeRefes(IBSharpClass t){
			var tables = _context.ResolveAll("dbtable");
			foreach (var s in tables){
				var refs = s.Compiled.Elements("ref");
				foreach (var r in refs){
					if(r.Attr("code")=="Parent")continue;
					var to = r.Attr("to");
					if (string.IsNullOrWhiteSpace(to)){
						to = r.Attr("code") + ".Id";
					}
					var fld = to.Split('.').Last();
					var cls = to.Substring(0, to.Length - fld.Length - 1);
					if (t.Name == cls || t.Compiled.Attr("fullname") == cls){
						yield return new Tuple<IBSharpClass,XElement>(s,r);
					}
				}
			}
		}

		private void GenerateRef(IBSharpClass targetclass, XElement e, string name){
			string dtype;
			var refval = e.Attr("to");
			if (string.IsNullOrWhiteSpace(refval)){
				refval = name + ".Id";
			}
			var fld = refval.Split('.').Last();
			if (fld == "Id"){
				dtype = "Int32";
			}
			else{
				dtype = "String";
			}
			GenerateField(e, dtype, name + fld, "(Идентификатор)");
			dtype = refval.Substring(0, refval.Length - fld.Length - 1);

			var clsname = dtype.Split('.').Last();
			var cls = _context.Get(clsname);
			string nsname = cls.Namespace;

			if (nsname == targetclass.Namespace){
				dtype = cls.Name;
			}
			else{
				dtype = cls.FullName;
			}
			GenerateField(e, dtype, name);
		}

		private void GenerateField(XElement e, string dtype, string name, string subcomment=null, string init = null){
			var sermode = e.Attr("serialize");
			string serattribute = null;
			if (!string.IsNullOrWhiteSpace(sermode)){
				if ("ignore" == sermode){
					serattribute = "IgnoreSerialize";
				}
				else if ("notnull" == sermode){
					serattribute = "SerializeNotNullOnly";
				}
				else{
					serattribute = "Serialize";
				}
			}

			o.AppendLine("\t\t///<summary>");
			o.AppendLine("\t\t///" + e.Attr("name")+" "+subcomment);
			o.AppendLine("\t\t///</summary>");
			if (e.Attr("comment").ToBool()){
				o.AppendLine("\t\t///<remarks>" + e.Attr("comment") + "</remarks>");
			}
			if (null != serattribute){
				o.AppendLine("#if !NOQORPENT");
				o.AppendLine("\t\t[" + serattribute + "]");
				o.AppendLine("#endif");
			}
			o.AppendFormat("\t\tpublic virtual {0} {1} {{get {{return _{2}{3};}} set{{_{2}=value;}}}}\r\n", dtype, name,
			               name.ToLower(),init);
			o.AppendLine("\t\t///<summary>Direct access to " + name + "</summary>");
			o.AppendFormat("\t\tprotected {0} _{1};\r\n", dtype, name.ToLower());
			o.AppendLine();
		}

		private void WriteEndClass(){
			o.AppendLine("\t}");
			o.AppendLine("}");
		}

		private void WriteStartClass(IBSharpClass targetclass, XElement x){
			o.AppendLine(Header);
			o.AppendLine("using System;");
			o.AppendLine("using System.Collections.Generic;");
			o.AppendLine("#if !NOQORPENT");
			o.AppendLine("using Qorpent.Serialization;");
			o.AppendLine("using Qorpent.Model;");
			o.AppendLine("#endif");
			o.AppendFormat("namespace {0} {{\r\n", targetclass.Namespace);
			o.AppendLine("\t///<summary>");
			o.AppendLine("\t///" + x.Attr("name"));
			o.AppendLine("\t///</summary>");
			o.AppendLine("#if !NOQORPENT");
			o.AppendLine("\t[Serialize]");
			o.AppendFormat("\tpublic partial class {0} ",targetclass.Name);
			var interfaces = targetclass.Compiled.Elements("qorpent-interface").OrderBy(_=>_.Attr("code"));
			var fst = true;
			foreach (var i in interfaces){
				if (fst){
					o.Append(": ");
					fst = false;
				}
				else{
					o.Append(", ");
				}
				o.Append(i.Attr("code"));
			}
			o.AppendLine(" {");
			o.AppendLine("#else");
			o.AppendFormat("\tpublic partial class {0} {{\r\n", targetclass.Name);
			o.AppendLine("#endif");
		}
	}
}